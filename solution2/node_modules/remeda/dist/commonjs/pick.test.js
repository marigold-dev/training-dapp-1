"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var pick_1 = require("./pick");
var pipe_1 = require("./pipe");
var concat_1 = require("./concat");
describe('data first', function () {
    test('it should pick props', function () {
        var result = pick_1.pick({ a: 1, b: 2, c: 3, d: 4 }, ['a', 'd']);
        expect(result).toStrictEqual({ a: 1, d: 4 });
    });
    test('allow undefined or null', function () {
        expect(pick_1.pick(undefined, ['foo'])).toEqual({});
        expect(pick_1.pick(null, ['foo'])).toEqual({});
    });
    test('support inherited properties', function () {
        var BaseClass = /** @class */ (function () {
            function BaseClass() {
            }
            BaseClass.prototype.testProp = function () { return 'abc'; };
            ;
            return BaseClass;
        }());
        var TestClass = /** @class */ (function (_super) {
            __extends(TestClass, _super);
            function TestClass() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return TestClass;
        }(BaseClass));
        var testClass = new TestClass();
        expect(pick_1.pick(testClass, ['testProp'])).toEqual({ testProp: expect.any(Function) });
    });
});
describe('data last', function () {
    test('it should pick props', function () {
        var result = pipe_1.pipe({ a: 1, b: 2, c: 3, d: 4 }, pick_1.pick(['a', 'd']));
        expect(result).toEqual({ a: 1, d: 4 });
    });
});
test('read only', function () {
    concat_1.concat([1, 2], [3, 4]);
    // or similar:
    // const props: ReadonlyArray<string> = ["prop1", "prop2"];
    // const getProps = <T extends string>(props: readonly T[]) => props;
    var someObject = { prop1: 'a', prop2: 2, a: 'b' };
    var props = ['prop1', 'prop2'];
    pick_1.pick(someObject, props); // TS2345 compilation error
});
