import { LazyResult } from './_reduceLazy';
declare type Flatten<T> = T extends ReadonlyArray<infer K> ? K : T;
/**
 * Flattens `array` a single level deep.
 * Note: In `pipe`, use `flatten()` form instead of `flatten`. Otherwise, the inferred type is lost.
 
 * @param items the target array
 * @signature R.flatten(array)
 * @example
 *    R.flatten([[1, 2], [3], [4, 5]]) // => [1, 2, 3, 4, 5]
 *    R.pipe(
 *      [[1, 2], [3], [4, 5]],
 *      R.flatten(),
 *    ); // => [1, 2, 3, 4, 5]
 * @category Array
 * @pipeable
 */
export declare function flatten<T>(items: readonly T[]): Array<Flatten<T>>;
export declare function flatten<T>(): (items: readonly T[]) => Array<Flatten<T>>;
export declare namespace flatten {
    function lazy<T>(): (next: T) => LazyResult<any>;
}
export {};
//# sourceMappingURL=flatten.d.ts.map