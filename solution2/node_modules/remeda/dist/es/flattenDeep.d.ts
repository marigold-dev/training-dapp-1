import { LazyResult } from './_reduceLazy';
declare type FlattenDeep<T> = T extends ReadonlyArray<infer K> ? FlattenDeep2<K> : T;
declare type FlattenDeep2<T> = T extends ReadonlyArray<infer K> ? FlattenDeep3<K> : T;
declare type FlattenDeep3<T> = T extends ReadonlyArray<infer K> ? FlattenDeep4<K> : T;
declare type FlattenDeep4<T> = T extends ReadonlyArray<infer K> ? K : T;
/**
 * Recursively flattens `array`.
 * Note: In `pipe`, use `flattenDeep()` form instead of `flattenDeep`. Otherwise, the inferred type is lost.
 * @param items the target array
 * @signature R.flattenDeep(array)
 * @example
 *    R.flattenDeep([[1, 2], [[3], [4, 5]]]) // => [1, 2, 3, 4, 5]
 *    R.pipe(
 *      [[1, 2], [[3], [4, 5]]],
 *      R.flattenDeep(),
 *    ); // => [1, 2, 3, 4, 5]
 * @category Array
 * @pipeable
 */
export declare function flattenDeep<T>(items: readonly T[]): Array<FlattenDeep<T>>;
export declare function flattenDeep<T>(): (items: readonly T[]) => Array<FlattenDeep<T>>;
export declare namespace flattenDeep {
    function lazy(): (value: any) => LazyResult<any>;
}
export {};
//# sourceMappingURL=flattenDeep.d.ts.map