var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// ../node_modules/sanctuary-type-identifiers/index.js
var require_sanctuary_type_identifiers = __commonJS({
  "../node_modules/sanctuary-type-identifiers/index.js"(exports, module) {
    (function(f) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd != null) {
        define([], f);
      } else {
        self.sanctuaryTypeIdentifiers = f();
      }
    })(function() {
      "use strict";
      var $$type3 = "@@type";
      var pattern = new RegExp(
        "^([\\s\\S]+)/([\\s\\S]+?)(?:@([0-9]+))?$"
      );
      function type4(x) {
        return x != null && x.constructor != null && x.constructor.prototype !== x && typeof x[$$type3] === "string" ? x[$$type3] : Object.prototype.toString.call(x).slice(
          "[object ".length,
          -"]".length
        );
      }
      type4.parse = function parse(s) {
        var namespace2 = null;
        var name2 = s;
        var version2 = 0;
        var groups = pattern.exec(s);
        if (groups != null) {
          namespace2 = groups[1];
          name2 = groups[2];
          if (groups[3] != null)
            version2 = Number(groups[3]);
        }
        return { namespace: namespace2, name: name2, version: version2 };
      };
      return type4;
    });
  }
});

// ../node_modules/sanctuary-show/index.js
var require_sanctuary_show = __commonJS({
  "../node_modules/sanctuary-show/index.js"(exports, module) {
    (function(f) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd != null) {
        define([], f);
      } else {
        self.sanctuaryShow = f();
      }
    })(function() {
      "use strict";
      var $$show = "@@show";
      var seen = [];
      function entry(o) {
        return function(k) {
          return show(k) + ": " + show(o[k]);
        };
      }
      function sortedKeys(o) {
        return Object.keys(o).sort();
      }
      function show(x) {
        if (seen.indexOf(x) >= 0)
          return "<Circular>";
        switch (Object.prototype.toString.call(x)) {
          case "[object Boolean]":
            return typeof x === "object" ? "new Boolean (" + show(x.valueOf()) + ")" : x.toString();
          case "[object Number]":
            return typeof x === "object" ? "new Number (" + show(x.valueOf()) + ")" : 1 / x === -Infinity ? "-0" : x.toString(10);
          case "[object String]":
            return typeof x === "object" ? "new String (" + show(x.valueOf()) + ")" : JSON.stringify(x);
          case "[object Date]":
            return "new Date (" + show(isNaN(x.valueOf()) ? NaN : x.toISOString()) + ")";
          case "[object Error]":
            return "new " + x.name + " (" + show(x.message) + ")";
          case "[object Arguments]":
            return "function () { return arguments; } (" + Array.prototype.map.call(x, show).join(", ") + ")";
          case "[object Array]":
            seen.push(x);
            try {
              return "[" + x.map(show).concat(
                sortedKeys(x).filter(function(k) {
                  return !/^\d+$/.test(k);
                }).map(entry(x))
              ).join(", ") + "]";
            } finally {
              seen.pop();
            }
          case "[object Object]":
            seen.push(x);
            try {
              return $$show in x && (x.constructor == null || x.constructor.prototype !== x) ? x[$$show]() : "{" + sortedKeys(x).map(entry(x)).join(", ") + "}";
            } finally {
              seen.pop();
            }
          case "[object Set]":
            seen.push(x);
            try {
              return "new Set (" + show(Array.from(x.values())) + ")";
            } finally {
              seen.pop();
            }
          case "[object Map]":
            seen.push(x);
            try {
              return "new Map (" + show(Array.from(x.entries())) + ")";
            } finally {
              seen.pop();
            }
          default:
            return String(x);
        }
      }
      return show;
    });
  }
});

// ../node_modules/pvtsutils/build/index.js
var require_build = __commonJS({
  "../node_modules/pvtsutils/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    var BufferSourceConverter = class {
      static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
      static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data).slice().buffer;
      }
      static toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
      static toView(data, type4) {
        if (data.constructor === type4) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type4(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type4(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
      static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
      static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
      static isEqual(a, b) {
        const aView = BufferSourceConverter.toUint8Array(a);
        const bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (let i = 0; i < aView.length; i++) {
          if (aView[i] !== bView[i]) {
            return false;
          }
        }
        return true;
      }
      static concat(...args) {
        if (Array.isArray(args[0])) {
          const buffers = args[0];
          let size = 0;
          for (const buffer of buffers) {
            size += buffer.byteLength;
          }
          const res = new Uint8Array(size);
          let offset = 0;
          for (const buffer of buffers) {
            const view = this.toUint8Array(buffer);
            res.set(view, offset);
            offset += view.length;
          }
          if (args[1]) {
            return this.toView(res, args[1]);
          }
          return res.buffer;
        } else {
          return this.concat(args);
        }
      }
    };
    var Utf8Converter = class {
      static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
          uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
      }
      static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for (let i = 0; i < buf.length; i++) {
          encodedString += String.fromCharCode(buf[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    };
    var Utf16Converter = class {
      static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
          const code = dataView.getUint16(i, littleEndian);
          res += String.fromCharCode(code);
        }
        return res;
      }
      static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView = new DataView(res);
        for (let i = 0; i < text.length; i++) {
          dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
      }
    };
    var Convert = class {
      static isHex(data) {
        return typeof data === "string" && /^[a-z0-9]+$/i.test(data);
      }
      static isBase64(data) {
        return typeof data === "string" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);
      }
      static isBase64Url(data) {
        return typeof data === "string" && /^[a-zA-Z0-9-_]+$/i.test(data);
      }
      static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          case "utf16le":
            return Utf16Converter.toString(buf, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static FromString(str, enc = "utf8") {
        if (!str) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          case "utf16le":
            return Utf16Converter.fromString(str, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
          const binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf).toString("base64");
        }
      }
      static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
      static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
      static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text);
          case "utf8":
            return Utf8Converter.fromString(text);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer);
          case "utf8":
            return Utf8Converter.toString(buffer);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
          resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
      }
      static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for (let i = 0; i < buf.length; i++) {
          res += String.fromCharCode(buf[i]);
        }
        return res;
      }
      static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        const splitter = "";
        const res = [];
        const len = buf.length;
        for (let i = 0; i < len; i++) {
          const char = buf[i].toString(16).padStart(2, "0");
          res.push(char);
        }
        return res.join(splitter);
      }
      static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i = 0; i < formatted.length; i = i + 2) {
          const c = formatted.slice(i, i + 2);
          res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
      }
      static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
      }
      static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
      }
      static Base64Padding(base64) {
        const padCount = 4 - base64.length % 4;
        if (padCount < 4) {
          for (let i = 0; i < padCount; i++) {
            base64 += "=";
          }
        }
        return base64;
      }
      static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    };
    Convert.DEFAULT_UTF8_ENCODING = "utf8";
    function assign(target, ...sources) {
      const res = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
          res[prop] = obj[prop];
        }
      }
      return res;
    }
    function combine(...buf) {
      const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
      const res = new Uint8Array(totalByteLength);
      let currentPos = 0;
      buf.map((item) => new Uint8Array(item)).forEach((arr) => {
        for (const item2 of arr) {
          res[currentPos++] = item2;
        }
      });
      return res.buffer;
    }
    function isEqual(bytes1, bytes2) {
      if (!(bytes1 && bytes2)) {
        return false;
      }
      if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b2 = new Uint8Array(bytes2);
      for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.BufferSourceConverter = BufferSourceConverter;
    exports.Convert = Convert;
    exports.assign = assign;
    exports.combine = combine;
    exports.isEqual = isEqual;
  }
});

// ../node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../node_modules/tslib/tslib.js"(exports, module) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory41) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory41(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory41(createExporter(root, createExporter(module.exports)));
      } else {
        factory41(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t2[p] = s[p];
        }
        return t2;
      };
      __rest = function(s, e) {
        var t2 = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t2[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t2[p[i]] = s[p[i]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value2) {
          return value2 instanceof P ? value2 : new P(function(resolve3) {
            resolve3(value2);
          });
        }
        return new (P || (P = Promise))(function(resolve3, reject2) {
          function fulfilled(value2) {
            try {
              step(generator.next(value2));
            } catch (e) {
              reject2(e);
            }
          }
          function rejected(value2) {
            try {
              step(generator["throw"](value2));
            } catch (e) {
              reject2(e);
            }
          }
          function step(result) {
            result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _23 = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_23)
            try {
              if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                return t2;
              if (y = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _23.label++;
                  return { value: op[1], done: false };
                case 5:
                  _23.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _23.ops.pop();
                  _23.trys.pop();
                  continue;
                default:
                  if (!(t2 = _23.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _23 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _23.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _23.label < t2[1]) {
                    _23.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _23.label < t2[2]) {
                    _23.label = t2[2];
                    _23.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _23.ops.pop();
                  _23.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _23);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error3) {
          e = { error: error3 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from3, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from3.length, ar; i < l; i++) {
            if (ar || !(i in from3)) {
              if (!ar)
                ar = Array.prototype.slice.call(from3, 0, i);
              ar[i] = from3[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from3));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);
        }
        function fulfill(value2) {
          resume("next", value2);
        }
        function reject2(value2) {
          resume("throw", value2);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve3, reject2) {
              v = o[n](v), settle(resolve3, reject2, v.done, v.value);
            });
          };
        }
        function settle(resolve3, reject2, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve3({ value: v2, done: d });
          }, reject2);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      __importDefault = function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// ../node_modules/pvutils/build/utils.js
var require_utils = __commonJS({
  "../node_modules/pvutils/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUTCDate(date) {
      return new Date(date.getTime() + date.getTimezoneOffset() * 6e4);
    }
    function getParametersValue(parameters, name2, defaultValue) {
      var _a;
      if (parameters instanceof Object === false) {
        return defaultValue;
      }
      return (_a = parameters[name2]) !== null && _a !== void 0 ? _a : defaultValue;
    }
    function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
      let result = "";
      for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
          result += "0";
        }
        result += str;
        if (insertSpace) {
          result += " ";
        }
      }
      return result.trim();
    }
    function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
      if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = 'Wrong parameter: inputBuffer must be "ArrayBuffer"';
        return false;
      }
      if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
      }
      if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
      }
      if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
      }
      if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
      }
      return true;
    }
    function utilFromBase(inputBuffer, inputBase) {
      let result = 0;
      if (inputBuffer.length === 1) {
        return inputBuffer[0];
      }
      for (let i = inputBuffer.length - 1; i >= 0; i--) {
        result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
      }
      return result;
    }
    function utilToBase(value2, base, reserved = -1) {
      const internalReserved = reserved;
      let internalValue = value2;
      let result = 0;
      let biggest = Math.pow(2, base);
      for (let i = 1; i < 8; i++) {
        if (value2 < biggest) {
          let retBuf;
          if (internalReserved < 0) {
            retBuf = new ArrayBuffer(i);
            result = i;
          } else {
            if (internalReserved < i) {
              return new ArrayBuffer(0);
            }
            retBuf = new ArrayBuffer(internalReserved);
            result = internalReserved;
          }
          const retView = new Uint8Array(retBuf);
          for (let j = i - 1; j >= 0; j--) {
            const basis = Math.pow(2, j * base);
            retView[result - j - 1] = Math.floor(internalValue / basis);
            internalValue -= retView[result - j - 1] * basis;
          }
          return retBuf;
        }
        biggest *= Math.pow(2, base);
      }
      return new ArrayBuffer(0);
    }
    function utilConcatBuf(...buffers) {
      let outputLength = 0;
      let prevLength = 0;
      for (const buffer of buffers) {
        outputLength += buffer.byteLength;
      }
      const retBuf = new ArrayBuffer(outputLength);
      const retView = new Uint8Array(retBuf);
      for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
      }
      return retBuf;
    }
    function utilConcatView(...views) {
      let outputLength = 0;
      let prevLength = 0;
      for (const view of views) {
        outputLength += view.length;
      }
      const retBuf = new ArrayBuffer(outputLength);
      const retView = new Uint8Array(retBuf);
      for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
      }
      return retView;
    }
    function utilDecodeTC() {
      const buf = new Uint8Array(this.valueHex);
      if (this.valueHex.byteLength >= 2) {
        const condition1 = buf[0] === 255 && buf[1] & 128;
        const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
        if (condition1 || condition2) {
          this.warnings.push("Needlessly long format");
        }
      }
      const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const bigIntView = new Uint8Array(bigIntBuffer);
      for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
      }
      bigIntView[0] = buf[0] & 128;
      const bigInt = utilFromBase(bigIntView, 8);
      const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const smallIntView = new Uint8Array(smallIntBuffer);
      for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
      }
      smallIntView[0] &= 127;
      const smallInt = utilFromBase(smallIntView, 8);
      return smallInt - bigInt;
    }
    function utilEncodeTC(value2) {
      const modValue = value2 < 0 ? value2 * -1 : value2;
      let bigInt = 128;
      for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
          if (value2 < 0) {
            const smallInt = bigInt - modValue;
            const retBuf2 = utilToBase(smallInt, 8, i);
            const retView2 = new Uint8Array(retBuf2);
            retView2[0] |= 128;
            return retBuf2;
          }
          let retBuf = utilToBase(modValue, 8, i);
          let retView = new Uint8Array(retBuf);
          if (retView[0] & 128) {
            const tempBuf = retBuf.slice(0);
            const tempView = new Uint8Array(tempBuf);
            retBuf = new ArrayBuffer(retBuf.byteLength + 1);
            retView = new Uint8Array(retBuf);
            for (let k = 0; k < tempBuf.byteLength; k++) {
              retView[k + 1] = tempView[k];
            }
            retView[0] = 0;
          }
          return retBuf;
        }
        bigInt *= Math.pow(2, 8);
      }
      return new ArrayBuffer(0);
    }
    function isEqualBuffer(inputBuffer1, inputBuffer2) {
      if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
      }
      const view1 = new Uint8Array(inputBuffer1);
      const view2 = new Uint8Array(inputBuffer2);
      for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
          return false;
        }
      }
      return true;
    }
    function padNumber(inputNumber, fullLength) {
      const str = inputNumber.toString(10);
      if (fullLength < str.length) {
        return "";
      }
      const dif = fullLength - str.length;
      const padding = new Array(dif);
      for (let i = 0; i < dif; i++) {
        padding[i] = "0";
      }
      const paddingString = padding.join("");
      return paddingString.concat(str);
    }
    var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
    function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
      let i = 0;
      let flag1 = 0;
      let flag2 = 0;
      let output2 = "";
      const template = useUrlTemplate ? base64UrlTemplate : base64Template;
      if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i2 = 0; i2 < input.length; i2++) {
          if (input.charCodeAt(i2) !== 0) {
            nonZeroPosition = i2;
            break;
          }
        }
        input = input.slice(nonZeroPosition);
      }
      while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
          flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
          flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        let enc4 = chr3 & 63;
        if (flag1 === 1) {
          enc3 = enc4 = 64;
        } else {
          if (flag2 === 1) {
            enc4 = 64;
          }
        }
        if (skipPadding) {
          if (enc3 === 64) {
            output2 += `${template.charAt(enc1)}${template.charAt(enc2)}`;
          } else {
            if (enc4 === 64) {
              output2 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
            } else {
              output2 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
            }
          }
        } else {
          output2 += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
      }
      return output2;
    }
    function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
      const template = useUrlTemplate ? base64UrlTemplate : base64Template;
      function indexOf(toSearch) {
        for (let i2 = 0; i2 < 64; i2++) {
          if (template.charAt(i2) === toSearch)
            return i2;
        }
        return 64;
      }
      function test(incoming) {
        return incoming === 64 ? 0 : incoming;
      }
      let i = 0;
      let output2 = "";
      while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const enc3 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const enc4 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const chr1 = test(enc1) << 2 | test(enc2) >> 4;
        const chr2 = (test(enc2) & 15) << 4 | test(enc3) >> 2;
        const chr3 = (test(enc3) & 3) << 6 | test(enc4);
        output2 += String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output2 += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output2 += String.fromCharCode(chr3);
        }
      }
      if (cutTailZeros) {
        const outputLength = output2.length;
        let nonZeroStart = -1;
        for (let i2 = outputLength - 1; i2 >= 0; i2--) {
          if (output2.charCodeAt(i2) !== 0) {
            nonZeroStart = i2;
            break;
          }
        }
        if (nonZeroStart !== -1) {
          output2 = output2.slice(0, nonZeroStart + 1);
        } else {
          output2 = "";
        }
      }
      return output2;
    }
    function arrayBufferToString(buffer) {
      let resultString = "";
      const view = new Uint8Array(buffer);
      for (const element of view) {
        resultString += String.fromCharCode(element);
      }
      return resultString;
    }
    function stringToArrayBuffer(str) {
      const stringLength = str.length;
      const resultBuffer = new ArrayBuffer(stringLength);
      const resultView = new Uint8Array(resultBuffer);
      for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
      }
      return resultBuffer;
    }
    var log2 = Math.log(2);
    function nearestPowerOf2(length) {
      const base = Math.log(length) / log2;
      const floor = Math.floor(base);
      const round = Math.round(base);
      return floor === round ? floor : round;
    }
    function clearProps(object, propsArray) {
      for (const prop of propsArray) {
        delete object[prop];
      }
    }
    exports.arrayBufferToString = arrayBufferToString;
    exports.bufferToHexCodes = bufferToHexCodes;
    exports.checkBufferParams = checkBufferParams;
    exports.clearProps = clearProps;
    exports.fromBase64 = fromBase64;
    exports.getParametersValue = getParametersValue;
    exports.getUTCDate = getUTCDate;
    exports.isEqualBuffer = isEqualBuffer;
    exports.nearestPowerOf2 = nearestPowerOf2;
    exports.padNumber = padNumber;
    exports.stringToArrayBuffer = stringToArrayBuffer;
    exports.toBase64 = toBase64;
    exports.utilConcatBuf = utilConcatBuf;
    exports.utilConcatView = utilConcatView;
    exports.utilDecodeTC = utilDecodeTC;
    exports.utilEncodeTC = utilEncodeTC;
    exports.utilFromBase = utilFromBase;
    exports.utilToBase = utilToBase;
  }
});

// ../node_modules/asn1js/build/index.js
var require_build2 = __commonJS({
  "../node_modules/asn1js/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pvtsutils = require_build();
    var pvutils = require_utils();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var pvtsutils__namespace = /* @__PURE__ */ _interopNamespace(pvtsutils);
    var pvutils__namespace = /* @__PURE__ */ _interopNamespace(pvutils);
    function assertBigInt() {
      if (typeof BigInt === "undefined") {
        throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
      }
    }
    function concat(buffers) {
      let outputLength = 0;
      let prevLength = 0;
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        outputLength += buffer.byteLength;
      }
      const retView = new Uint8Array(outputLength);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
      }
      return retView.buffer;
    }
    function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
      if (!(inputBuffer instanceof Uint8Array)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
        return false;
      }
      if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
      }
      if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
      }
      if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
      }
      if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
      }
      return true;
    }
    var ViewWriter = class {
      constructor() {
        this.items = [];
      }
      write(buf) {
        this.items.push(buf);
      }
      final() {
        return concat(this.items);
      }
    };
    var powers2 = [new Uint8Array([1])];
    var digitsString = "0123456789";
    var NAME = "name";
    var VALUE_HEX_VIEW = "valueHexView";
    var IS_HEX_ONLY = "isHexOnly";
    var ID_BLOCK = "idBlock";
    var TAG_CLASS = "tagClass";
    var TAG_NUMBER = "tagNumber";
    var IS_CONSTRUCTED = "isConstructed";
    var FROM_BER = "fromBER";
    var TO_BER = "toBER";
    var LOCAL = "local";
    var EMPTY_STRING = "";
    var EMPTY_BUFFER = new ArrayBuffer(0);
    var EMPTY_VIEW = new Uint8Array(0);
    var END_OF_CONTENT_NAME = "EndOfContent";
    var OCTET_STRING_NAME = "OCTET STRING";
    var BIT_STRING_NAME = "BIT STRING";
    function HexBlock(BaseClass) {
      var _a2;
      return _a2 = class Some extends BaseClass {
        constructor(...args) {
          var _a3;
          super(...args);
          const params = args[0] || {};
          this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
          this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
        }
        get valueHex() {
          return this.valueHexView.slice().buffer;
        }
        set valueHex(value2) {
          this.valueHexView = new Uint8Array(value2);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
          const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
          }
          const endLength = inputOffset + inputLength;
          this.valueHexView = view.subarray(inputOffset, endLength);
          if (!this.valueHexView.length) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
          }
          this.blockLength = inputLength;
          return endLength;
        }
        toBER(sizeOnly = false) {
          if (!this.isHexOnly) {
            this.error = "Flag 'isHexOnly' is not set, abort";
            return EMPTY_BUFFER;
          }
          if (sizeOnly) {
            return new ArrayBuffer(this.valueHexView.byteLength);
          }
          return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            isHexOnly: this.isHexOnly,
            valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView)
          };
        }
      }, _a2.NAME = "hexBlock", _a2;
    }
    var LocalBaseBlock = class {
      constructor({ blockLength = 0, error: error3 = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
        this.blockLength = blockLength;
        this.error = error3;
        this.warnings = warnings;
        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);
      }
      static blockName() {
        return this.NAME;
      }
      get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
      }
      set valueBeforeDecode(value2) {
        this.valueBeforeDecodeView = new Uint8Array(value2);
      }
      toJSON() {
        return {
          blockName: this.constructor.NAME,
          blockLength: this.blockLength,
          error: this.error,
          warnings: this.warnings,
          valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView)
        };
      }
    };
    LocalBaseBlock.NAME = "baseBlock";
    var ValueBlock = class extends LocalBaseBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
      toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    };
    ValueBlock.NAME = "valueBlock";
    var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ idBlock = {} } = {}) {
        var _a2, _b, _c, _d;
        super();
        if (idBlock) {
          this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
          this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
          this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
          this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
          this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
          this.tagClass = -1;
          this.tagNumber = -1;
          this.isConstructed = false;
        }
      }
      toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch (this.tagClass) {
          case 1:
            firstOctet |= 0;
            break;
          case 2:
            firstOctet |= 64;
            break;
          case 3:
            firstOctet |= 128;
            break;
          case 4:
            firstOctet |= 192;
            break;
          default:
            this.error = "Unknown tag class";
            return EMPTY_BUFFER;
        }
        if (this.isConstructed)
          firstOctet |= 32;
        if (this.tagNumber < 31 && !this.isHexOnly) {
          const retView2 = new Uint8Array(1);
          if (!sizeOnly) {
            let number = this.tagNumber;
            number &= 31;
            firstOctet |= number;
            retView2[0] = firstOctet;
          }
          return retView2.buffer;
        }
        if (!this.isHexOnly) {
          const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);
          const encodedView = new Uint8Array(encodedBuf);
          const size = encodedBuf.byteLength;
          const retView2 = new Uint8Array(size + 1);
          retView2[0] = firstOctet | 31;
          if (!sizeOnly) {
            for (let i = 0; i < size - 1; i++)
              retView2[i + 1] = encodedView[i] | 128;
            retView2[size] = encodedView[size - 1];
          }
          return retView2.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 31;
        if (!sizeOnly) {
          const curView = this.valueHexView;
          for (let i = 0; i < curView.length - 1; i++)
            retView[i + 1] = curView[i] | 128;
          retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        const tagClassMask = intBuffer[0] & 192;
        switch (tagClassMask) {
          case 0:
            this.tagClass = 1;
            break;
          case 64:
            this.tagClass = 2;
            break;
          case 128:
            this.tagClass = 3;
            break;
          case 192:
            this.tagClass = 4;
            break;
          default:
            this.error = "Unknown tag class";
            return -1;
        }
        this.isConstructed = (intBuffer[0] & 32) === 32;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 31;
        if (tagNumberMask !== 31) {
          this.tagNumber = tagNumberMask;
          this.blockLength = 1;
        } else {
          let count = 1;
          let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
          let tagNumberBufferMaxLength = 255;
          while (intBuffer[count] & 128) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
            count++;
            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            }
            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;
              const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
              for (let i = 0; i < intTagNumberBuffer.length; i++)
                tempBufferView2[i] = intTagNumberBuffer[i];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
            }
          }
          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
          const tempBufferView = new Uint8Array(count);
          for (let i = 0; i < count; i++)
            tempBufferView[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
          intTagNumberBuffer.set(tempBufferView);
          if (this.blockLength <= 9)
            this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);
          else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          }
        }
        if (this.tagClass === 1 && this.isConstructed) {
          switch (this.tagNumber) {
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
              this.error = "Constructed encoding used for primitive type";
              return -1;
          }
        }
        return inputOffset + this.blockLength;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          tagClass: this.tagClass,
          tagNumber: this.tagNumber,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalIdentificationBlock.NAME = "identificationBlock";
    var LocalLengthBlock = class extends LocalBaseBlock {
      constructor({ lenBlock = {} } = {}) {
        var _a2, _b, _c;
        super();
        this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        if (intBuffer[0] === 255) {
          this.error = "Length block 0xFF is reserved by standard";
          return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 128;
        if (this.isIndefiniteForm) {
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 128);
        if (this.longFormUsed === false) {
          this.length = intBuffer[0];
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 127;
        if (count > 8) {
          this.error = "Too big integer";
          return -1;
        }
        if (count + 1 > intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0)
          this.warnings.push("Needlessly long encoded length");
        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127)
          this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127)
          this.longFormUsed = true;
        if (this.isIndefiniteForm) {
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = 128;
          }
          return retBuf;
        }
        if (this.longFormUsed) {
          const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);
          if (encodedBuf.byteLength > 127) {
            this.error = "Too big length";
            return EMPTY_BUFFER;
          }
          retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
          if (sizeOnly)
            return retBuf;
          const encodedView = new Uint8Array(encodedBuf);
          retView = new Uint8Array(retBuf);
          retView[0] = encodedBuf.byteLength | 128;
          for (let i = 0; i < encodedBuf.byteLength; i++)
            retView[i + 1] = encodedView[i];
          return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = this.length;
        }
        return retBuf;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          longFormUsed: this.longFormUsed,
          length: this.length
        };
      }
    };
    LocalLengthBlock.NAME = "lengthBlock";
    var typeStore = {};
    var BaseBlock = class extends LocalBaseBlock {
      constructor({ name: name2 = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
        super(parameters);
        this.name = name2;
        this.optional = optional;
        if (primitiveSchema) {
          this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
          prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
          _writer.write(new Uint8Array([128]).buffer);
          this.valueBlock.toBER(sizeOnly, _writer);
          _writer.write(new ArrayBuffer(2));
        } else {
          const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
          this.lenBlock.length = valueBlockBuf.byteLength;
          const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
          _writer.write(lenBlockBuf);
          _writer.write(valueBlockBuf);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          idBlock: this.idBlock.toJSON(),
          lenBlock: this.lenBlock.toJSON(),
          valueBlock: this.valueBlock.toJSON(),
          name: this.name,
          optional: this.optional
        };
        if (this.primitiveSchema)
          object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
      }
      toString(encoding = "ascii") {
        if (encoding === "ascii") {
          return this.onAsciiEncoding();
        }
        return pvtsutils__namespace.Convert.ToHex(this.toBER());
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
      }
      isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof this.constructor)) {
          return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);
      }
    };
    BaseBlock.NAME = "BaseBlock";
    function prepareIndefiniteForm(baseBlock) {
      if (baseBlock instanceof typeStore.Constructed) {
        for (const value2 of baseBlock.valueBlock.value) {
          if (prepareIndefiniteForm(value2)) {
            baseBlock.lenBlock.isIndefiniteForm = true;
          }
        }
      }
      return !!baseBlock.lenBlock.isIndefiniteForm;
    }
    var BaseStringBlock = class extends BaseBlock {
      constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
        super(parameters, stringValueBlockType);
        if (value2) {
          this.fromString(value2);
        }
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value2) {
        this.valueBlock.value = value2;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
      }
    };
    BaseStringBlock.NAME = "BaseStringBlock";
    var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ isHexOnly = true, ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = isHexOnly;
      }
    };
    LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
    var _a$w;
    var Primitive = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
      }
    };
    _a$w = Primitive;
    (() => {
      typeStore.Primitive = _a$w;
    })();
    Primitive.NAME = "PRIMITIVE";
    function localChangeType(inputObject, newType) {
      if (inputObject instanceof newType) {
        return inputObject;
      }
      const newObject = new newType();
      newObject.idBlock = inputObject.idBlock;
      newObject.lenBlock = inputObject.lenBlock;
      newObject.warnings = inputObject.warnings;
      newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
      return newObject;
    }
    function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
      const incomingOffset = inputOffset;
      let returnObject = new BaseBlock({}, ValueBlock);
      const baseBlock = new LocalBaseBlock();
      if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
        returnObject.error = baseBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
      if (!intBuffer.length) {
        returnObject.error = "Zero buffer length";
        return {
          offset: -1,
          result: returnObject
        };
      }
      let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.idBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.idBlock.warnings);
      }
      if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.idBlock.blockLength;
      resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.lenBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.lenBlock.warnings);
      }
      if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.lenBlock.blockLength;
      if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
          offset: -1,
          result: returnObject
        };
      }
      let newASN1Type = BaseBlock;
      switch (returnObject.idBlock.tagClass) {
        case 1:
          if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
            returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
            return {
              offset: -1,
              result: returnObject
            };
          }
          switch (returnObject.idBlock.tagNumber) {
            case 0:
              if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
                returnObject.error = "Type [UNIVERSAL 0] is reserved";
                return {
                  offset: -1,
                  result: returnObject
                };
              }
              newASN1Type = typeStore.EndOfContent;
              break;
            case 1:
              newASN1Type = typeStore.Boolean;
              break;
            case 2:
              newASN1Type = typeStore.Integer;
              break;
            case 3:
              newASN1Type = typeStore.BitString;
              break;
            case 4:
              newASN1Type = typeStore.OctetString;
              break;
            case 5:
              newASN1Type = typeStore.Null;
              break;
            case 6:
              newASN1Type = typeStore.ObjectIdentifier;
              break;
            case 10:
              newASN1Type = typeStore.Enumerated;
              break;
            case 12:
              newASN1Type = typeStore.Utf8String;
              break;
            case 13:
              newASN1Type = typeStore.RelativeObjectIdentifier;
              break;
            case 14:
              newASN1Type = typeStore.TIME;
              break;
            case 15:
              returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
              return {
                offset: -1,
                result: returnObject
              };
            case 16:
              newASN1Type = typeStore.Sequence;
              break;
            case 17:
              newASN1Type = typeStore.Set;
              break;
            case 18:
              newASN1Type = typeStore.NumericString;
              break;
            case 19:
              newASN1Type = typeStore.PrintableString;
              break;
            case 20:
              newASN1Type = typeStore.TeletexString;
              break;
            case 21:
              newASN1Type = typeStore.VideotexString;
              break;
            case 22:
              newASN1Type = typeStore.IA5String;
              break;
            case 23:
              newASN1Type = typeStore.UTCTime;
              break;
            case 24:
              newASN1Type = typeStore.GeneralizedTime;
              break;
            case 25:
              newASN1Type = typeStore.GraphicString;
              break;
            case 26:
              newASN1Type = typeStore.VisibleString;
              break;
            case 27:
              newASN1Type = typeStore.GeneralString;
              break;
            case 28:
              newASN1Type = typeStore.UniversalString;
              break;
            case 29:
              newASN1Type = typeStore.CharacterString;
              break;
            case 30:
              newASN1Type = typeStore.BmpString;
              break;
            case 31:
              newASN1Type = typeStore.DATE;
              break;
            case 32:
              newASN1Type = typeStore.TimeOfDay;
              break;
            case 33:
              newASN1Type = typeStore.DateTime;
              break;
            case 34:
              newASN1Type = typeStore.Duration;
              break;
            default: {
              const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
              newObject.idBlock = returnObject.idBlock;
              newObject.lenBlock = returnObject.lenBlock;
              newObject.warnings = returnObject.warnings;
              returnObject = newObject;
            }
          }
          break;
        case 2:
        case 3:
        case 4:
        default: {
          newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
        }
      }
      returnObject = localChangeType(returnObject, newASN1Type);
      resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
      returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
      return {
        offset: resultOffset,
        result: returnObject
      };
    }
    function fromBER(inputBuffer) {
      if (!inputBuffer.byteLength) {
        const result = new BaseBlock({}, ValueBlock);
        result.error = "Input buffer has zero length";
        return {
          offset: -1,
          result
        };
      }
      return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
    }
    function checkLen(indefiniteLength, length) {
      if (indefiniteLength) {
        return 1;
      }
      return length;
    }
    var LocalConstructedValueBlock = class extends ValueBlock {
      constructor({ value: value2 = [], isIndefiniteForm = false, ...parameters } = {}) {
        super(parameters);
        this.value = value2;
        this.isIndefiniteForm = isIndefiniteForm;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        let currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
          const returnObject = localFromBER(view, currentOffset, inputLength);
          if (returnObject.offset === -1) {
            this.error = returnObject.result.error;
            this.warnings.concat(returnObject.result.warnings);
            return -1;
          }
          currentOffset = returnObject.offset;
          this.blockLength += returnObject.result.blockLength;
          inputLength -= returnObject.result.blockLength;
          this.value.push(returnObject.result);
          if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
            break;
          }
        }
        if (this.isIndefiniteForm) {
          if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
            this.value.pop();
          } else {
            this.warnings.push("No EndOfContent block encoded");
          }
        }
        return currentOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for (let i = 0; i < this.value.length; i++) {
          this.value[i].toBER(sizeOnly, _writer);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          value: []
        };
        for (const value2 of this.value) {
          object.value.push(value2.toJSON());
        }
        return object;
      }
    };
    LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
    var _a$v;
    var Constructed = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        const values = [];
        for (const value2 of this.valueBlock.value) {
          values.push(value2.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
      }
    };
    _a$v = Constructed;
    (() => {
      typeStore.Constructed = _a$v;
    })();
    Constructed.NAME = "CONSTRUCTED";
    var LocalEndOfContentValueBlock = class extends ValueBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
      }
      toBER(sizeOnly) {
        return EMPTY_BUFFER;
      }
    };
    LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
    var _a$u;
    var EndOfContent = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
      }
    };
    _a$u = EndOfContent;
    (() => {
      typeStore.EndOfContent = _a$u;
    })();
    EndOfContent.NAME = END_OF_CONTENT_NAME;
    var _a$t;
    var Null = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0)
          this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
          this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return -1;
        }
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
          const retView = new Uint8Array(retBuf);
          retView[0] = 5;
          retView[1] = 0;
        }
        if (writer) {
          writer.write(retBuf);
        }
        return retBuf;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME}`;
      }
    };
    _a$t = Null;
    (() => {
      typeStore.Null = _a$t;
    })();
    Null.NAME = "NULL";
    var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value: value2, ...parameters } = {}) {
        super(parameters);
        if (parameters.valueHex) {
          this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);
        } else {
          this.valueHexView = new Uint8Array(1);
        }
        if (value2) {
          this.value = value2;
        }
      }
      get value() {
        for (const octet of this.valueHexView) {
          if (octet > 0) {
            return true;
          }
        }
        return false;
      }
      set value(value2) {
        this.valueHexView[0] = value2 ? 255 : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1)
          this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        pvutils__namespace.utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
      }
      toBER() {
        return this.valueHexView.slice();
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalBooleanValueBlock.NAME = "BooleanValueBlock";
    var _a$s;
    var Boolean2 = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value2) {
        this.valueBlock.value = value2;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
      }
    };
    _a$s = Boolean2;
    (() => {
      typeStore.Boolean = _a$s;
    })();
    Boolean2.NAME = "BOOLEAN";
    var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.isConstructed = isConstructed;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
          this.isHexOnly = false;
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (let i = 0; i < this.value.length; i++) {
            const currentBlockName = this.value[i].constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== OCTET_STRING_NAME) {
              this.error = "OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
        } else {
          this.isHexOnly = true;
          resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
          this.blockLength = inputLength;
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed)
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isConstructed: this.isConstructed
        };
      }
    };
    LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
    var _a$r;
    var OctetString = class extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
          if (this.idBlock.error.length === 0)
            this.blockLength += this.idBlock.blockLength;
          if (this.lenBlock.error.length === 0)
            this.blockLength += this.lenBlock.blockLength;
          return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
          const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          const buf = view.subarray(inputOffset, inputOffset + inputLength);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength) {
                this.valueBlock.value = [asn.result];
              }
            }
          } catch (e) {
          }
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView)}`;
      }
      getValue() {
        if (!this.idBlock.isConstructed) {
          return this.valueBlock.valueHexView.slice().buffer;
        }
        const array = [];
        for (const content of this.valueBlock.value) {
          if (content instanceof OctetString) {
            array.push(content.valueBlock.valueHexView);
          }
        }
        return pvtsutils__namespace.BufferSourceConverter.concat(array);
      }
    };
    _a$r = OctetString;
    (() => {
      typeStore.OctetString = _a$r;
    })();
    OctetString.NAME = OCTET_STRING_NAME;
    var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (const value2 of this.value) {
            const currentBlockName = value2.constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== BIT_STRING_NAME) {
              this.error = "BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
            const valueBlock = value2.valueBlock;
            if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
              this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
              return -1;
            }
            this.unusedBits = valueBlock.unusedBits;
          }
          return resultOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
          this.error = "Unused bits for BitString must be in range 0-7";
          return -1;
        }
        if (!this.unusedBits) {
          const buf = intBuffer.subarray(1);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                this.value = [asn.result];
              }
            }
          } catch (e) {
          }
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed) {
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          unusedBits: this.unusedBits,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalBitStringValueBlock.NAME = "BitStringValueBlock";
    var _a$q;
    var BitString = class extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
          const bits = [];
          const valueHex = this.valueBlock.valueHexView;
          for (const byte of valueHex) {
            bits.push(byte.toString(2).padStart(8, "0"));
          }
          const bitsStr = bits.join("");
          return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
      }
    };
    _a$q = BitString;
    (() => {
      typeStore.BitString = _a$q;
    })();
    BitString.NAME = BIT_STRING_NAME;
    var _a$p;
    function viewAdd(first, second) {
      const c = new Uint8Array([0]);
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      let firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value2 = 0;
      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
      let counter = 0;
      for (let i = max; i >= 0; i--, counter++) {
        switch (true) {
          case counter < secondViewCopy.length:
            value2 = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
            break;
          default:
            value2 = firstViewCopy[firstViewCopyLength - counter] + c[0];
        }
        c[0] = value2 / 10;
        switch (true) {
          case counter >= firstViewCopy.length:
            firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([value2 % 10]), firstViewCopy);
            break;
          default:
            firstViewCopy[firstViewCopyLength - counter] = value2 % 10;
        }
      }
      if (c[0] > 0)
        firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);
      return firstViewCopy;
    }
    function power2(n) {
      if (n >= powers2.length) {
        for (let p = powers2.length; p <= n; p++) {
          const c = new Uint8Array([0]);
          let digits = powers2[p - 1].slice(0);
          for (let i = digits.length - 1; i >= 0; i--) {
            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
            c[0] = newValue[0] / 10;
            digits[i] = newValue[0] % 10;
          }
          if (c[0] > 0)
            digits = pvutils__namespace.utilConcatView(c, digits);
          powers2.push(digits);
        }
      }
      return powers2[n];
    }
    function viewSub(first, second) {
      let b = 0;
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      const firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value2;
      let counter = 0;
      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
        value2 = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
        switch (true) {
          case value2 < 0:
            b = 1;
            firstViewCopy[firstViewCopyLength - counter] = value2 + 10;
            break;
          default:
            b = 0;
            firstViewCopy[firstViewCopyLength - counter] = value2;
        }
      }
      if (b > 0) {
        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
          value2 = firstViewCopy[firstViewCopyLength - counter] - b;
          if (value2 < 0) {
            b = 1;
            firstViewCopy[firstViewCopyLength - counter] = value2 + 10;
          } else {
            b = 0;
            firstViewCopy[firstViewCopyLength - counter] = value2;
            break;
          }
        }
      }
      return firstViewCopy.slice();
    }
    var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value: value2, ...parameters } = {}) {
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) {
          this.setValueHex();
        }
        if (value2 !== void 0) {
          this.valueDec = value2;
        }
      }
      setValueHex() {
        if (this.valueHexView.length >= 4) {
          this.warnings.push("Too big Integer for decoding, hex only");
          this.isHexOnly = true;
          this._valueDec = 0;
        } else {
          this.isHexOnly = false;
          if (this.valueHexView.length > 0) {
            this._valueDec = pvutils__namespace.utilDecodeTC.call(this);
          }
        }
      }
      set valueDec(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));
      }
      get valueDec() {
        return this._valueDec;
      }
      fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1)
          return offset;
        const view = this.valueHexView;
        if (view[0] === 0 && (view[1] & 128) !== 0) {
          this.valueHexView = view.subarray(1);
        } else {
          if (expectedLength !== 0) {
            if (view.length < expectedLength) {
              if (expectedLength - view.length > 1)
                expectedLength = view.length + 1;
              this.valueHexView = view.subarray(expectedLength - view.length);
            }
          }
        }
        return offset;
      }
      toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch (true) {
          case (view[0] & 128) !== 0:
            {
              const updatedView = new Uint8Array(this.valueHexView.length + 1);
              updatedView[0] = 0;
              updatedView.set(view, 1);
              this.valueHexView = updatedView;
            }
            break;
          case (view[0] === 0 && (view[1] & 128) === 0):
            {
              this.valueHexView = this.valueHexView.subarray(1);
            }
            break;
        }
        return this.toBER(sizeOnly);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
          return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
      }
      toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
      toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
          currentByte = asn1View[byteNumber];
          for (let i = 0; i < 8; i++) {
            if ((currentByte & 1) === 1) {
              switch (bitNumber) {
                case firstBit:
                  digits = viewSub(power2(bitNumber), digits);
                  result = "-";
                  break;
                default:
                  digits = viewAdd(digits, power2(bitNumber));
              }
            }
            bitNumber++;
            currentByte >>= 1;
          }
        }
        for (let i = 0; i < digits.length; i++) {
          if (digits[i])
            flag = true;
          if (flag)
            result += digitsString.charAt(digits[i]);
        }
        if (flag === false)
          result += digitsString.charAt(0);
        return result;
      }
    };
    _a$p = LocalIntegerValueBlock;
    LocalIntegerValueBlock.NAME = "IntegerValueBlock";
    (() => {
      Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v) {
          this.valueHexView = new Uint8Array(v);
          this.setValueHex();
        },
        get: function() {
          return this.valueHexView.slice().buffer;
        }
      });
    })();
    var _a$o;
    var Integer = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
      }
      toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
      }
      static fromBigInt(value2) {
        assertBigInt();
        const bigIntValue = BigInt(value2);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));
        if (bigIntValue < 0) {
          const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
          first[0] |= 128;
          const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);
          const secondInt = firstInt + bigIntValue;
          const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));
          second[0] |= 128;
          writer.write(second);
        } else {
          if (view[0] & 128) {
            writer.write(new Uint8Array([0]));
          }
          writer.write(view);
        }
        const res = new Integer({
          valueHex: writer.final()
        });
        return res;
      }
      convertToDER() {
        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });
        integer.valueBlock.toDER();
        return integer;
      }
      convertFromDER() {
        return new Integer({
          valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
      }
    };
    _a$o = Integer;
    (() => {
      typeStore.Integer = _a$o;
    })();
    Integer.NAME = "INTEGER";
    var _a$n;
    var Enumerated = class extends Integer {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
      }
    };
    _a$n = Enumerated;
    (() => {
      typeStore.Enumerated = _a$n;
    })();
    Enumerated.NAME = "ENUMERATED";
    var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 127;
          this.blockLength++;
          if ((intBuffer[i] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++) {
          tempView[i] = this.valueHexView[i];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      set valueBigInt(value2) {
        assertBigInt();
        let bits = BigInt(value2).toString(2);
        while (bits.length % 7) {
          bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength - 1; i++)
            retView2[i] = curView[i] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i = 0; i < len; i++)
            retView[i] = encodedView[i] | 128;
          retView[len] = encodedView[len];
        }
        return retView;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
          if (this.isFirstSid) {
            let sidValue = this.valueDec;
            if (this.valueDec <= 39)
              result = "0.";
            else {
              if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
              } else {
                result = "2.";
                sidValue -= 80;
              }
            }
            result += sidValue.toString();
          } else
            result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec,
          isFirstSid: this.isFirstSid
        };
      }
    };
    LocalSidValueBlock.NAME = "sidBlock";
    var LocalObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value2) {
          this.fromString(value2);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          if (this.value.length === 0)
            sidBlock.isFirstSid = true;
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
          const valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          if (flag) {
            const sidBlock = this.value[0];
            let plus = 0;
            switch (sidBlock.valueDec) {
              case 0:
                break;
              case 1:
                plus = 40;
                break;
              case 2:
                plus = 80;
                break;
              default:
                this.value = [];
                return;
            }
            const parsedSID = parseInt(sid, 10);
            if (isNaN(parsedSID))
              return;
            sidBlock.valueDec = parsedSID + plus;
            flag = false;
          } else {
            const sidBlock = new LocalSidValueBlock();
            if (sid > Number.MAX_SAFE_INTEGER) {
              assertBigInt();
              const sidValue = BigInt(sid);
              sidBlock.valueBigInt = sidValue;
            } else {
              sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(sidBlock.valueDec))
                return;
            }
            if (!this.value.length) {
              sidBlock.isFirstSid = true;
              flag = true;
            }
            this.value.push(sidBlock);
          }
        } while (pos2 !== -1);
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          let sidStr = this.value[i].toString();
          if (i !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            if (this.value[i].isFirstSid)
              result = `2.{${sidStr} - 80}`;
            else
              result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i = 0; i < this.value.length; i++) {
          object.sidArray.push(this.value[i].toJSON());
        }
        return object;
      }
    };
    LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
    var _a$m;
    var ObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value2) {
        this.valueBlock.fromString(value2);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$m = ObjectIdentifier;
    (() => {
      typeStore.ObjectIdentifier = _a$m;
    })();
    ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
    var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ valueDec = 0, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0)
          return inputOffset;
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength))
          return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 127;
          this.blockLength++;
          if ((intBuffer[i] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++)
          tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength - 1; i++)
            retView2[i] = curView[i] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i = 0; i < len; i++)
            retView[i] = encodedView[i] | 128;
          retView[len] = encodedView[len];
        }
        return retView.buffer;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
          result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
    };
    LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
    var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value: value2 = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value2) {
          this.fromString(value2);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalRelativeSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
          const valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          const sidBlock = new LocalRelativeSidValueBlock();
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return true;
          this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          let sidStr = this.value[i].toString();
          if (i !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i = 0; i < this.value.length; i++)
          object.sidArray.push(this.value[i].toJSON());
        return object;
      }
    };
    LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
    var _a$l;
    var RelativeObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value2) {
        this.valueBlock.fromString(value2);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$l = RelativeObjectIdentifier;
    (() => {
      typeStore.RelativeObjectIdentifier = _a$l;
    })();
    RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
    var _a$k;
    var Sequence = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
      }
    };
    _a$k = Sequence;
    (() => {
      typeStore.Sequence = _a$k;
    })();
    Sequence.NAME = "SEQUENCE";
    var _a$j;
    var Set2 = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
      }
    };
    _a$j = Set2;
    (() => {
      typeStore.Set = _a$j;
    })();
    Set2.NAME = "SET";
    var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalStringValueBlock.NAME = "StringValueBlock";
    var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
    };
    LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
    var LocalSimpleStringBlock = class extends BaseStringBlock {
      constructor({ ...parameters } = {}) {
        super(parameters, LocalSimpleStringValueBlock);
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
      }
      fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (let i = 0; i < strLen; i++)
          view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
      }
    };
    LocalSimpleStringBlock.NAME = "SIMPLE STRING";
    var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
          this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
          this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
          this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);
        }
      }
      fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
      }
    };
    LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
    var _a$i;
    var Utf8String = class extends LocalUtf8StringValueBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
      }
    };
    _a$i = Utf8String;
    (() => {
      typeStore.Utf8String = _a$i;
    })();
    Utf8String.NAME = "UTF8String";
    var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
      }
      fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));
      }
    };
    LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
    var _a$h;
    var BmpString = class extends LocalBmpStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
      }
    };
    _a$h = BmpString;
    (() => {
      typeStore.BmpString = _a$h;
    })();
    BmpString.NAME = "BMPString";
    var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for (let i = 0; i < valueView.length; i += 4) {
          valueView[i] = valueView[i + 3];
          valueView[i + 1] = valueView[i + 2];
          valueView[i + 2] = 0;
          valueView[i + 3] = 0;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
      fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (let i = 0; i < strLength; i++) {
          const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);
          const codeView = new Uint8Array(codeBuf);
          if (codeView.length > 4)
            continue;
          const dif = 4 - codeView.length;
          for (let j = codeView.length - 1; j >= 0; j--)
            valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
      }
    };
    LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
    var _a$g;
    var UniversalString = class extends LocalUniversalStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
      }
    };
    _a$g = UniversalString;
    (() => {
      typeStore.UniversalString = _a$g;
    })();
    UniversalString.NAME = "UniversalString";
    var _a$f;
    var NumericString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
      }
    };
    _a$f = NumericString;
    (() => {
      typeStore.NumericString = _a$f;
    })();
    NumericString.NAME = "NumericString";
    var _a$e;
    var PrintableString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
      }
    };
    _a$e = PrintableString;
    (() => {
      typeStore.PrintableString = _a$e;
    })();
    PrintableString.NAME = "PrintableString";
    var _a$d;
    var TeletexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
      }
    };
    _a$d = TeletexString;
    (() => {
      typeStore.TeletexString = _a$d;
    })();
    TeletexString.NAME = "TeletexString";
    var _a$c;
    var VideotexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
      }
    };
    _a$c = VideotexString;
    (() => {
      typeStore.VideotexString = _a$c;
    })();
    VideotexString.NAME = "VideotexString";
    var _a$b;
    var IA5String = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
      }
    };
    _a$b = IA5String;
    (() => {
      typeStore.IA5String = _a$b;
    })();
    IA5String.NAME = "IA5String";
    var _a$a;
    var GraphicString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
      }
    };
    _a$a = GraphicString;
    (() => {
      typeStore.GraphicString = _a$a;
    })();
    GraphicString.NAME = "GraphicString";
    var _a$9;
    var VisibleString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
      }
    };
    _a$9 = VisibleString;
    (() => {
      typeStore.VisibleString = _a$9;
    })();
    VisibleString.NAME = "VisibleString";
    var _a$8;
    var GeneralString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
      }
    };
    _a$8 = GeneralString;
    (() => {
      typeStore.GeneralString = _a$8;
    })();
    GeneralString.NAME = "GeneralString";
    var _a$7;
    var CharacterString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
      }
    };
    _a$7 = CharacterString;
    (() => {
      typeStore.CharacterString = _a$7;
    })();
    CharacterString.NAME = "CharacterString";
    var _a$6;
    var UTCTime = class extends VisibleString {
      constructor({ value: value2, valueDate, ...parameters } = {}) {
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value2) {
          this.fromString(value2);
          this.valueBlock.valueHexView = new Uint8Array(value2.length);
          for (let i = 0; i < value2.length; i++)
            this.valueBlock.valueHexView[i] = value2.charCodeAt(i);
        }
        if (valueDate) {
          this.fromDate(valueDate);
          this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
      }
      fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));
      }
      toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for (let i = 0; i < str.length; i++)
          view[i] = str.charCodeAt(i);
        return buffer;
      }
      fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
      }
      fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
          this.error = "Wrong input string for conversion";
          return;
        }
        const year = parseInt(parserArray[1], 10);
        if (year >= 50)
          this.year = 1900 + year;
        else
          this.year = 2e3 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = new Array(7);
          outputArray[0] = pvutils__namespace.padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
          outputArray[1] = pvutils__namespace.padNumber(this.month, 2);
          outputArray[2] = pvutils__namespace.padNumber(this.day, 2);
          outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);
          outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);
          outputArray[5] = pvutils__namespace.padNumber(this.second, 2);
          outputArray[6] = "Z";
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second
        };
      }
    };
    _a$6 = UTCTime;
    (() => {
      typeStore.UTCTime = _a$6;
    })();
    UTCTime.NAME = "UTCTime";
    var _a$5;
    var GeneralizedTime = class extends UTCTime {
      constructor(parameters = {}) {
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
      }
      fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
      }
      fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
          timeString = inputString.substring(0, inputString.length - 1);
          isUTC = true;
        } else {
          const number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          timeString = inputString;
        }
        if (isUTC) {
          if (timeString.indexOf("+") !== -1)
            throw new Error("Wrong input string for conversion");
          if (timeString.indexOf("-") !== -1)
            throw new Error("Wrong input string for conversion");
        } else {
          let multiplier = 1;
          let differencePosition = timeString.indexOf("+");
          let differenceString = "";
          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }
          if (differencePosition !== -1) {
            differenceString = timeString.substring(differencePosition + 1);
            timeString = timeString.substring(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4)
              throw new Error("Wrong input string for conversion");
            let number = parseInt(differenceString.substring(0, 2), 10);
            if (isNaN(number.valueOf()))
              throw new Error("Wrong input string for conversion");
            hourDifference = multiplier * number;
            if (differenceString.length === 4) {
              number = parseInt(differenceString.substring(2, 4), 10);
              if (isNaN(number.valueOf()))
                throw new Error("Wrong input string for conversion");
              minuteDifference = multiplier * number;
            }
          }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1)
          fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
          const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
          if (isNaN(fractionPartCheck.valueOf()))
            throw new Error("Wrong input string for conversion");
          fractionPart = fractionPartCheck.valueOf();
          dateTimeString = timeString.substring(0, fractionPointPosition);
        } else
          dateTimeString = timeString;
        switch (true) {
          case dateTimeString.length === 8:
            parser = /(\d{4})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1)
              throw new Error("Wrong input string for conversion");
            break;
          case dateTimeString.length === 10:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.minute = Math.floor(fractionResult);
              fractionResult = 60 * (fractionResult - this.minute);
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 12:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 14:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              const fractionResult = 1e3 * fractionPart;
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null)
          throw new Error("Wrong input string for conversion");
        for (let j = 1; j < parserArray.length; j++) {
          switch (j) {
            case 1:
              this.year = parseInt(parserArray[j], 10);
              break;
            case 2:
              this.month = parseInt(parserArray[j], 10);
              break;
            case 3:
              this.day = parseInt(parserArray[j], 10);
              break;
            case 4:
              this.hour = parseInt(parserArray[j], 10) + hourDifference;
              break;
            case 5:
              this.minute = parseInt(parserArray[j], 10) + minuteDifference;
              break;
            case 6:
              this.second = parseInt(parserArray[j], 10);
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
        }
        if (isUTC === false) {
          const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
          this.year = tempDate.getUTCFullYear();
          this.month = tempDate.getUTCMonth();
          this.day = tempDate.getUTCDay();
          this.hour = tempDate.getUTCHours();
          this.minute = tempDate.getUTCMinutes();
          this.second = tempDate.getUTCSeconds();
          this.millisecond = tempDate.getUTCMilliseconds();
        }
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = [];
          outputArray.push(pvutils__namespace.padNumber(this.year, 4));
          outputArray.push(pvutils__namespace.padNumber(this.month, 2));
          outputArray.push(pvutils__namespace.padNumber(this.day, 2));
          outputArray.push(pvutils__namespace.padNumber(this.hour, 2));
          outputArray.push(pvutils__namespace.padNumber(this.minute, 2));
          outputArray.push(pvutils__namespace.padNumber(this.second, 2));
          if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));
          }
          outputArray.push("Z");
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          millisecond: this.millisecond
        };
      }
    };
    _a$5 = GeneralizedTime;
    (() => {
      typeStore.GeneralizedTime = _a$5;
    })();
    GeneralizedTime.NAME = "GeneralizedTime";
    var _a$4;
    var DATE = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
      }
    };
    _a$4 = DATE;
    (() => {
      typeStore.DATE = _a$4;
    })();
    DATE.NAME = "DATE";
    var _a$3;
    var TimeOfDay = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
      }
    };
    _a$3 = TimeOfDay;
    (() => {
      typeStore.TimeOfDay = _a$3;
    })();
    TimeOfDay.NAME = "TimeOfDay";
    var _a$2;
    var DateTime = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
      }
    };
    _a$2 = DateTime;
    (() => {
      typeStore.DateTime = _a$2;
    })();
    DateTime.NAME = "DateTime";
    var _a$1;
    var Duration = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
      }
    };
    _a$1 = Duration;
    (() => {
      typeStore.Duration = _a$1;
    })();
    Duration.NAME = "Duration";
    var _a;
    var TIME = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
      }
    };
    _a = TIME;
    (() => {
      typeStore.TIME = _a;
    })();
    TIME.NAME = "TIME";
    var Any = class {
      constructor({ name: name2 = EMPTY_STRING, optional = false } = {}) {
        this.name = name2;
        this.optional = optional;
      }
    };
    var Choice = class extends Any {
      constructor({ value: value2 = [], ...parameters } = {}) {
        super(parameters);
        this.value = value2;
      }
    };
    var Repeated = class extends Any {
      constructor({ value: value2 = new Any(), local = false, ...parameters } = {}) {
        super(parameters);
        this.value = value2;
        this.local = local;
      }
    };
    var RawData = class {
      constructor({ data = EMPTY_VIEW } = {}) {
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);
      }
      get data() {
        return this.dataView.slice().buffer;
      }
      set data(value2) {
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value2);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
      }
      toBER(sizeOnly) {
        return this.dataView.slice().buffer;
      }
    };
    function compareSchema(root, inputData, inputSchema) {
      if (inputSchema instanceof Choice) {
        for (let j = 0; j < inputSchema.value.length; j++) {
          const result = compareSchema(root, inputData, inputSchema.value[j]);
          if (result.verified) {
            return {
              verified: true,
              result: root
            };
          }
        }
        {
          const _result = {
            verified: false,
            result: {
              error: "Wrong values for Choice type"
            }
          };
          if (inputSchema.hasOwnProperty(NAME))
            _result.name = inputSchema.name;
          return _result;
        }
      }
      if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty(NAME))
          root[inputSchema.name] = inputData;
        return {
          verified: true,
          result: root
        };
      }
      if (root instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong root object" }
        };
      }
      if (inputData instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 data" }
        };
      }
      if (inputSchema instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (ID_BLOCK in inputSchema === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (FROM_BER in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (TO_BER in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      const encodedId = inputSchema.idBlock.toBER(false);
      if (encodedId.byteLength === 0) {
        return {
          verified: false,
          result: { error: "Error encoding idBlock for ASN.1 schema" }
        };
      }
      const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
      if (decodedOffset === -1) {
        return {
          verified: false,
          result: { error: "Error decoding idBlock for ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
        return {
          verified: false,
          result: root
        };
      }
      if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.isHexOnly) {
        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
          return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" }
          };
        }
        const schemaView = inputSchema.idBlock.valueHexView;
        const asn1View = inputData.idBlock.valueHexView;
        if (schemaView.length !== asn1View.length) {
          return {
            verified: false,
            result: root
          };
        }
        for (let i = 0; i < schemaView.length; i++) {
          if (schemaView[i] !== asn1View[1]) {
            return {
              verified: false,
              result: root
            };
          }
        }
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          root[inputSchema.name] = inputData;
      }
      if (inputSchema instanceof typeStore.Constructed) {
        let admission = 0;
        let result = {
          verified: false,
          result: {
            error: "Unknown error"
          }
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
          if (inputSchema.valueBlock.value[0] instanceof Repeated) {
            maxLength = inputData.valueBlock.value.length;
          }
        }
        if (maxLength === 0) {
          return {
            verified: true,
            result: root
          };
        }
        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
          let _optional = true;
          for (let i = 0; i < inputSchema.valueBlock.value.length; i++)
            _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
          if (_optional) {
            return {
              verified: true,
              result: root
            };
          }
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name)
              delete root[inputSchema.name];
          }
          root.error = "Inconsistent object length";
          return {
            verified: false,
            result: root
          };
        }
        for (let i = 0; i < maxLength; i++) {
          if (i - admission >= inputData.valueBlock.value.length) {
            if (inputSchema.valueBlock.value[i].optional === false) {
              const _result = {
                verified: false,
                result: root
              };
              root.error = "Inconsistent length between ASN.1 data and schema";
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                  delete root[inputSchema.name];
                  _result.name = inputSchema.name;
                }
              }
              return _result;
            }
          } else {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) {
              result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
              if (result.verified === false) {
                if (inputSchema.valueBlock.value[0].optional)
                  admission++;
                else {
                  if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                    if (inputSchema.name)
                      delete root[inputSchema.name];
                  }
                  return result;
                }
              }
              if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                let arrayRoot = {};
                if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
                  arrayRoot = inputData;
                else
                  arrayRoot = root;
                if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
                  arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
              }
            } else {
              result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
              if (result.verified === false) {
                if (inputSchema.valueBlock.value[i].optional)
                  admission++;
                else {
                  if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                    if (inputSchema.name)
                      delete root[inputSchema.name];
                  }
                  return result;
                }
              }
            }
          }
        }
        if (result.verified === false) {
          const _result = {
            verified: false,
            result: root
          };
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
        const asn1 = localFromBER(inputData.valueBlock.valueHexView);
        if (asn1.offset === -1) {
          const _result = {
            verified: false,
            result: asn1.result
          };
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
      }
      return {
        verified: true,
        result: root
      };
    }
    function verifySchema(inputBuffer, inputSchema) {
      if (inputSchema instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema type" }
        };
      }
      const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
      if (asn1.offset === -1) {
        return {
          verified: false,
          result: asn1.result
        };
      }
      return compareSchema(asn1.result, asn1.result, inputSchema);
    }
    exports.Any = Any;
    exports.BaseBlock = BaseBlock;
    exports.BaseStringBlock = BaseStringBlock;
    exports.BitString = BitString;
    exports.BmpString = BmpString;
    exports.Boolean = Boolean2;
    exports.CharacterString = CharacterString;
    exports.Choice = Choice;
    exports.Constructed = Constructed;
    exports.DATE = DATE;
    exports.DateTime = DateTime;
    exports.Duration = Duration;
    exports.EndOfContent = EndOfContent;
    exports.Enumerated = Enumerated;
    exports.GeneralString = GeneralString;
    exports.GeneralizedTime = GeneralizedTime;
    exports.GraphicString = GraphicString;
    exports.HexBlock = HexBlock;
    exports.IA5String = IA5String;
    exports.Integer = Integer;
    exports.Null = Null;
    exports.NumericString = NumericString;
    exports.ObjectIdentifier = ObjectIdentifier;
    exports.OctetString = OctetString;
    exports.Primitive = Primitive;
    exports.PrintableString = PrintableString;
    exports.RawData = RawData;
    exports.RelativeObjectIdentifier = RelativeObjectIdentifier;
    exports.Repeated = Repeated;
    exports.Sequence = Sequence;
    exports.Set = Set2;
    exports.TIME = TIME;
    exports.TeletexString = TeletexString;
    exports.TimeOfDay = TimeOfDay;
    exports.UTCTime = UTCTime;
    exports.UniversalString = UniversalString;
    exports.Utf8String = Utf8String;
    exports.ValueBlock = ValueBlock;
    exports.VideotexString = VideotexString;
    exports.ViewWriter = ViewWriter;
    exports.VisibleString = VisibleString;
    exports.compareSchema = compareSchema;
    exports.fromBER = fromBER;
    exports.verifySchema = verifySchema;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/enums.js
var require_enums = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnPropTypes = exports.AsnTypeTypes = void 0;
    var AsnTypeTypes;
    (function(AsnTypeTypes2) {
      AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
      AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
      AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
    })(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));
    var AsnPropTypes;
    (function(AsnPropTypes2) {
      AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
      AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
      AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
      AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
      AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
      AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
      AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
      AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
      AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
      AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
      AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
      AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
      AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
      AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
      AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
      AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
      AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
      AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
      AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
      AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
      AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
      AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
      AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
      AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
      AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
      AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
      AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
    })(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/converters.js
var require_converters = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/converters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;
    var asn1 = require_build2();
    var enums_1 = require_enums();
    exports.AsnAnyConverter = {
      fromASN: (value2) => value2 instanceof asn1.Null ? null : value2.valueBeforeDecode,
      toASN: (value2) => {
        if (value2 === null) {
          return new asn1.Null();
        }
        const schema = asn1.fromBER(value2);
        if (schema.result.error) {
          throw new Error(schema.result.error);
        }
        return schema.result;
      }
    };
    exports.AsnIntegerConverter = {
      fromASN: (value2) => value2.valueBlock.valueHexView.byteLength >= 4 ? value2.valueBlock.toString() : value2.valueBlock.valueDec,
      toASN: (value2) => new asn1.Integer({ value: value2 })
    };
    exports.AsnEnumeratedConverter = {
      fromASN: (value2) => value2.valueBlock.valueDec,
      toASN: (value2) => new asn1.Enumerated({ value: value2 })
    };
    exports.AsnIntegerArrayBufferConverter = {
      fromASN: (value2) => value2.valueBlock.valueHex,
      toASN: (value2) => new asn1.Integer({ valueHex: value2 })
    };
    exports.AsnIntegerBigIntConverter = {
      fromASN: (value2) => value2.toBigInt(),
      toASN: (value2) => asn1.Integer.fromBigInt(value2)
    };
    exports.AsnBitStringConverter = {
      fromASN: (value2) => value2.valueBlock.valueHex,
      toASN: (value2) => new asn1.BitString({ valueHex: value2 })
    };
    exports.AsnObjectIdentifierConverter = {
      fromASN: (value2) => value2.valueBlock.toString(),
      toASN: (value2) => new asn1.ObjectIdentifier({ value: value2 })
    };
    exports.AsnBooleanConverter = {
      fromASN: (value2) => value2.valueBlock.value,
      toASN: (value2) => new asn1.Boolean({ value: value2 })
    };
    exports.AsnOctetStringConverter = {
      fromASN: (value2) => value2.valueBlock.valueHex,
      toASN: (value2) => new asn1.OctetString({ valueHex: value2 })
    };
    function createStringConverter(Asn1Type) {
      return {
        fromASN: (value2) => value2.valueBlock.value,
        toASN: (value2) => new Asn1Type({ value: value2 })
      };
    }
    exports.AsnUtf8StringConverter = createStringConverter(asn1.Utf8String);
    exports.AsnBmpStringConverter = createStringConverter(asn1.BmpString);
    exports.AsnUniversalStringConverter = createStringConverter(asn1.UniversalString);
    exports.AsnNumericStringConverter = createStringConverter(asn1.NumericString);
    exports.AsnPrintableStringConverter = createStringConverter(asn1.PrintableString);
    exports.AsnTeletexStringConverter = createStringConverter(asn1.TeletexString);
    exports.AsnVideotexStringConverter = createStringConverter(asn1.VideotexString);
    exports.AsnIA5StringConverter = createStringConverter(asn1.IA5String);
    exports.AsnGraphicStringConverter = createStringConverter(asn1.GraphicString);
    exports.AsnVisibleStringConverter = createStringConverter(asn1.VisibleString);
    exports.AsnGeneralStringConverter = createStringConverter(asn1.GeneralString);
    exports.AsnCharacterStringConverter = createStringConverter(asn1.CharacterString);
    exports.AsnUTCTimeConverter = {
      fromASN: (value2) => value2.toDate(),
      toASN: (value2) => new asn1.UTCTime({ valueDate: value2 })
    };
    exports.AsnGeneralizedTimeConverter = {
      fromASN: (value2) => value2.toDate(),
      toASN: (value2) => new asn1.GeneralizedTime({ valueDate: value2 })
    };
    exports.AsnNullConverter = {
      fromASN: (value2) => null,
      toASN: (value2) => {
        return new asn1.Null();
      }
    };
    function defaultConverter(type4) {
      switch (type4) {
        case enums_1.AsnPropTypes.Any:
          return exports.AsnAnyConverter;
        case enums_1.AsnPropTypes.BitString:
          return exports.AsnBitStringConverter;
        case enums_1.AsnPropTypes.BmpString:
          return exports.AsnBmpStringConverter;
        case enums_1.AsnPropTypes.Boolean:
          return exports.AsnBooleanConverter;
        case enums_1.AsnPropTypes.CharacterString:
          return exports.AsnCharacterStringConverter;
        case enums_1.AsnPropTypes.Enumerated:
          return exports.AsnEnumeratedConverter;
        case enums_1.AsnPropTypes.GeneralString:
          return exports.AsnGeneralStringConverter;
        case enums_1.AsnPropTypes.GeneralizedTime:
          return exports.AsnGeneralizedTimeConverter;
        case enums_1.AsnPropTypes.GraphicString:
          return exports.AsnGraphicStringConverter;
        case enums_1.AsnPropTypes.IA5String:
          return exports.AsnIA5StringConverter;
        case enums_1.AsnPropTypes.Integer:
          return exports.AsnIntegerConverter;
        case enums_1.AsnPropTypes.Null:
          return exports.AsnNullConverter;
        case enums_1.AsnPropTypes.NumericString:
          return exports.AsnNumericStringConverter;
        case enums_1.AsnPropTypes.ObjectIdentifier:
          return exports.AsnObjectIdentifierConverter;
        case enums_1.AsnPropTypes.OctetString:
          return exports.AsnOctetStringConverter;
        case enums_1.AsnPropTypes.PrintableString:
          return exports.AsnPrintableStringConverter;
        case enums_1.AsnPropTypes.TeletexString:
          return exports.AsnTeletexStringConverter;
        case enums_1.AsnPropTypes.UTCTime:
          return exports.AsnUTCTimeConverter;
        case enums_1.AsnPropTypes.UniversalString:
          return exports.AsnUniversalStringConverter;
        case enums_1.AsnPropTypes.Utf8String:
          return exports.AsnUtf8StringConverter;
        case enums_1.AsnPropTypes.VideotexString:
          return exports.AsnVideotexStringConverter;
        case enums_1.AsnPropTypes.VisibleString:
          return exports.AsnVisibleStringConverter;
        default:
          return null;
      }
    }
    exports.defaultConverter = defaultConverter;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js
var require_bit_string = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var asn1js_1 = require_build2();
    var pvtsutils_1 = require_build();
    var BitString = class {
      constructor(params, unusedBits = 0) {
        this.unusedBits = 0;
        this.value = new ArrayBuffer(0);
        if (params) {
          if (typeof params === "number") {
            this.fromNumber(params);
          } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {
            this.unusedBits = unusedBits;
            this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);
          } else {
            throw TypeError("Unsupported type of 'params' argument for BitString");
          }
        }
      }
      fromASN(asn) {
        if (!(asn instanceof asn1js_1.BitString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
        }
        this.unusedBits = asn.valueBlock.unusedBits;
        this.value = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new asn1js_1.BitString({ unusedBits: this.unusedBits, valueHex: this.value });
      }
      toSchema(name2) {
        return new asn1js_1.BitString({ name: name2 });
      }
      toNumber() {
        let res = "";
        const uintArray = new Uint8Array(this.value);
        for (const octet of uintArray) {
          res += octet.toString(2).padStart(8, "0");
        }
        res = res.split("").reverse().join("");
        if (this.unusedBits) {
          res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
        }
        return parseInt(res, 2);
      }
      fromNumber(value2) {
        let bits = value2.toString(2);
        const octetSize = bits.length + 7 >> 3;
        this.unusedBits = (octetSize << 3) - bits.length;
        const octets = new Uint8Array(octetSize);
        bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
        let index = 0;
        while (index < octetSize) {
          octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
          index++;
        }
        this.value = octets.buffer;
      }
    };
    exports.BitString = BitString;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js
var require_octet_string = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OctetString = void 0;
    var asn1js_1 = require_build2();
    var pvtsutils_1 = require_build();
    var OctetString = class {
      constructor(param) {
        if (typeof param === "number") {
          this.buffer = new ArrayBuffer(param);
        } else {
          if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {
            this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);
          } else if (Array.isArray(param)) {
            this.buffer = new Uint8Array(param);
          } else {
            this.buffer = new ArrayBuffer(0);
          }
        }
      }
      get byteLength() {
        return this.buffer.byteLength;
      }
      get byteOffset() {
        return 0;
      }
      fromASN(asn) {
        if (!(asn instanceof asn1js_1.OctetString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
        }
        this.buffer = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new asn1js_1.OctetString({ valueHex: this.buffer });
      }
      toSchema(name2) {
        return new asn1js_1.OctetString({ name: name2 });
      }
    };
    exports.OctetString = OctetString;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js
var require_types = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_bit_string(), exports);
    tslib_1.__exportStar(require_octet_string(), exports);
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/helper.js
var require_helper = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;
    function isConvertible(target) {
      if (target && target.prototype) {
        if (target.prototype.toASN && target.prototype.fromASN) {
          return true;
        } else {
          return isConvertible(target.prototype);
        }
      } else {
        return !!(target && target.toASN && target.fromASN);
      }
    }
    exports.isConvertible = isConvertible;
    function isTypeOfArray(target) {
      var _a;
      if (target) {
        const proto = Object.getPrototypeOf(target);
        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {
          return true;
        }
        return isTypeOfArray(proto);
      }
      return false;
    }
    exports.isTypeOfArray = isTypeOfArray;
    function isArrayEqual(bytes1, bytes2) {
      if (!(bytes1 && bytes2)) {
        return false;
      }
      if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b2 = new Uint8Array(bytes2);
      for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.isArrayEqual = isArrayEqual;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/schema.js
var require_schema = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSchemaStorage = void 0;
    var asn1 = require_build2();
    var enums_1 = require_enums();
    var helper_1 = require_helper();
    var AsnSchemaStorage = class {
      constructor() {
        this.items = /* @__PURE__ */ new WeakMap();
      }
      has(target) {
        return this.items.has(target);
      }
      get(target) {
        var _a, _b, _c;
        const schema = this.items.get(target);
        if (!schema) {
          throw new Error(`Cannot get schema for '${(_c = (_b = (_a = target === null || target === void 0 ? void 0 : target.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : target}' target`);
        }
        return schema;
      }
      cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
          schema.schema = this.create(target, true);
        }
      }
      createDefault(target) {
        const schema = {
          type: enums_1.AsnTypeTypes.Sequence,
          items: {}
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
      }
      create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for (const key in schema.items) {
          const item = schema.items[key];
          const name2 = useNames ? key : "";
          let asn1Item;
          if (typeof item.type === "number") {
            const Asn1TypeName = enums_1.AsnPropTypes[item.type];
            const Asn1Type = asn1[Asn1TypeName];
            if (!Asn1Type) {
              throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
            }
            asn1Item = new Asn1Type({ name: name2 });
          } else if ((0, helper_1.isConvertible)(item.type)) {
            const instance2 = new item.type();
            asn1Item = instance2.toSchema(name2);
          } else if (item.optional) {
            const itemSchema = this.get(item.type);
            if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {
              asn1Item = new asn1.Any({ name: name2 });
            } else {
              asn1Item = this.create(item.type, false);
              asn1Item.name = name2;
            }
          } else {
            asn1Item = new asn1.Any({ name: name2 });
          }
          const optional = !!item.optional || item.defaultValue !== void 0;
          if (item.repeated) {
            asn1Item.name = "";
            const Container = item.repeated === "set" ? asn1.Set : asn1.Sequence;
            asn1Item = new Container({
              name: "",
              value: [
                new asn1.Repeated({
                  name: name2,
                  value: asn1Item
                })
              ]
            });
          }
          if (item.context !== null && item.context !== void 0) {
            if (item.implicit) {
              if (typeof item.type === "number" || (0, helper_1.isConvertible)(item.type)) {
                const Container = item.repeated ? asn1.Constructed : asn1.Primitive;
                asn1Value.push(new Container({
                  name: name2,
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  }
                }));
              } else {
                this.cache(item.type);
                const isRepeated = !!item.repeated;
                let value2 = !isRepeated ? this.get(item.type).schema : asn1Item;
                value2 = value2.valueBlock ? value2.valueBlock.value : value2.value;
                asn1Value.push(new asn1.Constructed({
                  name: !isRepeated ? name2 : "",
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  },
                  value: value2
                }));
              }
            } else {
              asn1Value.push(new asn1.Constructed({
                optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: item.context
                },
                value: [asn1Item]
              }));
            }
          } else {
            asn1Item.optional = optional;
            asn1Value.push(asn1Item);
          }
        }
        switch (schema.type) {
          case enums_1.AsnTypeTypes.Sequence:
            return new asn1.Sequence({ value: asn1Value, name: "" });
          case enums_1.AsnTypeTypes.Set:
            return new asn1.Set({ value: asn1Value, name: "" });
          case enums_1.AsnTypeTypes.Choice:
            return new asn1.Choice({ value: asn1Value, name: "" });
          default:
            throw new Error(`Unsupported ASN1 type in use`);
        }
      }
      set(target, schema) {
        this.items.set(target, schema);
        return this;
      }
      findParentSchema(target) {
        const parent = target.__proto__;
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
    exports.AsnSchemaStorage = AsnSchemaStorage;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/storage.js
var require_storage = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/storage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schemaStorage = void 0;
    var schema_1 = require_schema();
    exports.schemaStorage = new schema_1.AsnSchemaStorage();
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js
var require_decorators = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;
    var converters = require_converters();
    var enums_1 = require_enums();
    var storage_1 = require_storage();
    var AsnType = (options) => (target) => {
      let schema;
      if (!storage_1.schemaStorage.has(target)) {
        schema = storage_1.schemaStorage.createDefault(target);
        storage_1.schemaStorage.set(target, schema);
      } else {
        schema = storage_1.schemaStorage.get(target);
      }
      Object.assign(schema, options);
    };
    exports.AsnType = AsnType;
    var AsnChoiceType = () => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Choice });
    exports.AsnChoiceType = AsnChoiceType;
    var AsnSetType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Set, ...options });
    exports.AsnSetType = AsnSetType;
    var AsnSequenceType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Sequence, ...options });
    exports.AsnSequenceType = AsnSequenceType;
    var AsnProp = (options) => (target, propertyKey) => {
      let schema;
      if (!storage_1.schemaStorage.has(target.constructor)) {
        schema = storage_1.schemaStorage.createDefault(target.constructor);
        storage_1.schemaStorage.set(target.constructor, schema);
      } else {
        schema = storage_1.schemaStorage.get(target.constructor);
      }
      const copyOptions = Object.assign({}, options);
      if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const defaultConverter = converters.defaultConverter(options.type);
        if (!defaultConverter) {
          throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
        }
        copyOptions.converter = defaultConverter;
      }
      schema.items[propertyKey] = copyOptions;
    };
    exports.AsnProp = AsnProp;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js
var require_schema_validation = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSchemaValidationError = void 0;
    var AsnSchemaValidationError = class extends Error {
      constructor() {
        super(...arguments);
        this.schemas = [];
      }
    };
    exports.AsnSchemaValidationError = AsnSchemaValidationError;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js
var require_errors = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_schema_validation(), exports);
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/parser.js
var require_parser = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnParser = void 0;
    var asn1 = require_build2();
    var enums_1 = require_enums();
    var converters = require_converters();
    var errors_1 = require_errors();
    var helper_1 = require_helper();
    var storage_1 = require_storage();
    var AsnParser = class {
      static parse(data, target) {
        const asn1Parsed = asn1.fromBER(data);
        if (asn1Parsed.result.error) {
          throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
      }
      static fromASN(asn1Schema, target) {
        var _a;
        try {
          if ((0, helper_1.isConvertible)(target)) {
            const value2 = new target();
            return value2.fromASN(asn1Schema);
          }
          const schema = storage_1.schemaStorage.get(target);
          storage_1.schemaStorage.cache(target);
          let targetSchema = schema.schema;
          if (asn1Schema.constructor === asn1.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {
            targetSchema = new asn1.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: asn1Schema.idBlock.tagNumber
              },
              value: schema.schema.valueBlock.value
            });
            for (const key in schema.items) {
              delete asn1Schema[key];
            }
          }
          const asn1ComparedSchema = asn1.compareSchema({}, asn1Schema, targetSchema);
          if (!asn1ComparedSchema.verified) {
            throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
          }
          const res = new target();
          if ((0, helper_1.isTypeOfArray)(target)) {
            if (typeof schema.itemType === "number") {
              const converter = converters.defaultConverter(schema.itemType);
              if (!converter) {
                throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
              }
              return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
            } else {
              return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, schema.itemType));
            }
          }
          for (const key in schema.items) {
            const asn1SchemaValue = asn1ComparedSchema.result[key];
            if (!asn1SchemaValue) {
              continue;
            }
            const schemaItem = schema.items[key];
            if (typeof schemaItem.type === "number" || (0, helper_1.isConvertible)(schemaItem.type)) {
              const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItem.type) ? new schemaItem.type() : null;
              if (!converter) {
                throw new Error("Converter is empty");
              }
              if (schemaItem.repeated) {
                if (schemaItem.implicit) {
                  const Container = schemaItem.repeated === "sequence" ? asn1.Sequence : asn1.Set;
                  const newItem = new Container();
                  newItem.valueBlock = asn1SchemaValue.valueBlock;
                  const value2 = asn1.fromBER(newItem.toBER(false)).result.valueBlock.value;
                  res[key] = Array.from(value2, (element) => converter.fromASN(element));
                } else {
                  res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
                }
              } else {
                let value2 = asn1SchemaValue;
                if (schemaItem.implicit) {
                  let newItem;
                  if ((0, helper_1.isConvertible)(schemaItem.type)) {
                    newItem = new schemaItem.type().toSchema("");
                  } else {
                    const Asn1TypeName = enums_1.AsnPropTypes[schemaItem.type];
                    const Asn1Type = asn1[Asn1TypeName];
                    if (!Asn1Type) {
                      throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                    }
                    newItem = new Asn1Type();
                  }
                  newItem.valueBlock = value2.valueBlock;
                  value2 = asn1.fromBER(newItem.toBER(false)).result;
                }
                res[key] = converter.fromASN(value2);
              }
            } else {
              if (schemaItem.repeated) {
                res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItem.type));
              } else {
                res[key] = this.fromASN(asn1SchemaValue, schemaItem.type);
              }
            }
          }
          return res;
        } catch (error3) {
          if (error3 instanceof errors_1.AsnSchemaValidationError) {
            error3.schemas.push(target.name);
          }
          throw error3;
        }
      }
    };
    exports.AsnParser = AsnParser;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js
var require_serializer = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSerializer = void 0;
    var asn1 = require_build2();
    var converters = require_converters();
    var enums_1 = require_enums();
    var helper_1 = require_helper();
    var storage_1 = require_storage();
    var AsnSerializer = class {
      static serialize(obj) {
        if (obj instanceof asn1.BaseBlock) {
          return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
      }
      static toASN(obj) {
        if (obj && (0, helper_1.isConvertible)(obj.constructor)) {
          return obj.toASN();
        }
        const target = obj.constructor;
        const schema = storage_1.schemaStorage.get(target);
        storage_1.schemaStorage.cache(target);
        let asn1Value = [];
        if (schema.itemType) {
          if (typeof schema.itemType === "number") {
            const converter = converters.defaultConverter(schema.itemType);
            if (!converter) {
              throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
            }
            asn1Value = obj.map((o) => converter.toASN(o));
          } else {
            asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));
          }
        } else {
          for (const key in schema.items) {
            const schemaItem = schema.items[key];
            const objProp = obj[key];
            if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
              continue;
            }
            let asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
            if (typeof schemaItem.context === "number") {
              if (schemaItem.implicit) {
                if (!schemaItem.repeated && (typeof schemaItem.type === "number" || (0, helper_1.isConvertible)(schemaItem.type))) {
                  const value2 = {};
                  value2.valueHex = asn1Item instanceof asn1.Null ? asn1Item.valueBeforeDecode : asn1Item.valueBlock.toBER();
                  asn1Value.push(new asn1.Primitive({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    ...value2
                  }));
                } else {
                  asn1Value.push(new asn1.Constructed({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    value: asn1Item.valueBlock.value
                  }));
                }
              } else {
                asn1Value.push(new asn1.Constructed({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  value: [asn1Item]
                }));
              }
            } else if (schemaItem.repeated) {
              asn1Value = asn1Value.concat(asn1Item);
            } else {
              asn1Value.push(asn1Item);
            }
          }
        }
        let asnSchema;
        switch (schema.type) {
          case enums_1.AsnTypeTypes.Sequence:
            asnSchema = new asn1.Sequence({ value: asn1Value });
            break;
          case enums_1.AsnTypeTypes.Set:
            asnSchema = new asn1.Set({ value: asn1Value });
            break;
          case enums_1.AsnTypeTypes.Choice:
            if (!asn1Value[0]) {
              throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
            }
            asnSchema = asn1Value[0];
            break;
        }
        return asnSchema;
      }
      static toAsnItem(schemaItem, key, target, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
          const converter = schemaItem.converter;
          if (!converter) {
            throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
          }
          if (schemaItem.repeated) {
            const items = Array.from(objProp, (element) => converter.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? asn1.Sequence : asn1.Set;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = converter.toASN(objProp);
          }
        } else {
          if (schemaItem.repeated) {
            const items = Array.from(objProp, (element) => this.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? asn1.Sequence : asn1.Set;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = this.toASN(objProp);
          }
        }
        return asn1Item;
      }
    };
    exports.AsnSerializer = AsnSerializer;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/objects.js
var require_objects = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnArray = void 0;
    var AsnArray = class extends Array {
      constructor(items = []) {
        if (typeof items === "number") {
          super(items);
        } else {
          super();
          for (const item of items) {
            this.push(item);
          }
        }
      }
    };
    exports.AsnArray = AsnArray;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/convert.js
var require_convert = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnConvert = void 0;
    var asn1js = require_build2();
    var pvtsutils_1 = require_build();
    var parser_1 = require_parser();
    var serializer_1 = require_serializer();
    var AsnConvert = class {
      static serialize(obj) {
        return serializer_1.AsnSerializer.serialize(obj);
      }
      static parse(data, target) {
        return parser_1.AsnParser.parse(data, target);
      }
      static toString(data) {
        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);
        const asn = asn1js.fromBER(buf);
        if (asn.offset === -1) {
          throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
      }
    };
    exports.AsnConvert = AsnConvert;
  }
});

// ../node_modules/@peculiar/asn1-schema/build/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/@peculiar/asn1-schema/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_converters(), exports);
    tslib_1.__exportStar(require_types(), exports);
    var decorators_1 = require_decorators();
    Object.defineProperty(exports, "AsnProp", { enumerable: true, get: function() {
      return decorators_1.AsnProp;
    } });
    Object.defineProperty(exports, "AsnType", { enumerable: true, get: function() {
      return decorators_1.AsnType;
    } });
    Object.defineProperty(exports, "AsnChoiceType", { enumerable: true, get: function() {
      return decorators_1.AsnChoiceType;
    } });
    Object.defineProperty(exports, "AsnSequenceType", { enumerable: true, get: function() {
      return decorators_1.AsnSequenceType;
    } });
    Object.defineProperty(exports, "AsnSetType", { enumerable: true, get: function() {
      return decorators_1.AsnSetType;
    } });
    var enums_1 = require_enums();
    Object.defineProperty(exports, "AsnTypeTypes", { enumerable: true, get: function() {
      return enums_1.AsnTypeTypes;
    } });
    Object.defineProperty(exports, "AsnPropTypes", { enumerable: true, get: function() {
      return enums_1.AsnPropTypes;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports, "AsnParser", { enumerable: true, get: function() {
      return parser_1.AsnParser;
    } });
    var serializer_1 = require_serializer();
    Object.defineProperty(exports, "AsnSerializer", { enumerable: true, get: function() {
      return serializer_1.AsnSerializer;
    } });
    tslib_1.__exportStar(require_errors(), exports);
    tslib_1.__exportStar(require_objects(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// ../node_modules/@peculiar/json-schema/build/index.js
var require_build3 = __commonJS({
  "../node_modules/@peculiar/json-schema/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var JsonError = class extends Error {
      constructor(message, innerError) {
        super(innerError ? `${message}. See the inner exception for more details.` : message);
        this.message = message;
        this.innerError = innerError;
      }
    };
    var TransformError = class extends JsonError {
      constructor(schema, message, innerError) {
        super(message, innerError);
        this.schema = schema;
      }
    };
    var ParserError = class extends TransformError {
      constructor(schema, message, innerError) {
        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);
      }
    };
    var ValidationError = class extends JsonError {
    };
    var SerializerError = class extends JsonError {
      constructor(schemaName, message, innerError) {
        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);
        this.schemaName = schemaName;
      }
    };
    var KeyError = class extends ParserError {
      constructor(schema, keys, errors = {}) {
        super(schema, "Some keys doesn't match to schema");
        this.keys = keys;
        this.errors = errors;
      }
    };
    (function(JsonPropTypes) {
      JsonPropTypes[JsonPropTypes["Any"] = 0] = "Any";
      JsonPropTypes[JsonPropTypes["Boolean"] = 1] = "Boolean";
      JsonPropTypes[JsonPropTypes["Number"] = 2] = "Number";
      JsonPropTypes[JsonPropTypes["String"] = 3] = "String";
    })(exports.JsonPropTypes || (exports.JsonPropTypes = {}));
    function checkType(value2, type4) {
      switch (type4) {
        case exports.JsonPropTypes.Boolean:
          return typeof value2 === "boolean";
        case exports.JsonPropTypes.Number:
          return typeof value2 === "number";
        case exports.JsonPropTypes.String:
          return typeof value2 === "string";
      }
      return true;
    }
    function throwIfTypeIsWrong(value2, type4) {
      if (!checkType(value2, type4)) {
        throw new TypeError(`Value must be ${exports.JsonPropTypes[type4]}`);
      }
    }
    function isConvertible(target) {
      if (target && target.prototype) {
        if (target.prototype.toJSON && target.prototype.fromJSON) {
          return true;
        } else {
          return isConvertible(target.prototype);
        }
      } else {
        return !!(target && target.toJSON && target.fromJSON);
      }
    }
    var JsonSchemaStorage = class {
      constructor() {
        this.items = /* @__PURE__ */ new Map();
      }
      has(target) {
        return this.items.has(target) || !!this.findParentSchema(target);
      }
      get(target) {
        const schema = this.items.get(target) || this.findParentSchema(target);
        if (!schema) {
          throw new Error("Cannot get schema for current target");
        }
        return schema;
      }
      create(target) {
        const schema = { names: {} };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.names = {};
          for (const name2 in parentSchema.names) {
            schema.names[name2] = Object.assign({}, parentSchema.names[name2]);
          }
        }
        schema.target = target;
        return schema;
      }
      set(target, schema) {
        this.items.set(target, schema);
        return this;
      }
      findParentSchema(target) {
        const parent = target.__proto__;
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
    var DEFAULT_SCHEMA = "default";
    var schemaStorage = new JsonSchemaStorage();
    var PatternValidation = class {
      constructor(pattern) {
        this.pattern = new RegExp(pattern);
      }
      validate(value2) {
        const pattern = new RegExp(this.pattern.source, this.pattern.flags);
        if (typeof value2 !== "string") {
          throw new ValidationError("Incoming value must be string");
        }
        if (!pattern.exec(value2)) {
          throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);
        }
      }
    };
    var InclusiveValidation = class {
      constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
        this.min = min;
        this.max = max;
      }
      validate(value2) {
        throwIfTypeIsWrong(value2, exports.JsonPropTypes.Number);
        if (!(this.min <= value2 && value2 <= this.max)) {
          const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
          const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
          throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);
        }
      }
    };
    var ExclusiveValidation = class {
      constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
        this.min = min;
        this.max = max;
      }
      validate(value2) {
        throwIfTypeIsWrong(value2, exports.JsonPropTypes.Number);
        if (!(this.min < value2 && value2 < this.max)) {
          const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
          const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
          throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);
        }
      }
    };
    var LengthValidation = class {
      constructor(length, minLength, maxLength) {
        this.length = length;
        this.minLength = minLength;
        this.maxLength = maxLength;
      }
      validate(value2) {
        if (this.length !== void 0) {
          if (value2.length !== this.length) {
            throw new ValidationError(`Value length must be exactly ${this.length}.`);
          }
          return;
        }
        if (this.minLength !== void 0) {
          if (value2.length < this.minLength) {
            throw new ValidationError(`Value length must be more than ${this.minLength}.`);
          }
        }
        if (this.maxLength !== void 0) {
          if (value2.length > this.maxLength) {
            throw new ValidationError(`Value length must be less than ${this.maxLength}.`);
          }
        }
      }
    };
    var EnumerationValidation = class {
      constructor(enumeration) {
        this.enumeration = enumeration;
      }
      validate(value2) {
        throwIfTypeIsWrong(value2, exports.JsonPropTypes.String);
        if (!this.enumeration.includes(value2)) {
          throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(", ")}`);
        }
      }
    };
    var JsonTransform = class {
      static checkValues(data, schemaItem) {
        const values = Array.isArray(data) ? data : [data];
        for (const value2 of values) {
          for (const validation of schemaItem.validations) {
            if (validation instanceof LengthValidation && schemaItem.repeated) {
              validation.validate(data);
            } else {
              validation.validate(value2);
            }
          }
        }
      }
      static checkTypes(value2, schemaItem) {
        if (schemaItem.repeated && !Array.isArray(value2)) {
          throw new TypeError("Value must be Array");
        }
        if (typeof schemaItem.type === "number") {
          const values = Array.isArray(value2) ? value2 : [value2];
          for (const v of values) {
            throwIfTypeIsWrong(v, schemaItem.type);
          }
        }
      }
      static getSchemaByName(schema, name2 = DEFAULT_SCHEMA) {
        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name2] };
      }
    };
    var JsonSerializer = class extends JsonTransform {
      static serialize(obj, options, replacer, space) {
        const json = this.toJSON(obj, options);
        return JSON.stringify(json, replacer, space);
      }
      static toJSON(obj, options = {}) {
        let res;
        let targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        if (isConvertible(obj)) {
          return obj.toJSON();
        }
        if (Array.isArray(obj)) {
          res = [];
          for (const item of obj) {
            res.push(this.toJSON(item, options));
          }
        } else if (typeof obj === "object") {
          if (targetSchema && !schemaStorage.has(targetSchema)) {
            throw new JsonError("Cannot get schema for `targetSchema` param");
          }
          targetSchema = targetSchema || obj.constructor;
          if (schemaStorage.has(targetSchema)) {
            const schema = schemaStorage.get(targetSchema);
            res = {};
            const namedSchema = this.getSchemaByName(schema, schemaName);
            for (const key in namedSchema) {
              try {
                const item = namedSchema[key];
                const objItem = obj[key];
                let value2;
                if (item.optional && objItem === void 0 || item.defaultValue !== void 0 && objItem === item.defaultValue) {
                  continue;
                }
                if (!item.optional && objItem === void 0) {
                  throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);
                }
                if (typeof item.type === "number") {
                  if (item.converter) {
                    if (item.repeated) {
                      value2 = objItem.map((el) => item.converter.toJSON(el, obj));
                    } else {
                      value2 = item.converter.toJSON(objItem, obj);
                    }
                  } else {
                    value2 = objItem;
                  }
                } else {
                  if (item.repeated) {
                    value2 = objItem.map((el) => this.toJSON(el, { schemaName }));
                  } else {
                    value2 = this.toJSON(objItem, { schemaName });
                  }
                }
                this.checkTypes(value2, item);
                this.checkValues(value2, item);
                res[item.name || key] = value2;
              } catch (e) {
                if (e instanceof SerializerError) {
                  throw e;
                } else {
                  throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);
                }
              }
            }
          } else {
            res = {};
            for (const key in obj) {
              res[key] = this.toJSON(obj[key], { schemaName });
            }
          }
        } else {
          res = obj;
        }
        return res;
      }
    };
    var JsonParser = class extends JsonTransform {
      static parse(data, options) {
        const obj = JSON.parse(data);
        return this.fromJSON(obj, options);
      }
      static fromJSON(target, options) {
        const targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        const obj = new targetSchema();
        if (isConvertible(obj)) {
          return obj.fromJSON(target);
        }
        const schema = schemaStorage.get(targetSchema);
        const namedSchema = this.getSchemaByName(schema, schemaName);
        const keyErrors = {};
        if (options.strictProperty && !Array.isArray(target)) {
          JsonParser.checkStrictProperty(target, namedSchema, schema);
        }
        for (const key in namedSchema) {
          try {
            const item = namedSchema[key];
            const name2 = item.name || key;
            const value2 = target[name2];
            if (value2 === void 0 && (item.optional || item.defaultValue !== void 0)) {
              continue;
            }
            if (!item.optional && value2 === void 0) {
              throw new ParserError(schema, `Property '${name2}' is required.`);
            }
            this.checkTypes(value2, item);
            this.checkValues(value2, item);
            if (typeof item.type === "number") {
              if (item.converter) {
                if (item.repeated) {
                  obj[key] = value2.map((el) => item.converter.fromJSON(el, obj));
                } else {
                  obj[key] = item.converter.fromJSON(value2, obj);
                }
              } else {
                obj[key] = value2;
              }
            } else {
              const newOptions = {
                ...options,
                targetSchema: item.type,
                schemaName
              };
              if (item.repeated) {
                obj[key] = value2.map((el) => this.fromJSON(el, newOptions));
              } else {
                obj[key] = this.fromJSON(value2, newOptions);
              }
            }
          } catch (e) {
            if (!(e instanceof ParserError)) {
              e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);
            }
            if (options.strictAllKeys) {
              keyErrors[key] = e;
            } else {
              throw e;
            }
          }
        }
        const keys = Object.keys(keyErrors);
        if (keys.length) {
          throw new KeyError(schema, keys, keyErrors);
        }
        return obj;
      }
      static checkStrictProperty(target, namedSchema, schema) {
        const jsonProps = Object.keys(target);
        const schemaProps = Object.keys(namedSchema);
        const keys = [];
        for (const key of jsonProps) {
          if (schemaProps.indexOf(key) === -1) {
            keys.push(key);
          }
        }
        if (keys.length) {
          throw new KeyError(schema, keys);
        }
      }
    };
    function getValidations(item) {
      const validations = [];
      if (item.pattern) {
        validations.push(new PatternValidation(item.pattern));
      }
      if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {
        if (item.minInclusive !== void 0 || item.maxInclusive !== void 0) {
          validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));
        }
        if (item.minExclusive !== void 0 || item.maxExclusive !== void 0) {
          validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));
        }
        if (item.enumeration !== void 0) {
          validations.push(new EnumerationValidation(item.enumeration));
        }
      }
      if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {
        if (item.length !== void 0 || item.minLength !== void 0 || item.maxLength !== void 0) {
          validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));
        }
      }
      return validations;
    }
    var JsonProp = (options = {}) => (target, propertyKey) => {
      const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;
      let schema;
      if (!schemaStorage.has(target.constructor)) {
        schema = schemaStorage.create(target.constructor);
        schemaStorage.set(target.constructor, schema);
      } else {
        schema = schemaStorage.get(target.constructor);
        if (schema.target !== target.constructor) {
          schema = schemaStorage.create(target.constructor);
          schemaStorage.set(target.constructor, schema);
        }
      }
      const defaultSchema = {
        type: exports.JsonPropTypes.Any,
        validations: []
      };
      const copyOptions = Object.assign(defaultSchema, options);
      copyOptions.validations = getValidations(copyOptions);
      if (typeof copyOptions.type !== "number") {
        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {
          throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);
        }
      }
      let schemaNames;
      if (Array.isArray(options.schema)) {
        schemaNames = options.schema;
      } else {
        schemaNames = [options.schema || DEFAULT_SCHEMA];
      }
      for (const schemaName of schemaNames) {
        if (!schema.names[schemaName]) {
          schema.names[schemaName] = {};
        }
        const namedSchema = schema.names[schemaName];
        namedSchema[propertyKey] = copyOptions;
      }
    };
    exports.JsonError = JsonError;
    exports.JsonParser = JsonParser;
    exports.JsonProp = JsonProp;
    exports.JsonSerializer = JsonSerializer;
    exports.KeyError = KeyError;
    exports.ParserError = ParserError;
    exports.SerializerError = SerializerError;
    exports.TransformError = TransformError;
    exports.ValidationError = ValidationError;
  }
});

// ../node_modules/webcrypto-core/build/webcrypto-core.js
var require_webcrypto_core = __commonJS({
  "../node_modules/webcrypto-core/build/webcrypto-core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pvtsutils = require_build();
    var asn1Schema = require_cjs();
    var tslib = require_tslib();
    var jsonSchema = require_build3();
    var asn1 = require_build2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var asn1__namespace = /* @__PURE__ */ _interopNamespace(asn1);
    var CryptoError = class extends Error {
    };
    var AlgorithmError = class extends CryptoError {
    };
    var UnsupportedOperationError = class extends CryptoError {
      constructor(methodName) {
        super(`Unsupported operation: ${methodName ? `${methodName}` : ""}`);
      }
    };
    var OperationError = class extends CryptoError {
    };
    var RequiredPropertyError = class extends CryptoError {
      constructor(propName) {
        super(`${propName}: Missing required property`);
      }
    };
    var PemConverter = class {
      static toArrayBuffer(pem) {
        const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, "").replace("\r", "").replace("\n", "");
        return pvtsutils.Convert.FromBase64(base64);
      }
      static toUint8Array(pem) {
        const bytes = this.toArrayBuffer(pem);
        return new Uint8Array(bytes);
      }
      static fromBufferSource(buffer, tag) {
        const base64 = pvtsutils.Convert.ToBase64(buffer);
        let sliced;
        let offset = 0;
        const rows = [];
        while (true) {
          sliced = base64.slice(offset, offset = offset + 64);
          if (sliced.length) {
            rows.push(sliced);
            if (sliced.length < 64) {
              break;
            }
          } else {
            break;
          }
        }
        const upperCaseTag = tag.toUpperCase();
        return `-----BEGIN ${upperCaseTag}-----
${rows.join("\n")}
-----END ${upperCaseTag}-----`;
      }
      static isPEM(data) {
        return /-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(data);
      }
      static getTagName(pem) {
        if (!this.isPEM(pem)) {
          throw new Error("Bad parameter. Incoming data is not right PEM");
        }
        const res = /-----BEGIN (.+)-----/.exec(pem);
        if (!res) {
          throw new Error("Cannot get tag from PEM");
        }
        return res[1];
      }
      static hasTagName(pem, tagName) {
        const tag = this.getTagName(pem);
        return tagName.toLowerCase() === tag.toLowerCase();
      }
      static isCertificate(pem) {
        return this.hasTagName(pem, "certificate");
      }
      static isCertificateRequest(pem) {
        return this.hasTagName(pem, "certificate request");
      }
      static isCRL(pem) {
        return this.hasTagName(pem, "x509 crl");
      }
      static isPublicKey(pem) {
        return this.hasTagName(pem, "public key");
      }
    };
    function isJWK(data) {
      return typeof data === "object" && "kty" in data;
    }
    var ProviderCrypto = class {
      async digest(...args) {
        this.checkDigest.apply(this, args);
        return this.onDigest.apply(this, args);
      }
      checkDigest(algorithm, data) {
        this.checkAlgorithmName(algorithm);
      }
      async onDigest(algorithm, data) {
        throw new UnsupportedOperationError("digest");
      }
      async generateKey(...args) {
        this.checkGenerateKey.apply(this, args);
        return this.onGenerateKey.apply(this, args);
      }
      checkGenerateKey(algorithm, extractable, keyUsages, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkGenerateKeyParams(algorithm);
        if (!(keyUsages && keyUsages.length)) {
          throw new TypeError(`Usages cannot be empty when creating a key.`);
        }
        let allowedUsages;
        if (Array.isArray(this.usages)) {
          allowedUsages = this.usages;
        } else {
          allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);
        }
        this.checkKeyUsages(keyUsages, allowedUsages);
      }
      checkGenerateKeyParams(algorithm) {
      }
      async onGenerateKey(algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("generateKey");
      }
      async sign(...args) {
        this.checkSign.apply(this, args);
        return this.onSign.apply(this, args);
      }
      checkSign(algorithm, key, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "sign");
      }
      async onSign(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("sign");
      }
      async verify(...args) {
        this.checkVerify.apply(this, args);
        return this.onVerify.apply(this, args);
      }
      checkVerify(algorithm, key, signature, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "verify");
      }
      async onVerify(algorithm, key, signature, data, ...args) {
        throw new UnsupportedOperationError("verify");
      }
      async encrypt(...args) {
        this.checkEncrypt.apply(this, args);
        return this.onEncrypt.apply(this, args);
      }
      checkEncrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "encrypt" : void 0);
      }
      async onEncrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("encrypt");
      }
      async decrypt(...args) {
        this.checkDecrypt.apply(this, args);
        return this.onDecrypt.apply(this, args);
      }
      checkDecrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "decrypt" : void 0);
      }
      async onDecrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("decrypt");
      }
      async deriveBits(...args) {
        this.checkDeriveBits.apply(this, args);
        return this.onDeriveBits.apply(this, args);
      }
      checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(baseKey, options.keyUsage ? "deriveBits" : void 0);
        if (length % 8 !== 0) {
          throw new OperationError("length: Is not multiple of 8");
        }
      }
      async onDeriveBits(algorithm, baseKey, length, ...args) {
        throw new UnsupportedOperationError("deriveBits");
      }
      async exportKey(...args) {
        this.checkExportKey.apply(this, args);
        return this.onExportKey.apply(this, args);
      }
      checkExportKey(format, key, ...args) {
        this.checkKeyFormat(format);
        this.checkCryptoKey(key);
        if (!key.extractable) {
          throw new CryptoError("key: Is not extractable");
        }
      }
      async onExportKey(format, key, ...args) {
        throw new UnsupportedOperationError("exportKey");
      }
      async importKey(...args) {
        this.checkImportKey.apply(this, args);
        return this.onImportKey.apply(this, args);
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        this.checkKeyFormat(format);
        this.checkKeyData(format, keyData);
        this.checkAlgorithmName(algorithm);
        this.checkImportParams(algorithm);
        if (Array.isArray(this.usages)) {
          this.checkKeyUsages(keyUsages, this.usages);
        }
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("importKey");
      }
      checkAlgorithmName(algorithm) {
        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {
          throw new AlgorithmError("Unrecognized name");
        }
      }
      checkAlgorithmParams(algorithm) {
      }
      checkDerivedKeyParams(algorithm) {
      }
      checkKeyUsages(usages, allowed) {
        for (const usage of usages) {
          if (allowed.indexOf(usage) === -1) {
            throw new TypeError("Cannot create a key using the specified key usages");
          }
        }
      }
      checkCryptoKey(key, keyUsage) {
        this.checkAlgorithmName(key.algorithm);
        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {
          throw new CryptoError(`key does not match that of operation`);
        }
      }
      checkRequiredProperty(data, propName) {
        if (!(propName in data)) {
          throw new RequiredPropertyError(propName);
        }
      }
      checkHashAlgorithm(algorithm, hashAlgorithms) {
        for (const item of hashAlgorithms) {
          if (item.toLowerCase() === algorithm.name.toLowerCase()) {
            return;
          }
        }
        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(", ")}`);
      }
      checkImportParams(algorithm) {
      }
      checkKeyFormat(format) {
        switch (format) {
          case "raw":
          case "pkcs8":
          case "spki":
          case "jwk":
            break;
          default:
            throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'");
        }
      }
      checkKeyData(format, keyData) {
        if (!keyData) {
          throw new TypeError("keyData: Cannot be empty on empty on key importing");
        }
        if (format === "jwk") {
          if (!isJWK(keyData)) {
            throw new TypeError("keyData: Is not JsonWebToken");
          }
        } else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {
          throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");
        }
      }
      prepareData(data) {
        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);
      }
    };
    var AesProvider = class extends ProviderCrypto {
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not of type Number");
        }
        switch (algorithm.length) {
          case 128:
          case 192:
          case 256:
            break;
          default:
            throw new TypeError("length: Must be 128, 192, or 256");
        }
      }
      checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
      }
    };
    var AesCbcProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-CBC";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
          throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength !== 16) {
          throw new TypeError("iv: Must have length 16 bytes");
        }
      }
    };
    var AesCmacProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-CMAC";
        this.usages = ["sign", "verify"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
          throw new OperationError("length: Must be more than 0");
        }
      }
    };
    var AesCtrProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-CTR";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "counter");
        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {
          throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.counter.byteLength !== 16) {
          throw new TypeError("iv: Must have length 16 bytes");
        }
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
          throw new OperationError("length: Must be more than 0");
        }
      }
    };
    var AesEcbProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-ECB";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
    };
    var AesGcmProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-GCM";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
          throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength < 1) {
          throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1");
        }
        if (!("tagLength" in algorithm)) {
          algorithm.tagLength = 128;
        }
        switch (algorithm.tagLength) {
          case 32:
          case 64:
          case 96:
          case 104:
          case 112:
          case 120:
          case 128:
            break;
          default:
            throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128");
        }
      }
    };
    var AesKwProvider = class extends AesProvider {
      constructor() {
        super(...arguments);
        this.name = "AES-KW";
        this.usages = ["wrapKey", "unwrapKey"];
      }
    };
    var DesProvider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        if (this.ivSize) {
          this.checkRequiredProperty(algorithm, "iv");
          if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
          }
          if (algorithm.iv.byteLength !== this.ivSize) {
            throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);
          }
        }
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not of type Number");
        }
        if (algorithm.length !== this.keySizeBits) {
          throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);
        }
      }
      checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
      }
    };
    var RsaProvider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
          throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
          throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {
          throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384");
        }
      }
      checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    var RsaSsaProvider = class extends RsaProvider {
      constructor() {
        super(...arguments);
        this.name = "RSASSA-PKCS1-v1_5";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
      }
    };
    var RsaPssProvider = class extends RsaProvider {
      constructor() {
        super(...arguments);
        this.name = "RSA-PSS";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "saltLength");
        if (typeof algorithm.saltLength !== "number") {
          throw new TypeError("saltLength: Is not a Number");
        }
        if (algorithm.saltLength < 0) {
          throw new RangeError("saltLength: Must be positive number");
        }
      }
    };
    var RsaOaepProvider = class extends RsaProvider {
      constructor() {
        super(...arguments);
        this.name = "RSA-OAEP";
        this.usages = {
          privateKey: ["decrypt", "unwrapKey"],
          publicKey: ["encrypt", "wrapKey"]
        };
      }
      checkAlgorithmParams(algorithm) {
        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {
          throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
      }
    };
    var EllipticProvider = class extends ProviderCrypto {
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "namedCurve");
        this.checkNamedCurve(algorithm.namedCurve);
      }
      checkNamedCurve(namedCurve) {
        for (const item of this.namedCurves) {
          if (item.toLowerCase() === namedCurve.toLowerCase()) {
            return;
          }
        }
        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`);
      }
    };
    var EcdsaProvider = class extends EllipticProvider {
      constructor() {
        super(...arguments);
        this.name = "ECDSA";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    var KEY_TYPES = ["secret", "private", "public"];
    var CryptoKey = class {
      static create(algorithm, type4, extractable, usages) {
        const key = new this();
        key.algorithm = algorithm;
        key.type = type4;
        key.extractable = extractable;
        key.usages = usages;
        return key;
      }
      static isKeyType(data) {
        return KEY_TYPES.indexOf(data) !== -1;
      }
      get [Symbol.toStringTag]() {
        return "CryptoKey";
      }
    };
    var EcdhProvider = class extends EllipticProvider {
      constructor() {
        super(...arguments);
        this.name = "ECDH";
        this.usages = {
          privateKey: ["deriveBits", "deriveKey"],
          publicKey: []
        };
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "public");
        if (!(algorithm.public instanceof CryptoKey)) {
          throw new TypeError("public: Is not a CryptoKey");
        }
        if (algorithm.public.type !== "public") {
          throw new OperationError("public: Is not a public key");
        }
        if (algorithm.public.algorithm.name !== this.name) {
          throw new OperationError(`public: Is not ${this.name} key`);
        }
      }
    };
    var EcdhEsProvider = class extends EcdhProvider {
      constructor() {
        super(...arguments);
        this.name = "ECDH-ES";
        this.namedCurves = ["X25519", "X448"];
      }
    };
    var EdDsaProvider = class extends EllipticProvider {
      constructor() {
        super(...arguments);
        this.name = "EdDSA";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
        this.namedCurves = ["Ed25519", "Ed448"];
      }
    };
    var ObjectIdentifier = class ObjectIdentifier {
      constructor(value2) {
        if (value2) {
          this.value = value2;
        }
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.ObjectIdentifier })
    ], ObjectIdentifier.prototype, "value", void 0);
    ObjectIdentifier = tslib.__decorate([
      asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })
    ], ObjectIdentifier);
    var AlgorithmIdentifier = class {
      constructor(params) {
        Object.assign(this, params);
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.ObjectIdentifier
      })
    ], AlgorithmIdentifier.prototype, "algorithm", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Any,
        optional: true
      })
    ], AlgorithmIdentifier.prototype, "parameters", void 0);
    var PrivateKeyInfo = class {
      constructor() {
        this.version = 0;
        this.privateKeyAlgorithm = new AlgorithmIdentifier();
        this.privateKey = new ArrayBuffer(0);
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer })
    ], PrivateKeyInfo.prototype, "version", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: AlgorithmIdentifier })
    ], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })
    ], PrivateKeyInfo.prototype, "privateKey", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })
    ], PrivateKeyInfo.prototype, "attributes", void 0);
    var PublicKeyInfo = class {
      constructor() {
        this.publicKeyAlgorithm = new AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: AlgorithmIdentifier })
    ], PublicKeyInfo.prototype, "publicKeyAlgorithm", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })
    ], PublicKeyInfo.prototype, "publicKey", void 0);
    var JsonBase64UrlArrayBufferConverter = {
      fromJSON: (value2) => pvtsutils.Convert.FromBase64Url(value2),
      toJSON: (value2) => pvtsutils.Convert.ToBase64Url(new Uint8Array(value2))
    };
    var AsnIntegerArrayBufferConverter = {
      fromASN: (value2) => {
        const valueHex = value2.valueBlock.valueHex;
        return !new Uint8Array(valueHex)[0] ? value2.valueBlock.valueHex.slice(1) : value2.valueBlock.valueHex;
      },
      toASN: (value2) => {
        const valueHex = new Uint8Array(value2)[0] > 127 ? pvtsutils.combine(new Uint8Array([0]).buffer, value2) : value2;
        return new asn1__namespace.Integer({ valueHex });
      }
    };
    var index$3 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      JsonBase64UrlArrayBufferConverter,
      AsnIntegerArrayBufferConverter
    });
    var RsaPrivateKey = class {
      constructor() {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })
    ], RsaPrivateKey.prototype, "version", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "modulus", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "publicExponent", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "d", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "privateExponent", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "p", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "prime1", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "q", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "prime2", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "dp", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "exponent1", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "dq", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "exponent2", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "qi", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "coefficient", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })
    ], RsaPrivateKey.prototype, "otherPrimeInfos", void 0);
    var RsaPublicKey = class {
      constructor() {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPublicKey.prototype, "modulus", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      jsonSchema.JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPublicKey.prototype, "publicExponent", void 0);
    var EcPublicKey = class EcPublicKey {
      constructor(value2) {
        this.value = new ArrayBuffer(0);
        if (value2) {
          this.value = value2;
        }
      }
      toJSON() {
        let bytes = new Uint8Array(this.value);
        if (bytes[0] !== 4) {
          throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");
        }
        bytes = new Uint8Array(this.value.slice(1));
        const size = bytes.length / 2;
        const offset = 0;
        const json = {
          x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),
          y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))
        };
        return json;
      }
      fromJSON(json) {
        if (!("x" in json)) {
          throw new Error("x: Missing required property");
        }
        if (!("y" in json)) {
          throw new Error("y: Missing required property");
        }
        const x = pvtsutils.Convert.FromBase64Url(json.x);
        const y = pvtsutils.Convert.FromBase64Url(json.y);
        const value2 = pvtsutils.combine(new Uint8Array([4]).buffer, x, y);
        this.value = new Uint8Array(value2).buffer;
        return this;
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })
    ], EcPublicKey.prototype, "value", void 0);
    EcPublicKey = tslib.__decorate([
      asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })
    ], EcPublicKey);
    var EcPrivateKey = class {
      constructor() {
        this.version = 1;
        this.privateKey = new ArrayBuffer(0);
      }
      fromJSON(json) {
        if (!("d" in json)) {
          throw new Error("d: Missing required property");
        }
        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);
        if ("x" in json) {
          const publicKey = new EcPublicKey();
          publicKey.fromJSON(json);
          this.publicKey = asn1Schema.AsnSerializer.toASN(publicKey).valueBlock.valueHex;
        }
        return this;
      }
      toJSON() {
        const jwk = {};
        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);
        if (this.publicKey) {
          Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());
        }
        return jwk;
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })
    ], EcPrivateKey.prototype, "version", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })
    ], EcPrivateKey.prototype, "privateKey", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ context: 0, type: asn1Schema.AsnPropTypes.Any, optional: true })
    ], EcPrivateKey.prototype, "parameters", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ context: 1, type: asn1Schema.AsnPropTypes.BitString, optional: true })
    ], EcPrivateKey.prototype, "publicKey", void 0);
    var AsnIntegerWithoutPaddingConverter = {
      fromASN: (value2) => {
        const bytes = new Uint8Array(value2.valueBlock.valueHex);
        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;
      },
      toASN: (value2) => {
        const bytes = new Uint8Array(value2);
        if (bytes[0] > 127) {
          const newValue = new Uint8Array(bytes.length + 1);
          newValue.set(bytes, 1);
          return new asn1__namespace.Integer({ valueHex: newValue.buffer });
        }
        return new asn1__namespace.Integer({ valueHex: value2 });
      }
    };
    var index$2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AsnIntegerWithoutPaddingConverter
    });
    var EcUtils = class {
      static decodePoint(data, pointSize) {
        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);
        if (view.length === 0 || view[0] !== 4) {
          throw new Error("Only uncompressed point format supported");
        }
        const n = (view.length - 1) / 2;
        if (n !== Math.ceil(pointSize / 8)) {
          throw new Error("Point does not match field size");
        }
        const xb = view.slice(1, n + 1);
        const yb = view.slice(n + 1, n + 1 + n);
        return { x: xb, y: yb };
      }
      static encodePoint(point, pointSize) {
        const size = Math.ceil(pointSize / 8);
        if (point.x.byteLength !== size || point.y.byteLength !== size) {
          throw new Error("X,Y coordinates don't match point size criteria");
        }
        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);
        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);
        const res = new Uint8Array(size * 2 + 1);
        res[0] = 4;
        res.set(x, 1);
        res.set(y, size + 1);
        return res;
      }
      static getSize(pointSize) {
        return Math.ceil(pointSize / 8);
      }
      static encodeSignature(signature, pointSize) {
        const size = this.getSize(pointSize);
        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);
        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);
        const res = new Uint8Array(size * 2);
        res.set(this.padStart(r, size));
        res.set(this.padStart(s, size), size);
        return res;
      }
      static decodeSignature(data, pointSize) {
        const size = this.getSize(pointSize);
        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);
        if (view.length !== size * 2) {
          throw new Error("Incorrect size of the signature");
        }
        const r = view.slice(0, size);
        const s = view.slice(size);
        return {
          r: this.trimStart(r),
          s: this.trimStart(s)
        };
      }
      static trimStart(data) {
        let i = 0;
        while (i < data.length - 1 && data[i] === 0) {
          i++;
        }
        if (i === 0) {
          return data;
        }
        return data.slice(i, data.length);
      }
      static padStart(data, size) {
        if (size === data.length) {
          return data;
        }
        const res = new Uint8Array(size);
        res.set(data, size - data.length);
        return res;
      }
    };
    var EcDsaSignature = class {
      constructor() {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
      }
      static fromWebCryptoSignature(value2) {
        const pointSize = value2.byteLength / 2;
        const point = EcUtils.decodeSignature(value2, pointSize * 8);
        const ecSignature = new EcDsaSignature();
        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);
        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);
        return ecSignature;
      }
      toWebCryptoSignature(pointSize) {
        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;
        const signature = EcUtils.encodeSignature(this, pointSize);
        return signature.buffer;
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
    ], EcDsaSignature.prototype, "r", void 0);
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
    ], EcDsaSignature.prototype, "s", void 0);
    var OneAsymmetricKey = class extends PrivateKeyInfo {
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ context: 1, implicit: true, type: asn1Schema.AsnPropTypes.BitString, optional: true })
    ], OneAsymmetricKey.prototype, "publicKey", void 0);
    var EdPrivateKey = class EdPrivateKey {
      constructor() {
        this.value = new ArrayBuffer(0);
      }
      fromJSON(json) {
        if (!json.d) {
          throw new Error("d: Missing required property");
        }
        this.value = pvtsutils.Convert.FromBase64Url(json.d);
        return this;
      }
      toJSON() {
        const jwk = {
          d: pvtsutils.Convert.ToBase64Url(this.value)
        };
        return jwk;
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })
    ], EdPrivateKey.prototype, "value", void 0);
    EdPrivateKey = tslib.__decorate([
      asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })
    ], EdPrivateKey);
    var EdPublicKey = class EdPublicKey {
      constructor(value2) {
        this.value = new ArrayBuffer(0);
        if (value2) {
          this.value = value2;
        }
      }
      toJSON() {
        const json = {
          x: pvtsutils.Convert.ToBase64Url(this.value)
        };
        return json;
      }
      fromJSON(json) {
        if (!("x" in json)) {
          throw new Error("x: Missing required property");
        }
        this.value = pvtsutils.Convert.FromBase64Url(json.x);
        return this;
      }
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })
    ], EdPublicKey.prototype, "value", void 0);
    EdPublicKey = tslib.__decorate([
      asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })
    ], EdPublicKey);
    var CurvePrivateKey = class CurvePrivateKey {
    };
    tslib.__decorate([
      asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString }),
      jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })
    ], CurvePrivateKey.prototype, "d", void 0);
    CurvePrivateKey = tslib.__decorate([
      asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })
    ], CurvePrivateKey);
    var idSecp256r1 = "1.2.840.10045.3.1.7";
    var idEllipticCurve = "1.3.132.0";
    var idSecp384r1 = `${idEllipticCurve}.34`;
    var idSecp521r1 = `${idEllipticCurve}.35`;
    var idSecp256k1 = `${idEllipticCurve}.10`;
    var idVersionOne = "1.3.36.3.3.2.8.1.1";
    var idBrainpoolP160r1 = `${idVersionOne}.1`;
    var idBrainpoolP160t1 = `${idVersionOne}.2`;
    var idBrainpoolP192r1 = `${idVersionOne}.3`;
    var idBrainpoolP192t1 = `${idVersionOne}.4`;
    var idBrainpoolP224r1 = `${idVersionOne}.5`;
    var idBrainpoolP224t1 = `${idVersionOne}.6`;
    var idBrainpoolP256r1 = `${idVersionOne}.7`;
    var idBrainpoolP256t1 = `${idVersionOne}.8`;
    var idBrainpoolP320r1 = `${idVersionOne}.9`;
    var idBrainpoolP320t1 = `${idVersionOne}.10`;
    var idBrainpoolP384r1 = `${idVersionOne}.11`;
    var idBrainpoolP384t1 = `${idVersionOne}.12`;
    var idBrainpoolP512r1 = `${idVersionOne}.13`;
    var idBrainpoolP512t1 = `${idVersionOne}.14`;
    var idX25519 = "1.3.101.110";
    var idX448 = "1.3.101.111";
    var idEd25519 = "1.3.101.112";
    var idEd448 = "1.3.101.113";
    var index$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      converters: index$2,
      get ObjectIdentifier() {
        return ObjectIdentifier;
      },
      AlgorithmIdentifier,
      PrivateKeyInfo,
      PublicKeyInfo,
      RsaPrivateKey,
      RsaPublicKey,
      EcPrivateKey,
      get EcPublicKey() {
        return EcPublicKey;
      },
      EcDsaSignature,
      OneAsymmetricKey,
      get EdPrivateKey() {
        return EdPrivateKey;
      },
      get EdPublicKey() {
        return EdPublicKey;
      },
      get CurvePrivateKey() {
        return CurvePrivateKey;
      },
      idSecp256r1,
      idEllipticCurve,
      idSecp384r1,
      idSecp521r1,
      idSecp256k1,
      idVersionOne,
      idBrainpoolP160r1,
      idBrainpoolP160t1,
      idBrainpoolP192r1,
      idBrainpoolP192t1,
      idBrainpoolP224r1,
      idBrainpoolP224t1,
      idBrainpoolP256r1,
      idBrainpoolP256t1,
      idBrainpoolP320r1,
      idBrainpoolP320t1,
      idBrainpoolP384r1,
      idBrainpoolP384t1,
      idBrainpoolP512r1,
      idBrainpoolP512t1,
      idX25519,
      idX448,
      idEd25519,
      idEd448
    });
    var EcCurves = class {
      constructor() {
      }
      static register(item) {
        const oid = new ObjectIdentifier();
        oid.value = item.id;
        const raw = asn1Schema.AsnConvert.serialize(oid);
        this.items.push({
          ...item,
          raw
        });
        this.names.push(item.name);
      }
      static find(nameOrId) {
        nameOrId = nameOrId.toUpperCase();
        for (const item of this.items) {
          if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {
            return item;
          }
        }
        return null;
      }
      static get(nameOrId) {
        const res = this.find(nameOrId);
        if (!res) {
          throw new Error(`Unsupported EC named curve '${nameOrId}'`);
        }
        return res;
      }
    };
    EcCurves.items = [];
    EcCurves.names = [];
    EcCurves.register({ name: "P-256", id: idSecp256r1, size: 256 });
    EcCurves.register({ name: "P-384", id: idSecp384r1, size: 384 });
    EcCurves.register({ name: "P-521", id: idSecp521r1, size: 521 });
    EcCurves.register({ name: "K-256", id: idSecp256k1, size: 256 });
    EcCurves.register({ name: "brainpoolP160r1", id: idBrainpoolP160r1, size: 160 });
    EcCurves.register({ name: "brainpoolP160t1", id: idBrainpoolP160t1, size: 160 });
    EcCurves.register({ name: "brainpoolP192r1", id: idBrainpoolP192r1, size: 192 });
    EcCurves.register({ name: "brainpoolP192t1", id: idBrainpoolP192t1, size: 192 });
    EcCurves.register({ name: "brainpoolP224r1", id: idBrainpoolP224r1, size: 224 });
    EcCurves.register({ name: "brainpoolP224t1", id: idBrainpoolP224t1, size: 224 });
    EcCurves.register({ name: "brainpoolP256r1", id: idBrainpoolP256r1, size: 256 });
    EcCurves.register({ name: "brainpoolP256t1", id: idBrainpoolP256t1, size: 256 });
    EcCurves.register({ name: "brainpoolP320r1", id: idBrainpoolP320r1, size: 320 });
    EcCurves.register({ name: "brainpoolP320t1", id: idBrainpoolP320t1, size: 320 });
    EcCurves.register({ name: "brainpoolP384r1", id: idBrainpoolP384r1, size: 384 });
    EcCurves.register({ name: "brainpoolP384t1", id: idBrainpoolP384t1, size: 384 });
    EcCurves.register({ name: "brainpoolP512r1", id: idBrainpoolP512r1, size: 512 });
    EcCurves.register({ name: "brainpoolP512t1", id: idBrainpoolP512t1, size: 512 });
    var HmacProvider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "HMAC";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["sign", "verify"];
      }
      getDefaultLength(algName) {
        switch (algName.toUpperCase()) {
          case "SHA-1":
          case "SHA-256":
          case "SHA-384":
          case "SHA-512":
            return 512;
          default:
            throw new Error(`Unknown algorithm name '${algName}'`);
        }
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        if ("length" in algorithm) {
          if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not a Number");
          }
          if (algorithm.length < 1) {
            throw new RangeError("length: Number is out of range");
          }
        }
      }
      checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    var Pbkdf2Provider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "PBKDF2";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["deriveBits", "deriveKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "iterations");
        if (typeof algorithm.iterations !== "number") {
          throw new TypeError("iterations: Is not a Number");
        }
        if (algorithm.iterations < 1) {
          throw new TypeError("iterations: Is less than 1");
        }
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
          throw new SyntaxError("extractable: Must be 'false'");
        }
      }
    };
    var HkdfProvider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "HKDF";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["deriveKey", "deriveBits"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "info");
        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
          throw new SyntaxError("extractable: Must be 'false'");
        }
      }
    };
    var ShakeProvider = class extends ProviderCrypto {
      constructor() {
        super(...arguments);
        this.usages = [];
        this.defaultLength = 0;
      }
      digest(...args) {
        args[0] = { length: this.defaultLength, ...args[0] };
        return super.digest.apply(this, args);
      }
      checkDigest(algorithm, data) {
        super.checkDigest(algorithm, data);
        const length = algorithm.length || 0;
        if (typeof length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (length < 0) {
          throw new TypeError("length: Is negative");
        }
      }
    };
    var Shake128Provider = class extends ShakeProvider {
      constructor() {
        super(...arguments);
        this.name = "shake128";
        this.defaultLength = 16;
      }
    };
    var Shake256Provider = class extends ShakeProvider {
      constructor() {
        super(...arguments);
        this.name = "shake256";
        this.defaultLength = 32;
      }
    };
    var Crypto2 = class {
      get [Symbol.toStringTag]() {
        return "Crypto";
      }
      randomUUID() {
        const b = this.getRandomValues(new Uint8Array(16));
        b[6] = b[6] & 15 | 64;
        b[8] = b[8] & 63 | 128;
        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();
        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16)}`;
      }
    };
    var ProviderStorage = class {
      constructor() {
        this.items = {};
      }
      get(algorithmName) {
        return this.items[algorithmName.toLowerCase()] || null;
      }
      set(provider) {
        this.items[provider.name.toLowerCase()] = provider;
      }
      removeAt(algorithmName) {
        const provider = this.get(algorithmName.toLowerCase());
        if (provider) {
          delete this.items[algorithmName];
        }
        return provider;
      }
      has(name2) {
        return !!this.get(name2);
      }
      get length() {
        return Object.keys(this.items).length;
      }
      get algorithms() {
        const algorithms = [];
        for (const key in this.items) {
          const provider = this.items[key];
          algorithms.push(provider.name);
        }
        return algorithms.sort();
      }
    };
    var SubtleCrypto = class {
      constructor() {
        this.providers = new ProviderStorage();
      }
      static isHashedAlgorithm(data) {
        return data && typeof data === "object" && "name" in data && "hash" in data ? true : false;
      }
      get [Symbol.toStringTag]() {
        return "SubtleCrypto";
      }
      async digest(...args) {
        this.checkRequiredArguments(args, 2, "digest");
        const [algorithm, data, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);
        return result;
      }
      async generateKey(...args) {
        this.checkRequiredArguments(args, 3, "generateKey");
        const [algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
        return result;
      }
      async sign(...args) {
        this.checkRequiredArguments(args, 3, "sign");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);
        return result;
      }
      async verify(...args) {
        this.checkRequiredArguments(args, 4, "verify");
        const [algorithm, key, signature, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);
        return result;
      }
      async encrypt(...args) {
        this.checkRequiredArguments(args, 3, "encrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
      }
      async decrypt(...args) {
        this.checkRequiredArguments(args, 3, "decrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
      }
      async deriveBits(...args) {
        this.checkRequiredArguments(args, 3, "deriveBits");
        const [algorithm, baseKey, length, ...params] = args;
        this.checkCryptoKey(baseKey);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);
        return result;
      }
      async deriveKey(...args) {
        this.checkRequiredArguments(args, 5, "deriveKey");
        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;
        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);
        const importProvider = this.getProvider(preparedDerivedKeyType.name);
        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        provider.checkCryptoKey(baseKey, "deriveKey");
        const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);
        return this.importKey("raw", derivedBits, derivedKeyType, extractable, keyUsages, ...params);
      }
      async exportKey(...args) {
        this.checkRequiredArguments(args, 2, "exportKey");
        const [format, key, ...params] = args;
        this.checkCryptoKey(key);
        const provider = this.getProvider(key.algorithm.name);
        const result = await provider.exportKey(format, key, ...params);
        return result;
      }
      async importKey(...args) {
        this.checkRequiredArguments(args, 5, "importKey");
        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        if (["pkcs8", "spki", "raw"].indexOf(format) !== -1) {
          const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);
          return provider.importKey(format, preparedData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
        } else {
          if (!keyData.kty) {
            throw new TypeError("keyData: Is not JSON");
          }
        }
        return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
      }
      async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {
        let keyData = await this.exportKey(format, key, ...args);
        if (format === "jwk") {
          const json = JSON.stringify(keyData);
          keyData = pvtsutils.Convert.FromUtf8String(json);
        }
        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);
        const provider = this.getProvider(preparedAlgorithm.name);
        return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);
      }
      async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {
        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);
        const provider = this.getProvider(preparedAlgorithm.name);
        let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);
        if (format === "jwk") {
          try {
            keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));
          } catch (e) {
            const error3 = new TypeError("wrappedKey: Is not a JSON");
            error3.internal = e;
            throw error3;
          }
        }
        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);
      }
      checkRequiredArguments(args, size, methodName) {
        if (args.length < size) {
          throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);
        }
      }
      prepareAlgorithm(algorithm) {
        if (typeof algorithm === "string") {
          return {
            name: algorithm
          };
        }
        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {
          const preparedAlgorithm = { ...algorithm };
          preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
          return preparedAlgorithm;
        }
        return { ...algorithm };
      }
      getProvider(name2) {
        const provider = this.providers.get(name2);
        if (!provider) {
          throw new AlgorithmError("Unrecognized name");
        }
        return provider;
      }
      checkCryptoKey(key) {
        if (!(key instanceof CryptoKey)) {
          throw new TypeError(`Key is not of type 'CryptoKey'`);
        }
      }
    };
    var index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      converters: index$3
    });
    var REQUIRED_FIELDS = ["crv", "e", "k", "kty", "n", "x", "y"];
    var JwkUtils = class {
      static async thumbprint(hash, jwk, crypto) {
        const data = this.format(jwk, true);
        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));
      }
      static format(jwk, remove = false) {
        let res = Object.entries(jwk);
        if (remove) {
          res = res.filter((o) => REQUIRED_FIELDS.includes(o[0]));
        }
        res = res.sort(([keyA], [keyB]) => keyA > keyB ? 1 : keyA < keyB ? -1 : 0);
        return Object.fromEntries(res);
      }
    };
    Object.defineProperty(exports, "BufferSourceConverter", {
      enumerable: true,
      get: function() {
        return pvtsutils.BufferSourceConverter;
      }
    });
    exports.AesCbcProvider = AesCbcProvider;
    exports.AesCmacProvider = AesCmacProvider;
    exports.AesCtrProvider = AesCtrProvider;
    exports.AesEcbProvider = AesEcbProvider;
    exports.AesGcmProvider = AesGcmProvider;
    exports.AesKwProvider = AesKwProvider;
    exports.AesProvider = AesProvider;
    exports.AlgorithmError = AlgorithmError;
    exports.Crypto = Crypto2;
    exports.CryptoError = CryptoError;
    exports.CryptoKey = CryptoKey;
    exports.DesProvider = DesProvider;
    exports.EcCurves = EcCurves;
    exports.EcUtils = EcUtils;
    exports.EcdhEsProvider = EcdhEsProvider;
    exports.EcdhProvider = EcdhProvider;
    exports.EcdsaProvider = EcdsaProvider;
    exports.EdDsaProvider = EdDsaProvider;
    exports.EllipticProvider = EllipticProvider;
    exports.HkdfProvider = HkdfProvider;
    exports.HmacProvider = HmacProvider;
    exports.JwkUtils = JwkUtils;
    exports.OperationError = OperationError;
    exports.Pbkdf2Provider = Pbkdf2Provider;
    exports.PemConverter = PemConverter;
    exports.ProviderCrypto = ProviderCrypto;
    exports.ProviderStorage = ProviderStorage;
    exports.RequiredPropertyError = RequiredPropertyError;
    exports.RsaOaepProvider = RsaOaepProvider;
    exports.RsaProvider = RsaProvider;
    exports.RsaPssProvider = RsaPssProvider;
    exports.RsaSsaProvider = RsaSsaProvider;
    exports.Shake128Provider = Shake128Provider;
    exports.Shake256Provider = Shake256Provider;
    exports.ShakeProvider = ShakeProvider;
    exports.SubtleCrypto = SubtleCrypto;
    exports.UnsupportedOperationError = UnsupportedOperationError;
    exports.asn1 = index$1;
    exports.isJWK = isJWK;
    exports.json = index;
  }
});

// ../node_modules/@peculiar/webcrypto/build/webcrypto.js
var require_webcrypto = __commonJS({
  "../node_modules/@peculiar/webcrypto/build/webcrypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_webcrypto_core();
    var crypto = __require("crypto");
    var process = __require("process");
    var tslib = require_tslib();
    var jsonSchema = require_build3();
    var pvtsutils = require_build();
    var asn1Schema = require_cjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var core__namespace = /* @__PURE__ */ _interopNamespace(core);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
    var crypto__namespace = /* @__PURE__ */ _interopNamespace(crypto);
    var process__namespace = /* @__PURE__ */ _interopNamespace(process);
    var JsonBase64UrlConverter = {
      fromJSON: (value2) => Buffer.from(pvtsutils.Convert.FromBase64Url(value2)),
      toJSON: (value2) => pvtsutils.Convert.ToBase64Url(value2)
    };
    var CryptoKey = class extends core__namespace.CryptoKey {
      constructor() {
        super(...arguments);
        this.data = Buffer.alloc(0);
        this.algorithm = { name: "" };
        this.extractable = false;
        this.type = "secret";
        this.usages = [];
        this.kty = "oct";
        this.alg = "";
      }
    };
    tslib.__decorate([
      jsonSchema.JsonProp({ name: "ext", type: jsonSchema.JsonPropTypes.Boolean, optional: true })
    ], CryptoKey.prototype, "extractable", void 0);
    tslib.__decorate([
      jsonSchema.JsonProp({ name: "key_ops", type: jsonSchema.JsonPropTypes.String, repeated: true, optional: true })
    ], CryptoKey.prototype, "usages", void 0);
    tslib.__decorate([
      jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String })
    ], CryptoKey.prototype, "kty", void 0);
    tslib.__decorate([
      jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, optional: true })
    ], CryptoKey.prototype, "alg", void 0);
    var SymmetricKey = class extends CryptoKey {
      constructor() {
        super(...arguments);
        this.kty = "oct";
        this.type = "secret";
      }
    };
    var AsymmetricKey = class extends CryptoKey {
    };
    var AesCryptoKey = class extends SymmetricKey {
      get alg() {
        switch (this.algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return `A${this.algorithm.length}CBC`;
          case "AES-CTR":
            return `A${this.algorithm.length}CTR`;
          case "AES-GCM":
            return `A${this.algorithm.length}GCM`;
          case "AES-KW":
            return `A${this.algorithm.length}KW`;
          case "AES-CMAC":
            return `A${this.algorithm.length}CMAC`;
          case "AES-ECB":
            return `A${this.algorithm.length}ECB`;
          default:
            throw new core__namespace.AlgorithmError("Unsupported algorithm name");
        }
      }
      set alg(value2) {
      }
    };
    tslib.__decorate([
      jsonSchema.JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], AesCryptoKey.prototype, "data", void 0);
    var keyStorage = /* @__PURE__ */ new WeakMap();
    function getCryptoKey(key) {
      const res = keyStorage.get(key);
      if (!res) {
        throw new core__namespace.OperationError("Cannot get CryptoKey from secure storage");
      }
      return res;
    }
    function setCryptoKey(value2) {
      const key = core__namespace.CryptoKey.create(value2.algorithm, value2.type, value2.extractable, value2.usages);
      Object.freeze(key);
      keyStorage.set(key, value2);
      return key;
    }
    var AesCrypto = class {
      static async generateKey(algorithm, extractable, keyUsages) {
        const key = new AesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default["default"].randomBytes(algorithm.length >> 3);
        return key;
      }
      static async exportKey(format, key) {
        if (!(key instanceof AesCryptoKey)) {
          throw new Error("key: Is not AesCryptoKey");
        }
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(key);
          case "raw":
            return new Uint8Array(key.data).buffer;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });
            break;
          case "raw":
            key = new AesCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.algorithm.length = key.data.length << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        switch (key.algorithm.length) {
          case 128:
          case 192:
          case 256:
            break;
          default:
            throw new core__namespace.OperationError("keyData: Is wrong key length");
        }
        return key;
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return this.encryptAesCBC(algorithm, key, Buffer.from(data));
          case "AES-CTR":
            return this.encryptAesCTR(algorithm, key, Buffer.from(data));
          case "AES-GCM":
            return this.encryptAesGCM(algorithm, key, Buffer.from(data));
          case "AES-KW":
            return this.encryptAesKW(algorithm, key, Buffer.from(data));
          case "AES-ECB":
            return this.encryptAesECB(algorithm, key, Buffer.from(data));
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        if (!(key instanceof AesCryptoKey)) {
          throw new Error("key: Is not AesCryptoKey");
        }
        switch (algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return this.decryptAesCBC(algorithm, key, Buffer.from(data));
          case "AES-CTR":
            return this.decryptAesCTR(algorithm, key, Buffer.from(data));
          case "AES-GCM":
            return this.decryptAesGCM(algorithm, key, Buffer.from(data));
          case "AES-KW":
            return this.decryptAesKW(algorithm, key, Buffer.from(data));
          case "AES-ECB":
            return this.decryptAesECB(algorithm, key, Buffer.from(data));
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async encryptAesCBC(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesCBC(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesCTR(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesCTR(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesGCM(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {
          authTagLength: (algorithm.tagLength || 128) >> 3
        });
        if (algorithm.additionalData) {
          cipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesGCM(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));
        const tagLength = (algorithm.tagLength || 128) >> 3;
        const enc = data.slice(0, data.length - tagLength);
        const tag = data.slice(data.length - tagLength);
        if (algorithm.additionalData) {
          decipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        decipher.setAuthTag(tag);
        let dec = decipher.update(enc);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesKW(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        return new Uint8Array(enc).buffer;
      }
      static async decryptAesKW(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesECB(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesECB(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
    };
    AesCrypto.AES_KW_IV = Buffer.from("A6A6A6A6A6A6A6A6", "hex");
    var AesCbcProvider = class extends core__namespace.AesCbcProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    var rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);
    var blockSize = 16;
    function bitShiftLeft(buffer) {
      const shifted = Buffer.alloc(buffer.length);
      const last = buffer.length - 1;
      for (let index = 0; index < last; index++) {
        shifted[index] = buffer[index] << 1;
        if (buffer[index + 1] & 128) {
          shifted[index] += 1;
        }
      }
      shifted[last] = buffer[last] << 1;
      return shifted;
    }
    function xor(a, b) {
      const length = Math.min(a.length, b.length);
      const output2 = Buffer.alloc(length);
      for (let index = 0; index < length; index++) {
        output2[index] = a[index] ^ b[index];
      }
      return output2;
    }
    function aes(key, message) {
      const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);
      const result = cipher.update(message);
      cipher.final();
      return result;
    }
    function getMessageBlock(message, blockIndex) {
      const block = Buffer.alloc(blockSize);
      const start = blockIndex * blockSize;
      const end = start + blockSize;
      message.copy(block, 0, start, end);
      return block;
    }
    function getPaddedMessageBlock(message, blockIndex) {
      const block = Buffer.alloc(blockSize);
      const start = blockIndex * blockSize;
      const end = message.length;
      block.fill(0);
      message.copy(block, 0, start, end);
      block[end - start] = 128;
      return block;
    }
    function generateSubkeys(key) {
      const l = aes(key, zero);
      let subkey1 = bitShiftLeft(l);
      if (l[0] & 128) {
        subkey1 = xor(subkey1, rb);
      }
      let subkey2 = bitShiftLeft(subkey1);
      if (subkey1[0] & 128) {
        subkey2 = xor(subkey2, rb);
      }
      return { subkey1, subkey2 };
    }
    function aesCmac(key, message) {
      const subkeys = generateSubkeys(key);
      let blockCount = Math.ceil(message.length / blockSize);
      let lastBlockCompleteFlag;
      let lastBlock;
      if (blockCount === 0) {
        blockCount = 1;
        lastBlockCompleteFlag = false;
      } else {
        lastBlockCompleteFlag = message.length % blockSize === 0;
      }
      const lastBlockIndex = blockCount - 1;
      if (lastBlockCompleteFlag) {
        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);
      } else {
        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);
      }
      let x = zero;
      let y;
      for (let index = 0; index < lastBlockIndex; index++) {
        y = xor(x, getMessageBlock(message, index));
        x = aes(key, y);
      }
      y = xor(lastBlock, x);
      return aes(key, y);
    }
    var AesCmacProvider = class extends core__namespace.AesCmacProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onSign(algorithm, key, data) {
        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));
        return new Uint8Array(result).buffer;
      }
      async onVerify(algorithm, key, signature, data) {
        const signature2 = await this.sign(algorithm, key, data);
        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var AesCtrProvider = class extends core__namespace.AesCtrProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var AesGcmProvider = class extends core__namespace.AesGcmProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var AesKwProvider = class extends core__namespace.AesKwProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const res = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var AesEcbProvider = class extends core__namespace.AesEcbProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    var DesCryptoKey = class extends SymmetricKey {
      get alg() {
        switch (this.algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return `DES-CBC`;
          case "DES-EDE3-CBC":
            return `3DES-CBC`;
          default:
            throw new core__namespace.AlgorithmError("Unsupported algorithm name");
        }
      }
      set alg(value2) {
      }
    };
    tslib.__decorate([
      jsonSchema.JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], DesCryptoKey.prototype, "data", void 0);
    var DesCrypto = class {
      static async generateKey(algorithm, extractable, keyUsages) {
        const key = new DesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default["default"].randomBytes(algorithm.length >> 3);
        return key;
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(key);
          case "raw":
            return new Uint8Array(key.data).buffer;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });
            break;
          case "raw":
            key = new DesCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return this.encryptDesCBC(algorithm, key, Buffer.from(data));
          case "DES-EDE3-CBC":
            return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        if (!(key instanceof DesCryptoKey)) {
          throw new Error("key: Is not DesCryptoKey");
        }
        switch (algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return this.decryptDesCBC(algorithm, key, Buffer.from(data));
          case "DES-EDE3-CBC":
            return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async encryptDesCBC(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptDesCBC(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptDesEDE3CBC(algorithm, key, data) {
        const cipher = crypto__default["default"].createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptDesEDE3CBC(algorithm, key, data) {
        const decipher = crypto__default["default"].createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
    };
    var DesCbcProvider = class extends core__namespace.DesProvider {
      constructor() {
        super(...arguments);
        this.keySizeBits = 64;
        this.ivSize = 8;
        this.name = "DES-CBC";
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
          name: this.name,
          length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
          throw new core__namespace.OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
          throw new TypeError("key: Is not a DesCryptoKey");
        }
      }
    };
    var DesEde3CbcProvider = class extends core__namespace.DesProvider {
      constructor() {
        super(...arguments);
        this.keySizeBits = 192;
        this.ivSize = 8;
        this.name = "DES-EDE3-CBC";
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
          name: this.name,
          length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
          throw new core__namespace.OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
          throw new TypeError("key: Is not a DesCryptoKey");
        }
      }
    };
    function getJwkAlgorithm(algorithm) {
      switch (algorithm.name.toUpperCase()) {
        case "RSA-OAEP": {
          const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
          return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
        }
        case "RSASSA-PKCS1-V1_5":
          return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case "RSA-PSS":
          return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case "RSA-PKCS1":
          return `RS1`;
        default:
          throw new core__namespace.OperationError("algorithm: Is not recognized");
      }
    }
    var RsaPrivateKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "RSA",
          alg: getJwkAlgorithm(this.algorithm),
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
      }
      fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPrivateKey });
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
      }
    };
    var RsaPublicKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "RSA",
          alg: getJwkAlgorithm(this.algorithm),
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
      }
      fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPublicKey });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
      }
    };
    var RsaCrypto = class {
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new RsaPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new RsaPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const publicExponent = Buffer.concat([
          Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),
          Buffer.from(algorithm.publicExponent)
        ]).readInt32BE(0);
        const keys = crypto__default["default"].generateKeyPairSync("rsa", {
          modulusLength: algorithm.modulusLength,
          publicExponent,
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPublicKey });
              return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
          }
          case "spki": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
            const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
            const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
      }
      static async sign(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-PSS":
          case "RSASSA-PKCS1-V1_5":
            return this.signRsa(algorithm, key, data);
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async verify(algorithm, key, signature, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-PSS":
          case "RSASSA-PKCS1-V1_5":
            return this.verifySSA(algorithm, key, data, signature);
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-OAEP":
            return this.encryptOAEP(algorithm, key, data);
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-OAEP":
            return this.decryptOAEP(algorithm, key, data);
          default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
      }
      static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static getCryptoAlgorithm(alg) {
        switch (alg.hash.name.toUpperCase()) {
          case "SHA-1":
            return "RSA-SHA1";
          case "SHA-256":
            return "RSA-SHA256";
          case "SHA-384":
            return "RSA-SHA384";
          case "SHA-512":
            return "RSA-SHA512";
          case "SHA3-256":
            return "RSA-SHA3-256";
          case "SHA3-384":
            return "RSA-SHA3-384";
          case "SHA3-512":
            return "RSA-SHA3-512";
          default:
            throw new core__namespace.OperationError("algorithm.hash: Is not recognized");
        }
      }
      static signRsa(algorithm, key, data) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto__default["default"].createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
          options.padding = crypto__default["default"].constants.RSA_PKCS1_PSS_PADDING;
          options.saltLength = algorithm.saltLength;
        }
        const signature = signer.sign(options);
        return new Uint8Array(signature).buffer;
      }
      static verifySSA(algorithm, key, data, signature) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto__default["default"].createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
          options.padding = crypto__default["default"].constants.RSA_PKCS1_PSS_PADDING;
          options.saltLength = algorithm.saltLength;
        }
        const ok = signer.verify(options, signature);
        return ok;
      }
      static encryptOAEP(algorithm, key, data) {
        const options = {
          key: `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`,
          padding: crypto__default["default"].constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label)
          ;
        return new Uint8Array(crypto__default["default"].publicEncrypt(options, data)).buffer;
      }
      static decryptOAEP(algorithm, key, data) {
        const options = {
          key: `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`,
          padding: crypto__default["default"].constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label)
          ;
        return new Uint8Array(crypto__default["default"].privateDecrypt(options, data)).buffer;
      }
    };
    RsaCrypto.publicKeyUsages = ["verify", "encrypt", "wrapKey"];
    RsaCrypto.privateKeyUsages = ["sign", "decrypt", "unwrapKey"];
    var RsaSsaProvider = class extends core__namespace.RsaSsaProvider {
      constructor() {
        super(...arguments);
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
    };
    var RsaPssProvider = class extends core__namespace.RsaPssProvider {
      constructor() {
        super(...arguments);
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
    };
    var ShaCrypto = class {
      static size(algorithm) {
        switch (algorithm.name.toUpperCase()) {
          case "SHA-1":
            return 160;
          case "SHA-256":
          case "SHA3-256":
            return 256;
          case "SHA-384":
          case "SHA3-384":
            return 384;
          case "SHA-512":
          case "SHA3-512":
            return 512;
          default:
            throw new Error("Unrecognized name");
        }
      }
      static getAlgorithmName(algorithm) {
        switch (algorithm.name.toUpperCase()) {
          case "SHA-1":
            return "sha1";
          case "SHA-256":
            return "sha256";
          case "SHA-384":
            return "sha384";
          case "SHA-512":
            return "sha512";
          case "SHA3-256":
            return "sha3-256";
          case "SHA3-384":
            return "sha3-384";
          case "SHA3-512":
            return "sha3-512";
          default:
            throw new Error("Unrecognized name");
        }
      }
      static digest(algorithm, data) {
        const hashAlg = this.getAlgorithmName(algorithm);
        const hash = crypto__default["default"].createHash(hashAlg).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
      }
    };
    var RsaOaepProvider = class extends core__namespace.RsaOaepProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onEncrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const dataView = new Uint8Array(data);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = dataView.byteLength;
        const psLength = keySize - dataLength - 2 * hashSize - 2;
        if (dataLength > keySize - 2 * hashSize - 2) {
          throw new Error("Data too large");
        }
        const message = new Uint8Array(keySize);
        const seed = message.subarray(1, hashSize + 1);
        const dataBlock = message.subarray(hashSize + 1);
        dataBlock.set(dataView, hashSize + psLength + 1);
        const labelHash = crypto__default["default"].createHash(internalKey.algorithm.hash.name.replace("-", "")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        dataBlock.set(labelHash, 0);
        dataBlock[hashSize + psLength] = 1;
        crypto__default["default"].randomFillSync(seed);
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i < dataBlock.length; i++) {
          dataBlock[i] ^= dataBlockMask[i];
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i < seed.length; i++) {
          seed[i] ^= seedMask[i];
        }
        if (!internalKey.pem) {
          internalKey.pem = `-----BEGIN PUBLIC KEY-----
${internalKey.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const pkcs0 = crypto__default["default"].publicEncrypt({
          key: internalKey.pem,
          padding: crypto__default["default"].constants.RSA_NO_PADDING
        }, Buffer.from(message));
        return new Uint8Array(pkcs0).buffer;
      }
      async onDecrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = data.byteLength;
        if (dataLength !== keySize) {
          throw new Error("Bad data");
        }
        if (!internalKey.pem) {
          internalKey.pem = `-----BEGIN PRIVATE KEY-----
${internalKey.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        let pkcs0 = crypto__default["default"].privateDecrypt({
          key: internalKey.pem,
          padding: crypto__default["default"].constants.RSA_NO_PADDING
        }, Buffer.from(data));
        const z2 = pkcs0[0];
        const seed = pkcs0.subarray(1, hashSize + 1);
        const dataBlock = pkcs0.subarray(hashSize + 1);
        if (z2 !== 0) {
          throw new Error("Decryption failed");
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i = 0; i < seed.length; i++) {
          seed[i] ^= seedMask[i];
        }
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i = 0; i < dataBlock.length; i++) {
          dataBlock[i] ^= dataBlockMask[i];
        }
        const labelHash = crypto__default["default"].createHash(internalKey.algorithm.hash.name.replace("-", "")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        for (let i = 0; i < hashSize; i++) {
          if (labelHash[i] !== dataBlock[i]) {
            throw new Error("Decryption failed");
          }
        }
        let psEnd = hashSize;
        for (; psEnd < dataBlock.length; psEnd++) {
          const psz = dataBlock[psEnd];
          if (psz === 1) {
            break;
          }
          if (psz !== 0) {
            throw new Error("Decryption failed");
          }
        }
        if (psEnd === dataBlock.length) {
          throw new Error("Decryption failed");
        }
        pkcs0 = dataBlock.subarray(psEnd + 1);
        return new Uint8Array(pkcs0).buffer;
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
      mgf1(algorithm, seed, length = 0) {
        const hashSize = ShaCrypto.size(algorithm) >> 3;
        const mask = new Uint8Array(length);
        const counter = new Uint8Array(4);
        const chunks = Math.ceil(length / hashSize);
        for (let i = 0; i < chunks; i++) {
          counter[0] = i >>> 24;
          counter[1] = i >>> 16 & 255;
          counter[2] = i >>> 8 & 255;
          counter[3] = i & 255;
          const submask = mask.subarray(i * hashSize);
          let chunk = crypto__default["default"].createHash(algorithm.name.replace("-", "")).update(seed).update(counter).digest();
          if (chunk.length > submask.length) {
            chunk = chunk.subarray(0, submask.length);
          }
          submask.set(chunk);
        }
        return mask;
      }
    };
    var RsaEsProvider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "RSAES-PKCS1-v1_5";
        this.usages = {
          publicKey: ["encrypt", "wrapKey"],
          privateKey: ["decrypt", "unwrapKey"]
        };
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
          throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
          throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        switch (algorithm.modulusLength) {
          case 1024:
          case 2048:
          case 4096:
            break;
          default:
            throw new TypeError("modulusLength: Must be 1024, 2048, or 4096");
        }
      }
      async onEncrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));
        return new Uint8Array(enc).buffer;
      }
      async onDecrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));
        return new Uint8Array(dec).buffer;
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
      toCryptoOptions(key) {
        const type4 = key.type.toUpperCase();
        return {
          key: `-----BEGIN ${type4} KEY-----
${getCryptoKey(key).data.toString("base64")}
-----END ${type4} KEY-----`,
          padding: crypto__namespace.constants.RSA_PKCS1_PADDING
        };
      }
    };
    var namedOIDs = {
      "1.2.840.10045.3.1.7": "P-256",
      "P-256": "1.2.840.10045.3.1.7",
      "1.3.132.0.34": "P-384",
      "P-384": "1.3.132.0.34",
      "1.3.132.0.35": "P-521",
      "P-521": "1.3.132.0.35",
      "1.3.132.0.10": "K-256",
      "K-256": "1.3.132.0.10",
      "brainpoolP160r1": "1.3.36.3.3.2.8.1.1.1",
      "1.3.36.3.3.2.8.1.1.1": "brainpoolP160r1",
      "brainpoolP160t1": "1.3.36.3.3.2.8.1.1.2",
      "1.3.36.3.3.2.8.1.1.2": "brainpoolP160t1",
      "brainpoolP192r1": "1.3.36.3.3.2.8.1.1.3",
      "1.3.36.3.3.2.8.1.1.3": "brainpoolP192r1",
      "brainpoolP192t1": "1.3.36.3.3.2.8.1.1.4",
      "1.3.36.3.3.2.8.1.1.4": "brainpoolP192t1",
      "brainpoolP224r1": "1.3.36.3.3.2.8.1.1.5",
      "1.3.36.3.3.2.8.1.1.5": "brainpoolP224r1",
      "brainpoolP224t1": "1.3.36.3.3.2.8.1.1.6",
      "1.3.36.3.3.2.8.1.1.6": "brainpoolP224t1",
      "brainpoolP256r1": "1.3.36.3.3.2.8.1.1.7",
      "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1",
      "brainpoolP256t1": "1.3.36.3.3.2.8.1.1.8",
      "1.3.36.3.3.2.8.1.1.8": "brainpoolP256t1",
      "brainpoolP320r1": "1.3.36.3.3.2.8.1.1.9",
      "1.3.36.3.3.2.8.1.1.9": "brainpoolP320r1",
      "brainpoolP320t1": "1.3.36.3.3.2.8.1.1.10",
      "1.3.36.3.3.2.8.1.1.10": "brainpoolP320t1",
      "brainpoolP384r1": "1.3.36.3.3.2.8.1.1.11",
      "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1",
      "brainpoolP384t1": "1.3.36.3.3.2.8.1.1.12",
      "1.3.36.3.3.2.8.1.1.12": "brainpoolP384t1",
      "brainpoolP512r1": "1.3.36.3.3.2.8.1.1.13",
      "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1",
      "brainpoolP512t1": "1.3.36.3.3.2.8.1.1.14",
      "1.3.36.3.3.2.8.1.1.14": "brainpoolP512t1"
    };
    function getOidByNamedCurve$1(namedCurve) {
      const oid = namedOIDs[namedCurve];
      if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
      }
      return oid;
    }
    var EcPrivateKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "EC",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
      }
      fromJSON(json) {
        if (!json.crv) {
          throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPrivateKey });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    var EcPublicKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "EC",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
      }
      fromJSON(json) {
        if (!json.crv) {
          throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPublicKey });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    var Sha1Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA-1";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha256Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA-256";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha384Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA-384";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha512Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA-512";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha3256Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA3-256";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha3384Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA3-384";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var Sha3512Provider = class extends core__namespace.ProviderCrypto {
      constructor() {
        super(...arguments);
        this.name = "SHA3-512";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    var EcCrypto = class {
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EcPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EcPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const keys = crypto__default["default"].generateKeyPairSync("ec", {
          namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async sign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto__default["default"].createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const signature = signer.sign(options);
        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);
        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);
        return signatureRaw.buffer;
      }
      static async verify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto__default["default"].createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const ecSignature = new core__namespace.asn1.EcDsaSignature();
        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);
        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);
        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);
        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);
        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));
        const ok = signer.verify(options, ecSignatureRaw);
        return ok;
      }
      static async deriveBits(algorithm, baseKey, length) {
        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);
        const ecdh = crypto__default["default"].createECDH(cryptoAlg);
        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);
        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);
        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));
        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);
        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          case "raw": {
            const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
            return publicKeyInfo.publicKey;
          }
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPublicKey });
              return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
          }
          case "raw": {
            const asnKey = new core__namespace.asn1.EcPublicKey(keyData);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "spki": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
            const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
            this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
            const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
            this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
      }
      static assertKeyParameters(parameters, namedCurve) {
        if (!parameters) {
          throw new core__namespace.CryptoError("Key info doesn't have required parameters");
        }
        let namedCurveIdentifier = "";
        try {
          namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;
        } catch (e) {
          throw new core__namespace.CryptoError("Cannot read key info parameters");
        }
        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {
          throw new core__namespace.CryptoError("Key info parameter doesn't match to named curve");
        }
      }
      static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new EcPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));
        keyInfo.publicKey = asnKey.value;
        const key = new EcPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static getOpenSSLNamedCurve(curve) {
        switch (curve.toUpperCase()) {
          case "P-256":
            return "prime256v1";
          case "K-256":
            return "secp256k1";
          case "P-384":
            return "secp384r1";
          case "P-521":
            return "secp521r1";
          default:
            return curve;
        }
      }
    };
    EcCrypto.publicKeyUsages = ["verify"];
    EcCrypto.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];
    var EcdsaProvider = class extends core__namespace.EcdsaProvider {
      constructor() {
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
          throw new TypeError("key: Is not EC CryptoKey");
        }
      }
    };
    var EcdhProvider = class extends core__namespace.EcdhProvider {
      constructor() {
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
          throw new TypeError("key: Is not EC CryptoKey");
        }
      }
      async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
      }
    };
    var edOIDs = {
      [core__namespace.asn1.idEd448]: "Ed448",
      "ed448": core__namespace.asn1.idEd448,
      [core__namespace.asn1.idX448]: "X448",
      "x448": core__namespace.asn1.idX448,
      [core__namespace.asn1.idEd25519]: "Ed25519",
      "ed25519": core__namespace.asn1.idEd25519,
      [core__namespace.asn1.idX25519]: "X25519",
      "x25519": core__namespace.asn1.idX25519
    };
    function getOidByNamedCurve(namedCurve) {
      const oid = edOIDs[namedCurve.toLowerCase()];
      if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
      }
      return oid;
    }
    var EdPrivateKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "OKP",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
      }
      fromJSON(json) {
        if (!json.crv) {
          throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.CurvePrivateKey });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    var EdPublicKey = class extends AsymmetricKey {
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return keyInfo.publicKey;
      }
      toJSON() {
        const key = this.getKey();
        const json = {
          kty: "OKP",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json, {
          x: pvtsutils.Convert.ToBase64Url(key)
        });
      }
      fromJSON(json) {
        if (!json.crv) {
          throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        if (!json.x) {
          throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);
        }
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    var EdCrypto = class {
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EdPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EdPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const type4 = algorithm.namedCurve.toLowerCase();
        const keys = crypto__default["default"].generateKeyPairSync(type4, {
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async sign(algorithm, key, data) {
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const signature = crypto__default["default"].sign(null, Buffer.from(data), options);
        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);
      }
      static async verify(algorithm, key, signature, data) {
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const ok = crypto__default["default"].verify(null, Buffer.from(data), options, Buffer.from(signature));
        return ok;
      }
      static async deriveBits(algorithm, baseKey, length) {
        const publicKey = crypto__default["default"].createPublicKey({
          key: algorithm.public.data,
          format: "der",
          type: "spki"
        });
        const privateKey = crypto__default["default"].createPrivateKey({
          key: baseKey.data,
          format: "der",
          type: "pkcs8"
        });
        const bits = crypto__default["default"].diffieHellman({
          publicKey,
          privateKey
        });
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          case "raw": {
            const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
            return publicKeyInfo.publicKey;
          }
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.CurvePrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              if (!jwk.x) {
                throw new TypeError("keyData: Cannot get required 'x' filed");
              }
              return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);
            }
          }
          case "raw": {
            return this.importPublicKey(keyData, algorithm, extractable, keyUsages);
          }
          case "spki": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
            return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
            const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
      }
      static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPrivateKey();
        key.fromJSON({
          crv: algorithm.namedCurve,
          d: pvtsutils.Convert.ToBase64Url(asnKey.d)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPublicKey();
        key.fromJSON({
          crv: algorithm.namedCurve,
          x: pvtsutils.Convert.ToBase64Url(asnKey)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
    };
    EdCrypto.publicKeyUsages = ["verify"];
    EdCrypto.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];
    var EdDsaProvider = class extends core__namespace.EdDsaProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
          name: this.name,
          namedCurve: algorithm.namedCurve.replace(/^ed/i, "Ed")
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
    };
    var EcdhEsProvider = class extends core__namespace.EcdhEsProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
          name: this.name,
          namedCurve: algorithm.namedCurve.toUpperCase()
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
      }
      async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
    };
    var PbkdfCryptoKey = class extends CryptoKey {
    };
    var Pbkdf2Provider = class extends core__namespace.Pbkdf2Provider {
      async onDeriveBits(algorithm, baseKey, length) {
        return new Promise((resolve3, reject2) => {
          const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);
          const hash = algorithm.hash.name.replace("-", "");
          crypto__default["default"].pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {
            if (err) {
              reject2(err);
            } else {
              resolve3(new Uint8Array(derivedBits).buffer);
            }
          });
        });
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format === "raw") {
          const key = new PbkdfCryptoKey();
          key.data = Buffer.from(keyData);
          key.algorithm = { name: this.name };
          key.extractable = false;
          key.usages = keyUsages;
          return setCryptoKey(key);
        }
        throw new core__namespace.OperationError("format: Must be 'raw'");
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {
          throw new TypeError("key: Is not PBKDF CryptoKey");
        }
      }
    };
    var HmacCryptoKey = class extends CryptoKey {
      get alg() {
        const hash = this.algorithm.hash.name.toUpperCase();
        return `HS${hash.replace("SHA-", "")}`;
      }
      set alg(value2) {
      }
    };
    tslib.__decorate([
      jsonSchema.JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], HmacCryptoKey.prototype, "data", void 0);
    var HmacProvider = class extends core__namespace.HmacProvider {
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;
        const key = new HmacCryptoKey();
        key.algorithm = {
          ...algorithm,
          length,
          name: this.name
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default["default"].randomBytes(length >> 3);
        return setCryptoKey(key);
      }
      async onSign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto__default["default"].createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return new Uint8Array(hmac).buffer;
      }
      async onVerify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto__default["default"].createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return hmac.compare(Buffer.from(signature)) === 0;
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });
            break;
          case "raw":
            key = new HmacCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = {
          hash: { name: algorithm.hash.name },
          name: this.name,
          length: key.data.length << 3
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
      }
      async onExportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));
          case "raw":
            return new Uint8Array(getCryptoKey(key).data).buffer;
          default:
            throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {
          throw new TypeError("key: Is not HMAC CryptoKey");
        }
      }
    };
    var HkdfCryptoKey = class extends CryptoKey {
    };
    var HkdfProvider = class extends core__namespace.HkdfProvider {
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format.toLowerCase() !== "raw") {
          throw new core__namespace.OperationError("Operation not supported");
        }
        const key = new HkdfCryptoKey();
        key.data = Buffer.from(keyData);
        key.algorithm = { name: this.name };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
      }
      async onDeriveBits(params, baseKey, length) {
        const hash = params.hash.name.replace("-", "");
        const hashLength = crypto__default["default"].createHash(hash).digest().length;
        const byteLength = length / 8;
        const info = core.BufferSourceConverter.toUint8Array(params.info);
        const PRK = crypto__default["default"].createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt)).update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();
        const blocks = [Buffer.alloc(0)];
        const blockCount = Math.ceil(byteLength / hashLength) + 1;
        for (let i = 1; i < blockCount; ++i) {
          blocks.push(crypto__default["default"].createHmac(hash, PRK).update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])])).digest());
        }
        return Buffer.concat(blocks).slice(0, byteLength);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {
          throw new TypeError("key: Is not HKDF CryptoKey");
        }
      }
    };
    var ShakeCrypto = class {
      static digest(algorithm, data) {
        const hash = crypto__default["default"].createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length }).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
      }
    };
    var Shake128Provider = class extends core__namespace.Shake128Provider {
      async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
      }
    };
    var Shake256Provider = class extends core__namespace.Shake256Provider {
      async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
      }
    };
    var SubtleCrypto = class extends core__namespace.SubtleCrypto {
      constructor() {
        var _a;
        super();
        this.providers.set(new AesCbcProvider());
        this.providers.set(new AesCtrProvider());
        this.providers.set(new AesGcmProvider());
        this.providers.set(new AesCmacProvider());
        this.providers.set(new AesKwProvider());
        this.providers.set(new AesEcbProvider());
        this.providers.set(new DesCbcProvider());
        this.providers.set(new DesEde3CbcProvider());
        this.providers.set(new RsaSsaProvider());
        this.providers.set(new RsaPssProvider());
        this.providers.set(new RsaOaepProvider());
        this.providers.set(new RsaEsProvider());
        this.providers.set(new EcdsaProvider());
        this.providers.set(new EcdhProvider());
        this.providers.set(new Sha1Provider());
        this.providers.set(new Sha256Provider());
        this.providers.set(new Sha384Provider());
        this.providers.set(new Sha512Provider());
        this.providers.set(new Pbkdf2Provider());
        this.providers.set(new HmacProvider());
        this.providers.set(new HkdfProvider());
        const nodeMajorVersion = (_a = /^v(\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {
          this.providers.set(new Shake128Provider());
          this.providers.set(new Shake256Provider());
        }
        const hashes = crypto__namespace.getHashes();
        if (hashes.includes("sha3-256")) {
          this.providers.set(new Sha3256Provider());
        }
        if (hashes.includes("sha3-384")) {
          this.providers.set(new Sha3384Provider());
        }
        if (hashes.includes("sha3-512")) {
          this.providers.set(new Sha3512Provider());
        }
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {
          this.providers.set(new EdDsaProvider());
          this.providers.set(new EcdhEsProvider());
        }
      }
    };
    var Crypto2 = class extends core__namespace.Crypto {
      constructor() {
        super(...arguments);
        this.subtle = new SubtleCrypto();
      }
      getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
          throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");
        }
        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);
        crypto__default["default"].randomFillSync(buffer);
        return array;
      }
    };
    Object.defineProperty(exports, "CryptoKey", {
      enumerable: true,
      get: function() {
        return core.CryptoKey;
      }
    });
    exports.Crypto = Crypto2;
  }
});

// ../taqueria-protocol/Environment.ts
var Environment_exports = {};
__export(Environment_exports, {
  create: () => create2,
  factory: () => factory,
  from: () => from,
  generatedSchemas: () => generatedSchemas,
  make: () => make,
  of: () => of,
  rawSchema: () => rawSchema,
  schemas: () => schemas
});

// ../taqueria-protocol/TaqError.ts
var TaqError_exports = {};
__export(TaqError_exports, {
  E_TaqError: () => E_TaqError,
  create: () => create,
  toFutureParseErr: () => toFutureParseErr,
  toFutureParseUnknownErr: () => toFutureParseUnknownErr,
  toParseErr: () => toParseErr,
  toParseUnknownErr: () => toParseUnknownErr
});

// ../node_modules/fluture/src/future.js
var import_sanctuary_type_identifiers2 = __toESM(require_sanctuary_type_identifiers(), 1);

// ../node_modules/fluture/src/internal/const.js
var FL = {
  alt: "fantasy-land/alt",
  ap: "fantasy-land/ap",
  bimap: "fantasy-land/bimap",
  chain: "fantasy-land/chain",
  chainRec: "fantasy-land/chainRec",
  map: "fantasy-land/map",
  of: "fantasy-land/of",
  zero: "fantasy-land/zero"
};
var ordinal = ["first", "second", "third", "fourth", "fifth"];
var namespace = "fluture";
var name = "Future";
var version = 5;
var $$type = namespace + "/" + name + "@" + version;

// ../node_modules/fluture/src/internal/list.js
function List(head, tail) {
  this.head = head;
  this.tail = tail;
}
List.prototype.toJSON = function() {
  return toArray(this);
};
var nil = new List(null, null);
nil.tail = nil;
function isNil(list) {
  return list.tail === list;
}
function cons(head, tail) {
  return new List(head, tail);
}
function reverse(xs) {
  var ys = nil, tail = xs;
  while (!isNil(tail)) {
    ys = cons(tail.head, ys);
    tail = tail.tail;
  }
  return ys;
}
function cat(xs, ys) {
  var zs = ys, tail = reverse(xs);
  while (!isNil(tail)) {
    zs = cons(tail.head, zs);
    tail = tail.tail;
  }
  return zs;
}
function toArray(xs) {
  var tail = xs, arr = [];
  while (!isNil(tail)) {
    arr.push(tail.head);
    tail = tail.tail;
  }
  return arr;
}

// ../node_modules/fluture/src/internal/debug.js
var captureStackTrace = Error.captureStackTrace || captureStackTraceFallback;
var _debug = debugHandleNone;
function debugHandleNone(x) {
  return x;
}
function debug(x, fn, a, b, c) {
  return _debug(x, fn, a, b, c);
}
function captureContext(previous, tag, fn) {
  return debug(previous, debugCaptureContext, previous, tag, fn);
}
function debugCaptureContext(previous, tag, fn) {
  var context = { tag, name: " from " + tag + ":" };
  captureStackTrace(context, fn);
  return cons(context, previous);
}
function captureApplicationContext(context, n, f) {
  return debug(context, debugCaptureApplicationContext, context, n, f);
}
function debugCaptureApplicationContext(context, n, f) {
  return debugCaptureContext(context, ordinal[n - 1] + " application of " + f.name, f);
}
function captureStackTraceFallback(x) {
  var e = new Error();
  if (typeof e.stack === "string") {
    x.stack = x.name + "\n" + e.stack.split("\n").slice(1).join("\n");
  } else {
    x.stack = x.name;
  }
}

// ../node_modules/fluture/src/internal/utils.js
var import_sanctuary_show = __toESM(require_sanctuary_show(), 1);
var setImmediate = typeof setImmediate === "undefined" ? setImmediateFallback : setImmediate;
function noop() {
}
function moop() {
  return this;
}
function call(f, x) {
  return f(x);
}
function setImmediateFallback(f, x) {
  return setTimeout(f, 0, x);
}
function raise(x) {
  setImmediate(function rethrowErrorDelayedToEscapePromiseCatch() {
    throw x;
  });
}

// ../node_modules/fluture/src/internal/error.js
var import_sanctuary_type_identifiers = __toESM(require_sanctuary_type_identifiers(), 1);
function showArg(x) {
  return (0, import_sanctuary_show.default)(x) + " :: " + import_sanctuary_type_identifiers.default.parse((0, import_sanctuary_type_identifiers.default)(x)).name;
}
function error(message) {
  return new Error(message);
}
function typeError(message) {
  return new TypeError(message);
}
function invalidArgument(it, at, expected, actual) {
  return typeError(
    it + "() expects its " + ordinal[at] + " argument to " + expected + ".\n  Actual: " + showArg(actual)
  );
}
function invalidArgumentOf(expected) {
  return function(it, at, actual) {
    return invalidArgument(it, at, expected, actual);
  };
}
function invalidArity(f, args) {
  return new TypeError(
    f.name + "() expects to be called with a single argument per invocation\n  Saw: " + args.length + " arguments" + Array.prototype.slice.call(args).map(function(arg, i) {
      return "\n  " + (ordinal[i] ? ordinal[i].charAt(0).toUpperCase() + ordinal[i].slice(1) : "Argument " + String(i + 1)) + ": " + showArg(arg);
    }).join("")
  );
}
function invalidNamespace(m, x) {
  return "The Future was not created by " + namespace + ". Make sure you transform other Futures to " + namespace + " Futures. Got " + (x ? "a Future from " + x : "an unscoped Future") + ".\n  See: https://github.com/fluture-js/Fluture#casting-futures";
}
function invalidVersion(m, x) {
  return "The Future was created by " + (x < version ? "an older" : "a newer") + " version of " + namespace + ". This means that one of the sources which creates Futures is outdated. Update this source, or transform its created Futures to be compatible.\n  See: https://github.com/fluture-js/Fluture#casting-futures";
}
function invalidFuture(desc, m, s) {
  var id = import_sanctuary_type_identifiers.default.parse((0, import_sanctuary_type_identifiers.default)(m));
  var info = id.name === name ? "\n" + (id.namespace !== namespace ? invalidNamespace(m, id.namespace) : id.version !== version ? invalidVersion(m, id.version) : "Nothing seems wrong. Contact the Fluture maintainers.") : "";
  return typeError(
    desc + " to be a valid Future." + info + "\n  Actual: " + (0, import_sanctuary_show.default)(m) + " :: " + id.name + (s || "")
  );
}
function invalidFutureArgument(it, at, m, s) {
  return invalidFuture(it + "() expects its " + ordinal[at] + " argument", m, s);
}
function ensureError(value2, fn) {
  var message;
  try {
    if (value2 instanceof Error)
      return value2;
    message = "A Non-Error was thrown from a Future: " + (0, import_sanctuary_show.default)(value2);
  } catch (_23) {
    message = "Something was thrown from a Future, but it could not be converted to String";
  }
  var e = error(message);
  captureStackTrace(e, fn);
  return e;
}
function assignUnenumerable(o, prop, value2) {
  Object.defineProperty(o, prop, { value: value2, writable: true, configurable: true });
}
function wrapException(caught, callingFuture) {
  var origin = ensureError(caught, wrapException);
  var context = cat(origin.context || nil, callingFuture.context);
  var e = error(origin.message);
  assignUnenumerable(e, "future", origin.future || callingFuture);
  assignUnenumerable(e, "reason", origin.reason || origin);
  assignUnenumerable(e, "stack", e.reason.stack);
  return withExtraContext(e, context);
}
function withExtraContext(e, context) {
  assignUnenumerable(e, "context", context);
  assignUnenumerable(e, "stack", e.stack + contextToStackTrace(context));
  return e;
}
function contextToStackTrace(context) {
  var stack = "", tail = context;
  while (tail !== nil) {
    stack = stack + "\n" + tail.head.stack;
    tail = tail.tail;
  }
  return stack;
}

// ../node_modules/fluture/src/internal/predicates.js
function isFunction(f) {
  return typeof f === "function";
}
function isThenable(m) {
  return m instanceof Promise || m != null && isFunction(m.then);
}
function isBoolean(f) {
  return typeof f === "boolean";
}
function isNumber(f) {
  return typeof f === "number";
}
function isUnsigned(n) {
  return n === Infinity || isNumber(n) && n > 0 && n % 1 === 0;
}
function isObject(o) {
  return o !== null && typeof o === "object";
}
function isIterator(i) {
  return isObject(i) && isFunction(i.next);
}
function isArray(x) {
  return Array.isArray(x);
}
function hasMethod(method, x) {
  return x != null && isFunction(x[method]);
}
function isFunctor(x) {
  return hasMethod(FL.map, x);
}
function isAlt(x) {
  return isFunctor(x) && hasMethod(FL.alt, x);
}
function isApply(x) {
  return isFunctor(x) && hasMethod(FL.ap, x);
}
function isBifunctor(x) {
  return isFunctor(x) && hasMethod(FL.bimap, x);
}
function isChain(x) {
  return isApply(x) && hasMethod(FL.chain, x);
}

// ../node_modules/fluture/src/internal/iteration.js
function Next(x) {
  return { done: false, value: x };
}
function Done(x) {
  return { done: true, value: x };
}
function isIteration(x) {
  return isObject(x) && isBoolean(x.done);
}

// ../node_modules/fluture/src/future.js
function alwaysTrue() {
  return true;
}
function getArgs(it) {
  var args = new Array(it.arity);
  for (var i = 1; i <= it.arity; i++) {
    args[i - 1] = it["$" + String(i)];
  }
  return args;
}
function showArg2(arg) {
  return " (" + (0, import_sanctuary_show.default)(arg) + ")";
}
var any = { pred: alwaysTrue, error: invalidArgumentOf("be anything") };
var func = { pred: isFunction, error: invalidArgumentOf("be a Function") };
var future = { pred: isFuture, error: invalidFutureArgument };
var positiveInteger = { pred: isUnsigned, error: invalidArgumentOf("be a positive Integer") };
function application(n, f, type4, args, prev) {
  if (args.length < 2 && type4.pred(args[0]))
    return captureApplicationContext(prev, n, f);
  var e = args.length > 1 ? invalidArity(f, args) : type4.error(f.name, n - 1, args[0]);
  captureStackTrace(e, f);
  throw withExtraContext(e, prev);
}
function application1(f, type4, args) {
  return application(1, f, type4, args, nil);
}
function Future(computation) {
  var context = application1(Future, func, arguments);
  return new Computation(context, computation);
}
function isFuture(x) {
  return x instanceof Future || (0, import_sanctuary_type_identifiers2.default)(x) === $$type;
}
Future["@@type"] = $$type;
Future.constructor = { prototype: Future };
Future[FL.of] = resolve;
Future[FL.chainRec] = chainRec;
Future.prototype["@@type"] = $$type;
Future.prototype["@@show"] = function Future$show() {
  return this.toString();
};
Future.prototype.pipe = function Future$pipe(f) {
  if (!isFunction(f))
    throw invalidArgument("Future#pipe", 0, "be a Function", f);
  return f(this);
};
Future.prototype[FL.ap] = function Future$FL$ap(other) {
  var context = captureContext(nil, "a Fantasy Land dispatch to ap", Future$FL$ap);
  return other._transform(new ApTransformation(context, this));
};
Future.prototype[FL.map] = function Future$FL$map(mapper) {
  var context = captureContext(nil, "a Fantasy Land dispatch to map", Future$FL$map);
  return this._transform(new MapTransformation(context, mapper));
};
Future.prototype[FL.bimap] = function Future$FL$bimap(lmapper, rmapper) {
  var context = captureContext(nil, "a Fantasy Land dispatch to bimap", Future$FL$bimap);
  return this._transform(new BimapTransformation(context, lmapper, rmapper));
};
Future.prototype[FL.chain] = function Future$FL$chain(mapper) {
  var context = captureContext(nil, "a Fantasy Land dispatch to chain", Future$FL$chain);
  return this._transform(new ChainTransformation(context, mapper));
};
Future.prototype[FL.alt] = function Future$FL$alt(other) {
  var context = captureContext(nil, "a Fantasy Land dispatch to alt", Future$FL$alt);
  return this._transform(new AltTransformation(context, other));
};
Future.prototype.extractLeft = function Future$extractLeft() {
  return [];
};
Future.prototype.extractRight = function Future$extractRight() {
  return [];
};
Future.prototype._transform = function Future$transform(transformation) {
  return new Transformer(transformation.context, this, cons(transformation, nil));
};
Future.prototype.isTransformer = false;
Future.prototype.context = nil;
Future.prototype.arity = 0;
Future.prototype.name = "future";
Future.prototype.toString = function Future$toString() {
  return this.name + getArgs(this).map(showArg2).join("");
};
Future.prototype.toJSON = function Future$toJSON() {
  return { $: $$type, kind: "interpreter", type: this.name, args: getArgs(this) };
};
function createInterpreter(arity, name2, interpret) {
  var Interpreter = function(context, $1, $2, $3) {
    this.context = context;
    this.$1 = $1;
    this.$2 = $2;
    this.$3 = $3;
  };
  Interpreter.prototype = Object.create(Future.prototype);
  Interpreter.prototype.arity = arity;
  Interpreter.prototype.name = name2;
  Interpreter.prototype._interpret = interpret;
  return Interpreter;
}
var Computation = createInterpreter(1, "Future", function Computation$interpret(rec, rej, res) {
  var computation = this.$1, open = false, cancel = noop, cont = function() {
    open = true;
  };
  try {
    cancel = computation(function Computation$rej(x) {
      cont = function Computation$rej$cont() {
        open = false;
        rej(x);
      };
      if (open) {
        cont();
      }
    }, function Computation$res(x) {
      cont = function Computation$res$cont() {
        open = false;
        res(x);
      };
      if (open) {
        cont();
      }
    });
  } catch (e) {
    rec(wrapException(e, this));
    return noop;
  }
  if (!(isFunction(cancel) && cancel.length === 0)) {
    rec(wrapException(typeError(
      "The computation was expected to return a nullary cancellation function\n  Actual: " + (0, import_sanctuary_show.default)(cancel)
    ), this));
    return noop;
  }
  cont();
  return function Computation$cancel() {
    if (open) {
      open = false;
      cancel && cancel();
    }
  };
});
var Never = createInterpreter(0, "never", function Never$interpret() {
  return noop;
});
Never.prototype._isNever = true;
var never = new Never(nil);
var Crash = createInterpreter(1, "crash", function Crash$interpret(rec) {
  rec(this.$1);
  return noop;
});
function crash(x) {
  return new Crash(application1(crash, any, arguments), x);
}
var Reject = createInterpreter(1, "reject", function Reject$interpret(rec, rej) {
  rej(this.$1);
  return noop;
});
Reject.prototype.extractLeft = function Reject$extractLeft() {
  return [this.$1];
};
function reject(x) {
  return new Reject(application1(reject, any, arguments), x);
}
var Resolve = createInterpreter(1, "resolve", function Resolve$interpret(rec, rej, res) {
  res(this.$1);
  return noop;
});
Resolve.prototype.extractRight = function Resolve$extractRight() {
  return [this.$1];
};
function resolve(x) {
  return new Resolve(application1(resolve, any, arguments), x);
}
function chainRec(step, init2) {
  return resolve(Next(init2))._transform(new ChainTransformation(nil, function chainRec$recur(o) {
    return o.done ? resolve(o.value) : step(Next, Done, o.value)._transform(new ChainTransformation(nil, chainRec$recur));
  }));
}
var Transformer = createInterpreter(2, "transform", function Transformer$interpret(rec, rej, res) {
  var cold = nil, hot = nil;
  var future2, transformation, cancel = noop, settled, async = true, it;
  function nextHot() {
    var x = hot.head;
    hot = hot.tail;
    return x;
  }
  function nextCold() {
    var x = cold.head;
    cold = cold.tail;
    return x;
  }
  function settle(m) {
    settled = true;
    future2 = m;
    if (future2.isTransformer) {
      var tail = future2.$2;
      while (!isNil(tail)) {
        cold = cons(tail.head, cold);
        tail = tail.tail;
      }
      future2 = future2.$1;
    }
    if (async)
      drain();
  }
  function rejected(x) {
    settle(transformation.rejected(x));
  }
  function resolved(x) {
    settle(transformation.resolved(x));
  }
  function early(m, terminator) {
    cancel();
    cold = nil;
    if (async && transformation !== terminator) {
      transformation.cancel();
      while ((it = nextHot()) && it !== terminator)
        it.cancel();
    }
    settle(m);
  }
  function Sequence$cancel() {
    cancel();
    transformation && transformation.cancel();
    while (it = nextHot())
      it.cancel();
  }
  function exception(e) {
    Sequence$cancel();
    settled = true;
    cold = hot = nil;
    var error3 = wrapException(e, future2);
    future2 = never;
    rec(error3);
  }
  function warmupActions() {
    cold = reverse(cold);
    while (cold !== nil) {
      it = cold.head.run(early);
      if (settled)
        return;
      hot = cons(it, hot);
      cold = cold.tail;
    }
    transformation = transformation.run(early);
  }
  function drain() {
    async = false;
    while (true) {
      settled = false;
      if (transformation = nextCold()) {
        cancel = future2._interpret(exception, rejected, resolved);
        if (!settled)
          warmupActions();
      } else if (transformation = nextHot()) {
        cancel = future2._interpret(exception, rejected, resolved);
      } else
        break;
      if (settled)
        continue;
      async = true;
      return;
    }
    cancel = future2._interpret(exception, rej, res);
  }
  settle(this);
  return Sequence$cancel;
});
Transformer.prototype.isTransformer = true;
Transformer.prototype._transform = function Transformer$_transform(transformation) {
  return new Transformer(transformation.context, this.$1, cons(transformation, this.$2));
};
Transformer.prototype.toString = function Transformer$toString() {
  return toArray(reverse(this.$2)).reduce(function(str, action) {
    return action.name + getArgs(action).map(showArg2).join("") + " (" + str + ")";
  }, this.$1.toString());
};
function BaseTransformation$rejected(x) {
  this.cancel();
  return new Reject(this.context, x);
}
function BaseTransformation$resolved(x) {
  this.cancel();
  return new Resolve(this.context, x);
}
function BaseTransformation$toJSON() {
  return { $: $$type, kind: "transformation", type: this.name, args: getArgs(this) };
}
var BaseTransformation = {
  rejected: BaseTransformation$rejected,
  resolved: BaseTransformation$resolved,
  run: moop,
  cancel: noop,
  context: nil,
  arity: 0,
  name: "transform",
  toJSON: BaseTransformation$toJSON
};
function wrapHandler(handler) {
  return function transformationHandler(x) {
    var m;
    try {
      m = handler.call(this, x);
    } catch (e) {
      return new Crash(this.context, e);
    }
    if (isFuture(m)) {
      return m;
    }
    return new Crash(this.context, invalidFuture(
      this.name + " expects the return value from the function it's given",
      m,
      "\n  When called with: " + (0, import_sanctuary_show.default)(x)
    ));
  };
}
function createTransformation(arity, name2, prototype) {
  var Transformation = function(context, $1, $2) {
    this.context = context;
    this.$1 = $1;
    this.$2 = $2;
  };
  Transformation.prototype = Object.create(BaseTransformation);
  Transformation.prototype.arity = arity;
  Transformation.prototype.name = name2;
  if (typeof prototype.rejected === "function") {
    Transformation.prototype.rejected = wrapHandler(prototype.rejected);
  }
  if (typeof prototype.resolved === "function") {
    Transformation.prototype.resolved = wrapHandler(prototype.resolved);
  }
  if (typeof prototype.run === "function") {
    Transformation.prototype.run = prototype.run;
  }
  return Transformation;
}
var ApTransformation = createTransformation(1, "ap", {
  resolved: function ApTransformation$resolved(f) {
    if (isFunction(f))
      return this.$1._transform(new MapTransformation(this.context, f));
    throw typeError(
      "ap expects the second Future to resolve to a Function\n  Actual: " + (0, import_sanctuary_show.default)(f)
    );
  }
});
var AltTransformation = createTransformation(1, "alt", {
  rejected: function AltTransformation$rejected() {
    return this.$1;
  }
});
var MapTransformation = createTransformation(1, "map", {
  resolved: function MapTransformation$resolved(x) {
    return new Resolve(this.context, call(this.$1, x));
  }
});
var BimapTransformation = createTransformation(2, "bimap", {
  rejected: function BimapTransformation$rejected(x) {
    return new Reject(this.context, call(this.$1, x));
  },
  resolved: function BimapTransformation$resolved(x) {
    return new Resolve(this.context, call(this.$2, x));
  }
});
var ChainTransformation = createTransformation(1, "chain", {
  resolved: function ChainTransformation$resolved(x) {
    return call(this.$1, x);
  }
});

// ../node_modules/fluture/src/after.js
var After = createInterpreter(2, "after", function After$interpret(rec, rej, res) {
  var id = setTimeout(res, this.$1, this.$2);
  return function After$cancel() {
    clearTimeout(id);
  };
});
After.prototype.extractRight = function After$extractRight() {
  return [this.$2];
};

// ../node_modules/fluture/src/alt.js
var alternative = { pred: isAlt, error: invalidArgumentOf("have Alt implemented") };

// ../node_modules/fluture/src/and.js
var AndTransformation = createTransformation(1, "and", {
  resolved: function AndTransformation$resolved() {
    return this.$1;
  }
});

// ../node_modules/fluture/src/ap.js
var apply = { pred: isApply, error: invalidArgumentOf("have Apply implemented") };

// ../node_modules/fluture/src/encase-p.js
function invalidPromise(p, f, a) {
  return typeError(
    "encaseP() expects the function it's given to return a Promise/Thenable\n  Actual: " + (0, import_sanctuary_show.default)(p) + "\n  From calling: " + (0, import_sanctuary_show.default)(f) + "\n  With: " + (0, import_sanctuary_show.default)(a)
  );
}
var EncaseP = createInterpreter(2, "encaseP", function EncaseP$interpret(rec, rej, res) {
  var open = true, fn = this.$1, arg = this.$2, p;
  try {
    p = fn(arg);
  } catch (e) {
    rec(wrapException(e, this));
    return noop;
  }
  if (!isThenable(p)) {
    rec(wrapException(invalidPromise(p, fn, arg), this));
    return noop;
  }
  p.then(function EncaseP$res(x) {
    if (open) {
      open = false;
      res(x);
    }
  }, function EncaseP$rej(x) {
    if (open) {
      open = false;
      rej(x);
    }
  });
  return function EncaseP$cancel() {
    open = false;
  };
});
function encaseP(f) {
  var context1 = application1(encaseP, func, arguments);
  return function encaseP2(x) {
    var context2 = application(2, encaseP2, any, arguments, context1);
    return new EncaseP(context2, f, x);
  };
}

// ../node_modules/fluture/src/attempt-p.js
function attemptP(_23) {
  return encaseP.apply(this, arguments)(void 0);
}

// ../node_modules/fluture/src/encase.js
var Encase = createInterpreter(2, "encase", function Encase$interpret(rec, rej, res) {
  var fn = this.$1, r;
  try {
    r = fn(this.$2);
  } catch (e) {
    rej(e);
    return noop;
  }
  res(r);
  return noop;
});

// ../node_modules/fluture/src/bimap.js
var bifunctor = { pred: isBifunctor, error: invalidArgumentOf("have Bifunctor implemented") };

// ../node_modules/fluture/src/bichain.js
var BichainTransformation = createTransformation(2, "bichain", {
  rejected: function BichainTransformation$rejected(x) {
    return call(this.$1, x);
  },
  resolved: function BichainTransformation$resolved(x) {
    return call(this.$2, x);
  }
});

// ../node_modules/fluture/src/internal/parallel.js
function Eager(future2) {
  var _this = this;
  _this.rec = noop;
  _this.rej = noop;
  _this.res = noop;
  _this.crashed = false;
  _this.rejected = false;
  _this.resolved = false;
  _this.value = null;
  _this.cancel = future2._interpret(function Eager$crash(x) {
    _this.value = x;
    _this.crashed = true;
    _this.cancel = noop;
    _this.rec(x);
  }, function Eager$reject(x) {
    _this.value = x;
    _this.rejected = true;
    _this.cancel = noop;
    _this.rej(x);
  }, function Eager$resolve(x) {
    _this.value = x;
    _this.resolved = true;
    _this.cancel = noop;
    _this.res(x);
  });
}
Eager.prototype = Object.create(Future.prototype);
Eager.prototype._interpret = function Eager$interpret(rec, rej, res) {
  if (this.crashed)
    rec(this.value);
  else if (this.rejected)
    rej(this.value);
  else if (this.resolved)
    res(this.value);
  else {
    this.rec = rec;
    this.rej = rej;
    this.res = res;
  }
  return this.cancel;
};
function earlyCrash(early, x) {
  early(crash(x));
}
function earlyReject(early, x) {
  early(reject(x));
}
function earlyResolve(early, x) {
  early(resolve(x));
}
function createParallelTransformation(name2, rec, rej, res, prototype) {
  var ParallelTransformation = createTransformation(1, name2, Object.assign({
    run: function Parallel$run(early) {
      var eager3 = new Eager(this.$1);
      var transformation = new ParallelTransformation(this.context, eager3);
      function Parallel$early(m) {
        early(m, transformation);
      }
      transformation.cancel = eager3._interpret(
        function Parallel$rec(x) {
          rec(Parallel$early, x);
        },
        function Parallel$rej(x) {
          rej(Parallel$early, x);
        },
        function Parallel$res(x) {
          res(Parallel$early, x);
        }
      );
      return transformation;
    }
  }, prototype));
  return ParallelTransformation;
}

// ../node_modules/fluture/src/both.js
var PairTransformation = createTransformation(1, "pair", {
  resolved: function PairTransformation$resolved(x) {
    return new Resolve(this.context, [x, this.$1]);
  }
});
var BothTransformation = createParallelTransformation("both", earlyCrash, earlyReject, noop, {
  resolved: function BothTransformation$resolved(x) {
    return this.$1._transform(new PairTransformation(this.context, x));
  }
});

// ../node_modules/fluture/src/cache.js
var Cold = 0;
var Pending = 1;
var Crashed = 2;
var Rejected = 3;
var Resolved = 4;
function Queued(rec, rej, res) {
  this[Crashed] = rec;
  this[Rejected] = rej;
  this[Resolved] = res;
}
var Cache = createInterpreter(1, "cache", function Cache$interpret(rec, rej, res) {
  var cancel = noop;
  switch (this._state) {
    case Pending:
      cancel = this._addToQueue(rec, rej, res);
      break;
    case Crashed:
      rec(this._value);
      break;
    case Rejected:
      rej(this._value);
      break;
    case Resolved:
      res(this._value);
      break;
    default:
      this._queue = [];
      cancel = this._addToQueue(rec, rej, res);
      this.run();
  }
  return cancel;
});
Cache.prototype._cancel = noop;
Cache.prototype._queue = null;
Cache.prototype._queued = 0;
Cache.prototype._value = void 0;
Cache.prototype._state = Cold;
Cache.prototype.extractLeft = function Cache$extractLeft() {
  return this._state === Rejected ? [this._value] : [];
};
Cache.prototype.extractRight = function Cache$extractRight() {
  return this._state === Resolved ? [this._value] : [];
};
Cache.prototype._addToQueue = function Cache$addToQueue(rec, rej, res) {
  var _this = this;
  if (_this._state > Pending)
    return noop;
  var i = _this._queue.push(new Queued(rec, rej, res)) - 1;
  _this._queued = _this._queued + 1;
  return function Cache$removeFromQueue() {
    if (_this._state > Pending)
      return;
    _this._queue[i] = void 0;
    _this._queued = _this._queued - 1;
    if (_this._queued === 0)
      _this.reset();
  };
};
Cache.prototype._drainQueue = function Cache$drainQueue() {
  if (this._state <= Pending)
    return;
  if (this._queued === 0)
    return;
  var queue = this._queue;
  var length = queue.length;
  var state = this._state;
  var value2 = this._value;
  for (var i = 0; i < length; i++) {
    queue[i] && queue[i][state](value2);
    queue[i] = void 0;
  }
  this._queue = void 0;
  this._queued = 0;
};
Cache.prototype.crash = function Cache$crash(error3) {
  if (this._state > Pending)
    return;
  this._value = error3;
  this._state = Crashed;
  this._drainQueue();
};
Cache.prototype.reject = function Cache$reject(reason) {
  if (this._state > Pending)
    return;
  this._value = reason;
  this._state = Rejected;
  this._drainQueue();
};
Cache.prototype.resolve = function Cache$resolve(value2) {
  if (this._state > Pending)
    return;
  this._value = value2;
  this._state = Resolved;
  this._drainQueue();
};
Cache.prototype.run = function Cache$run() {
  var _this = this;
  if (_this._state > Cold)
    return;
  _this._state = Pending;
  _this._cancel = _this.$1._interpret(
    function Cache$fork$rec(x) {
      _this.crash(x);
    },
    function Cache$fork$rej(x) {
      _this.reject(x);
    },
    function Cache$fork$res(x) {
      _this.resolve(x);
    }
  );
};
Cache.prototype.reset = function Cache$reset() {
  if (this._state === Cold)
    return;
  if (this._state === Pending)
    this._cancel();
  this._cancel = noop;
  this._queue = [];
  this._queued = 0;
  this._value = void 0;
  this._state = Cold;
};

// ../node_modules/fluture/src/chain-rej.js
var ChainRejTransformation = createTransformation(1, "chainRej", {
  rejected: function ChainRejTransformation$rejected(x) {
    return call(this.$1, x);
  }
});

// ../node_modules/fluture/src/chain.js
var monad = { pred: isChain, error: invalidArgumentOf("have Chain implemented") };

// ../node_modules/fluture/src/coalesce.js
var CoalesceTransformation = createTransformation(2, "coalesce", {
  rejected: function CoalesceTransformation$rejected(x) {
    return new Resolve(this.context, call(this.$1, x));
  },
  resolved: function CoalesceTransformation$resolved(x) {
    return new Resolve(this.context, call(this.$2, x));
  }
});

// ../node_modules/fluture/src/internal/timing.js
var Undetermined = 0;
var Synchronous = 1;
var Asynchronous = 2;

// ../node_modules/fluture/src/go.js
function invalidIteration(o) {
  return typeError(
    "The iterator did not return a valid iteration from iterator.next()\n  Actual: " + (0, import_sanctuary_show.default)(o)
  );
}
function invalidState(x) {
  return invalidFuture(
    "go() expects the value produced by the iterator",
    x,
    "\n  Tip: If you're using a generator, make sure you always yield a Future"
  );
}
var Go = createInterpreter(1, "go", function Go$interpret(rec, rej, res) {
  var _this = this, timing = Undetermined, cancel = noop, state, value2, iterator;
  function crash2(e) {
    rec(wrapException(e, _this));
  }
  try {
    iterator = _this.$1();
  } catch (e) {
    crash2(e);
    return noop;
  }
  if (!isIterator(iterator)) {
    crash2(invalidArgument("go", 0, 'return an iterator, maybe you forgot the "*"', iterator));
    return noop;
  }
  function resolved(x) {
    value2 = x;
    if (timing === Asynchronous)
      return drain();
    timing = Synchronous;
  }
  function drain() {
    while (true) {
      try {
        state = iterator.next(value2);
      } catch (e) {
        return crash2(e);
      }
      if (!isIteration(state))
        return crash2(invalidIteration(state));
      if (state.done)
        break;
      if (!isFuture(state.value)) {
        return crash2(invalidState(state.value));
      }
      timing = Undetermined;
      cancel = state.value._interpret(crash2, rej, resolved);
      if (timing === Undetermined)
        return timing = Asynchronous;
    }
    res(state.value);
  }
  drain();
  return function Go$cancel() {
    cancel();
  };
});

// ../node_modules/fluture/src/hook.js
function invalidDisposal(m, f, x) {
  return invalidFuture(
    "hook() expects the return value from the first function it's given",
    m,
    "\n  From calling: " + (0, import_sanctuary_show.default)(f) + "\n  With: " + (0, import_sanctuary_show.default)(x)
  );
}
function invalidConsumption(m, f, x) {
  return invalidFuture(
    "hook() expects the return value from the second function it's given",
    m,
    "\n  From calling: " + (0, import_sanctuary_show.default)(f) + "\n  With: " + (0, import_sanctuary_show.default)(x)
  );
}
var Hook = createInterpreter(3, "hook", function Hook$interpret(rec, rej, res) {
  var _this = this, _acquire = this.$1, _dispose = this.$2, _consume = this.$3;
  var cancel, cancelConsume = noop, resource, value2, cont = noop;
  function Hook$done() {
    cont(value2);
  }
  function Hook$rec(x) {
    rec(wrapException(x, _this));
  }
  function Hook$dispose() {
    var disposal;
    try {
      disposal = _dispose(resource);
    } catch (e) {
      return Hook$rec(e);
    }
    if (!isFuture(disposal)) {
      return Hook$rec(invalidDisposal(disposal, _dispose, resource));
    }
    cancel = Hook$cancelDisposal;
    disposal._interpret(Hook$rec, Hook$disposalRejected, Hook$done);
  }
  function Hook$cancelConsumption() {
    cancelConsume();
    Hook$dispose();
    Hook$cancelDisposal();
  }
  function Hook$cancelDisposal() {
    cont = noop;
  }
  function Hook$disposalRejected(x) {
    Hook$rec(new Error("The disposal Future rejected with " + (0, import_sanctuary_show.default)(x)));
  }
  function Hook$consumptionException(x) {
    cont = Hook$rec;
    value2 = x;
    Hook$dispose();
  }
  function Hook$consumptionRejected(x) {
    cont = rej;
    value2 = x;
    Hook$dispose();
  }
  function Hook$consumptionResolved(x) {
    cont = res;
    value2 = x;
    Hook$dispose();
  }
  function Hook$consume(x) {
    resource = x;
    var consumption;
    try {
      consumption = _consume(resource);
    } catch (e) {
      return Hook$consumptionException(e);
    }
    if (!isFuture(consumption)) {
      return Hook$consumptionException(invalidConsumption(consumption, _consume, resource));
    }
    cancel = Hook$cancelConsumption;
    cancelConsume = consumption._interpret(
      Hook$consumptionException,
      Hook$consumptionRejected,
      Hook$consumptionResolved
    );
  }
  var cancelAcquire = _acquire._interpret(Hook$rec, rej, Hook$consume);
  cancel = cancel || cancelAcquire;
  return function Hook$fork$cancel() {
    rec = raise;
    cancel();
  };
});

// ../node_modules/fluture/src/lastly.js
var LastlyTransformation = createTransformation(1, "lastly", {
  rejected: function LastlyAction$rejected(x) {
    return this.$1._transform(new AndTransformation(this.context, new Reject(this.context, x)));
  },
  resolved: function LastlyAction$resolved(x) {
    return this.$1._transform(new AndTransformation(this.context, new Resolve(this.context, x)));
  }
});

// ../node_modules/fluture/src/map-rej.js
var MapRejTransformation = createTransformation(1, "mapRej", {
  rejected: function MapRejTransformation$rejected(x) {
    return new Reject(this.context, call(this.$1, x));
  }
});
function mapRej(f) {
  var context1 = application1(mapRej, func, arguments);
  return function mapRej2(m) {
    var context2 = application(2, mapRej2, future, arguments, context1);
    return m._transform(new MapRejTransformation(context2, f));
  };
}

// ../node_modules/fluture/src/map.js
var functor = { pred: isFunctor, error: invalidArgumentOf("have Functor implemented") };
function map(f) {
  var context1 = application1(map, func, arguments);
  return function map2(m) {
    var context2 = application(2, map2, functor, arguments, context1);
    return isFuture(m) ? m._transform(new MapTransformation(context2, f)) : m[FL.map](f);
  };
}

// ../node_modules/fluture/src/node.js
var Node = createInterpreter(1, "node", function Node$interpret(rec, rej, res) {
  function Node$done(err, val) {
    cont = err ? function EncaseN3$rej() {
      open = false;
      rej(err);
    } : function EncaseN3$res() {
      open = false;
      res(val);
    };
    if (open) {
      cont();
    }
  }
  var open = false, cont = function() {
    open = true;
  };
  try {
    call(this.$1, Node$done);
  } catch (e) {
    rec(wrapException(e, this));
    open = false;
    return noop;
  }
  cont();
  return function Node$cancel() {
    open = false;
  };
});

// ../node_modules/fluture/src/pap.js
var ParallelApTransformation = createParallelTransformation("pap", earlyCrash, earlyReject, noop, {
  resolved: function ParallelApTransformation$resolved(f) {
    if (isFunction(f))
      return this.$1._transform(new MapTransformation(this.context, f));
    throw typeError(
      "pap expects the second Future to resolve to a Function\n  Actual: " + (0, import_sanctuary_show.default)(f)
    );
  }
});

// ../node_modules/fluture/src/parallel.js
function isFutureArray(xs) {
  if (!isArray(xs))
    return false;
  for (var i = 0; i < xs.length; i++) {
    if (!isFuture(xs[i]))
      return false;
  }
  return true;
}
var futureArray = {
  pred: isFutureArray,
  error: invalidArgumentOf("be an Array of valid Futures")
};
var Parallel = createInterpreter(2, "parallel", function Parallel$interpret(rec, rej, res) {
  var _this = this, futures = this.$2, length = futures.length;
  var max = Math.min(this.$1, length), cancels = new Array(length), out = new Array(length);
  var cursor = 0, running = 0, blocked = false, cont = noop;
  function Parallel$cancel() {
    rec = noop;
    rej = noop;
    res = noop;
    cursor = length;
    for (var n = 0; n < length; n++)
      cancels[n] && cancels[n]();
  }
  function Parallel$run(idx) {
    running++;
    cancels[idx] = futures[idx]._interpret(function Parallel$rec(e) {
      cont = rec;
      cancels[idx] = noop;
      Parallel$cancel();
      cont(wrapException(e, _this));
    }, function Parallel$rej(reason) {
      cont = rej;
      cancels[idx] = noop;
      Parallel$cancel();
      cont(reason);
    }, function Parallel$res(value2) {
      cancels[idx] = noop;
      out[idx] = value2;
      running--;
      if (cursor === length && running === 0)
        res(out);
      else if (blocked)
        Parallel$drain();
    });
  }
  function Parallel$drain() {
    blocked = false;
    while (cursor < length && running < max)
      Parallel$run(cursor++);
    blocked = true;
  }
  Parallel$drain();
  return Parallel$cancel;
});
var emptyArray = resolve([]);

// ../node_modules/fluture/src/par.js
var import_sanctuary_type_identifiers3 = __toESM(require_sanctuary_type_identifiers(), 1);

// ../node_modules/fluture/src/race.js
var RaceTransformation = createParallelTransformation("race", earlyCrash, earlyReject, earlyResolve, {});

// ../node_modules/fluture/src/par.js
function ConcurrentFuture(sequential) {
  this.sequential = sequential;
}
ConcurrentFuture.prototype = Object.create(Par.prototype);
function Par(sequential) {
  if (!isFuture(sequential))
    throw invalidFutureArgument(Par.name, 0, sequential);
  return new ConcurrentFuture(sequential);
}
var $$type2 = namespace + "/ConcurrentFuture@" + version;
var zeroInstance = new ConcurrentFuture(never);
Par["@@type"] = $$type2;
Par.constructor = { prototype: Par };
Par[FL.of] = function Par$of(x) {
  return new ConcurrentFuture(resolve(x));
};
Par[FL.zero] = function Par$zero() {
  return zeroInstance;
};
Par.prototype["@@type"] = $$type2;
Par.prototype["@@show"] = function Par$show() {
  return this.toString();
};
Par.prototype.toString = function Par$toString() {
  return "Par (" + this.sequential.toString() + ")";
};
Par.prototype[FL.map] = function Par$FL$map(f) {
  var context = captureContext(
    nil,
    "a Fantasy Land dispatch to map via ConcurrentFuture",
    Par$FL$map
  );
  return new ConcurrentFuture(this.sequential._transform(new MapTransformation(context, f)));
};
Par.prototype[FL.ap] = function Par$FL$ap(other) {
  var context = captureContext(
    nil,
    "a Fantasy Land dispatch to ap via ConcurrentFuture",
    Par$FL$ap
  );
  return new ConcurrentFuture(other.sequential._transform(
    new ParallelApTransformation(context, this.sequential)
  ));
};
Par.prototype[FL.alt] = function Par$FL$alt(other) {
  var context = captureContext(
    nil,
    "a Fantasy Land dispatch to alt via ConcurrentFuture",
    Par$FL$alt
  );
  return new ConcurrentFuture(other.sequential._transform(
    new RaceTransformation(context, this.sequential)
  ));
};
function isParallel(x) {
  return x instanceof ConcurrentFuture || (0, import_sanctuary_type_identifiers3.default)(x) === $$type2;
}

// ../node_modules/fluture/src/promise.js
function promise(m) {
  application1(promise, future, arguments);
  return new Promise(function promise$computation(res, rej) {
    m._interpret(rej, rej, res);
  });
}

// ../node_modules/fluture/src/reject-after.js
var RejectAfter = createInterpreter(2, "rejectAfter", function RejectAfter$interpret(rec, rej) {
  var id = setTimeout(rej, this.$1, this.$2);
  return function RejectAfter$cancel() {
    clearTimeout(id);
  };
});
RejectAfter.prototype.extractLeft = function RejectAfter$extractLeft() {
  return [this.$2];
};

// ../node_modules/fluture/src/seq.js
var parallel = { pred: isParallel, error: invalidArgumentOf("be a ConcurrentFuture") };

// ../node_modules/fluture/src/swap.js
var SwapTransformation = createTransformation(0, "swap", {
  resolved: function SwapTransformation$resolved(x) {
    return new Reject(this.context, x);
  },
  rejected: function SwapTransformation$rejected(x) {
    return new Resolve(this.context, x);
  }
});

// ../taqueria-protocol/TaqError.ts
var E_TaqError = class extends Error {
  constructor(taqErr) {
    super(taqErr.msg);
    this.context = taqErr.context;
    this.kind = taqErr.kind;
    this.name = this.kind;
    this.previous = taqErr.previous;
  }
};
var toFutureParseErr = (previous, msg, context) => reject(toParseErr(previous, msg, context)).pipe(map((val) => val));
var toParseErr = (previous, msg, context) => create({
  kind: "E_PARSE",
  msg,
  context,
  previous
});
var toParseUnknownErr = (previous, msg, context) => create({
  kind: "E_PARSE_UNKNOWN",
  msg,
  context,
  previous
});
var toFutureParseUnknownErr = (previous, msg, context) => reject(toParseUnknownErr(previous, msg, context)).pipe(map((val) => val));
var create = (err) => err;

// ../node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  function assertEqual(_cond) {
  }
  util2.assertEqual = assertEqual;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
})(util || (util = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error3) => {
      for (const issue of error3.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error3 = new ZodError(issues);
  return error3;
};
var defaultErrorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be greater than ${issue.inclusive ? `or equal to ` : ``}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be greater than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.minimum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be less than ${issue.inclusive ? `or equal to ` : ``}${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be smaller than ${issue.inclusive ? `or equal to ` : ``}${new Date(issue.maximum)}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = defaultErrorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      defaultErrorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value2 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value2.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value2.status === "dirty")
        status.dirty();
      if (typeof value2.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value2.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value2) => ({ status: "dirty", value: value2 });
var OK = (value2) => ({ status: "valid", value: value2 });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;
var jsonStringifyReplacer = (_23, value2) => {
  if (typeof value2 === "bigint") {
    return value2.toString();
  }
  return value2;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value2, path2, key) {
    this.parent = parent;
    this.data = value2;
    this._path = path2;
    this._key = key;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error3 = new ZodError(ctx.common.issues);
    return { success: false, error: error3 };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this.superRefine = this._refinement;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.default = this.default.bind(this);
    this.describe = this.describe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  optional() {
    return ZodOptional.create(this);
  }
  nullable() {
    return ZodNullable.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this);
  }
  or(option) {
    return ZodUnion.create([this, option]);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming);
  }
  transform(transform) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  startsWith(value2, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value2, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value2,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value2, message) {
    return this.setLimit("min", value2, true, errorUtil.toString(message));
  }
  gt(value2, message) {
    return this.setLimit("min", value2, false, errorUtil.toString(message));
  }
  lte(value2, message) {
    return this.setLimit("max", value2, true, errorUtil.toString(message));
  }
  lt(value2, message) {
    return this.setLimit("max", value2, false, errorUtil.toString(message));
  }
  setLimit(kind, value2, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value2,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value2, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value2,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(ctx.data.map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = ctx.data.map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return this.min(len, message).max(len, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var AugmentFactory = (def) => (augmentation) => {
  return new ZodObject({
    ...def,
    shape: () => ({
      ...def.shape(),
      ...augmentation
    })
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = AugmentFactory(this._def);
    this.extend = AugmentFactory(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    for (const key in ctx.data) {
      if (!shapeKeys.includes(key)) {
        extraKeys.push(key);
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value2 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value2 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value2, ctx.path, key)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).map((key) => {
      if (this.shape[key])
        shape[key] = this.shape[key];
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).map((key) => {
      if (util.objectKeys(mask).indexOf(key) === -1) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    if (mask) {
      util.objectKeys(this.shape).map((key) => {
        if (util.objectKeys(mask).indexOf(key) === -1) {
          newShape[key] = this.shape[key];
        } else {
          newShape[key] = this.shape[key].optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    } else {
      for (const key in this.shape) {
        const fieldSchema = this.shape[key];
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required() {
    const newShape = {};
    for (const key in this.shape) {
      const fieldSchema = this.shape[key];
      let newField = fieldSchema;
      while (newField instanceof ZodOptional) {
        newField = newField._def.innerType;
      }
      newShape[key] = newField;
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.options.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: this.validDiscriminatorValues,
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(discriminator, types, params) {
    const options = /* @__PURE__ */ new Map();
    try {
      types.forEach((type4) => {
        const discriminatorValue = type4.shape[discriminator].value;
        options.set(discriminatorValue, type4);
      });
    } catch (e) {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (options.size !== types.length) {
      throw new Error("Some of the discriminator values are not unique");
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        type: "array"
      });
      status.dirty();
    }
    const items = ctx.data.map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas42, params) => {
  return new ZodTuple({
    items: schemas42,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value2], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          if (key.status === "aborted" || value2.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value2.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value2.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value2 = pair.value;
        if (key.status === "aborted" || value2.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value2.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value2.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error3) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          defaultErrorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error3
        }
      });
    }
    function makeReturnsIssue(returns, error3) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          defaultErrorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error3
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error3 = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
          error3.addIssue(makeArgsIssue(args, e));
          throw error3;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error3.addIssue(makeReturnsIssue(result, e));
          throw error3;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
};
ZodFunction.create = (args, returns, params) => {
  return new ZodFunction({
    args: args ? args.rest(ZodUnknown.create()) : ZodTuple.create([]).rest(ZodUnknown.create()),
    returns: returns || ZodUnknown.create(),
    typeName: ZodFirstPartyTypeKind.ZodFunction,
    ...processCreateParams(params)
  });
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value2, params) => {
  return new ZodLiteral({
    value: value2,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type4, params) => {
  return new ZodOptional({
    innerType: type4,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type4, params) => {
  return new ZodNullable({
    innerType: type4,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type4, params) => {
  return new ZodOptional({
    innerType: type4,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : params;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params, true);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var mod = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getParsedType,
  ZodParsedType,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  jsonStringifyReplacer,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  get objectUtil() {
    return objectUtil;
  },
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodNaN,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  ZodIssueCode,
  quotelessJson,
  ZodError,
  defaultErrorMap,
  setErrorMap,
  getErrorMap
});

// ../taqueria-protocol/Base.ts
var createSchema = (params) => {
  const { rawSchema: rawSchema41, isStringLike } = params;
  const internalSchema27 = params.internalSchema ?? params.rawSchema;
  const noop3 = (val) => val;
  const transformer = params.transformer ?? noop3;
  const schema = isStringLike ? internalSchema27.transform(
    (val) => transformer(val)
  ) : internalSchema27.transform(
    (val) => transformer(val)
  );
  return {
    rawSchema: rawSchema41,
    internalSchema: internalSchema27,
    schema
  };
};
var createType = (params) => {
  const schemas42 = createSchema(params);
  const { parseErrMsg, unknownErrMsg } = params;
  const internalOf = (input) => {
    try {
      return resolve(schemas42.schema.parse(input));
    } catch (previous) {
      const parseMsg = typeof parseErrMsg === "string" ? parseErrMsg : parseErrMsg(input);
      const unknownMsg = typeof unknownErrMsg === "string" ? unknownErrMsg : unknownErrMsg(input);
      if (previous instanceof ZodError) {
        return toFutureParseErr(previous, parseMsg, input);
      }
      return toFutureParseUnknownErr(previous, unknownMsg, input);
    }
  };
  const of40 = internalOf;
  const make40 = (input) => internalOf(input);
  const create41 = (input) => schemas42.schema.parse(input);
  const from3 = (input) => schemas42.schema.parse(input);
  const factory41 = {
    make: make40,
    of: of40,
    create: create41,
    from: from3
  };
  return {
    schemas: schemas42,
    factory: factory41
  };
};
var Base_default = createType;

// ../taqueria-protocol/Environment.ts
var rawSchema = mod.object({
  networks: mod.array(
    mod.string({ description: "Environment network" }).min(1, "Must reference the name of an existing network configuration")
  ),
  sandboxes: mod.array(
    mod.string({ description: "Environment sandbox" }).min(1, "Must reference the name of an existing sandbox configuration")
  ),
  storage: mod.record(
    mod.any({ description: "Environment storage value" }),
    { description: "Environment storage" }
  ).optional()
}).describe("Environment Config");
var { schemas: generatedSchemas, factory } = Base_default({
  rawSchema,
  parseErrMsg: (value2) => `${value2} is not an valid environment configuration`,
  unknownErrMsg: "Something went wrong trying to parse the environment configuration"
});
var { create: create2, make, of, from } = factory;
var schemas = {
  ...generatedSchemas,
  schema: generatedSchemas.schema.transform((val) => val)
};

// ../taqueria-protocol/LoadedConfig.ts
var LoadedConfig_exports = {};
__export(LoadedConfig_exports, {
  create: () => create18,
  factory: () => factory17,
  generatedSchemas: () => generatedSchemas17,
  internalSchema: () => internalSchema9,
  make: () => make17,
  of: () => of17,
  rawSchema: () => rawSchema17,
  schemas: () => schemas17,
  toConfig: () => toConfig
});

// ../taqueria-protocol/Config.ts
var Config_exports = {};
__export(Config_exports, {
  create: () => create16,
  factory: () => factory15,
  generatedSchemas: () => generatedSchemas15,
  internalSchema: () => internalSchema8,
  make: () => make15,
  of: () => of15,
  pluginsInternalSchema: () => pluginsInternalSchema,
  pluginsRawSchema: () => pluginsRawSchema,
  rawSchema: () => rawSchema15,
  schemas: () => schemas15
});

// ../taqueria-protocol/SHA256.ts
var SHA256_exports = {};
__export(SHA256_exports, {
  create: () => create3,
  internalSchema: () => internalSchema,
  make: () => make2,
  of: () => of2,
  rawSchema: () => rawSchema2,
  schemas: () => schemas2,
  toSHA256: () => toSHA256
});
var import_webcrypto = __toESM(require_webcrypto());
import { TextEncoder } from "util";
var eager = (f) => promise(
  mapRej((err) => new E_TaqError(err))(f)
);
var rawSchema2 = mod.string({ description: "SHA256" }).length(64);
var { schemas: generatedSchemas2, factory: factory2 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema2,
  parseErrMsg: (value2) => `${value2} is an invalid SHA256 hash`,
  unknownErrMsg: (value2) => `Something went wrong trying to parse the following as a SHA256 value, ${value2}`
});
var toSHA256 = async (value2) => {
  const encoder = new TextEncoder();
  const data = encoder.encode(value2);
  const crypto = new import_webcrypto.Crypto();
  const hash = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hash));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return eager(factory2.make(hashHex));
};
var internalSchema = generatedSchemas2.schema;
var { create: create3, of: of2, make: make2 } = factory2;
var schemas2 = {
  ...generatedSchemas2,
  schema: generatedSchemas2.schema.transform((val) => val)
};

// ../taqueria-protocol/Contract.ts
var rawSchema3 = mod.object({
  sourceFile: mod.string().min(1),
  hash: rawSchema2
});
var internalSchema2 = mod.object({
  sourceFile: mod.string().min(1),
  hash: schemas2.schema
});
var { schemas: generatedSchemas3, factory: factory3 } = Base_default({
  rawSchema: rawSchema3,
  internalSchema: internalSchema2,
  parseErrMsg: (value2) => `${value2} is not a valid contract`,
  unknownErrMsg: "Something went wrong trying to parse a contract"
});
var { create: create4, of: of3, make: make3 } = factory3;
var schemas3 = {
  ...generatedSchemas3,
  schema: generatedSchemas3.schema.transform((val) => val)
};

// ../taqueria-protocol/InstalledPlugin.ts
var InstalledPlugin_exports = {};
__export(InstalledPlugin_exports, {
  create: () => create5,
  factory: () => factory4,
  generatedSchemas: () => generatedSchemas4,
  make: () => make4,
  of: () => of4,
  rawSchema: () => rawSchema4,
  schemas: () => schemas4
});
var rawSchema4 = mod.object({
  name: mod.string({ description: "Plugin Name" }).min(1),
  type: mod.union(
    [mod.literal("npm"), mod.literal("binary"), mod.literal("deno")],
    { description: "Plugin Type" }
  )
}).describe("InstalledPlugin");
var { schemas: generatedSchemas4, factory: factory4 } = Base_default({
  rawSchema: rawSchema4,
  parseErrMsg: (value2) => `${value2} is not a valid installed plugin`,
  unknownErrMsg: "Something went wrong when parsing the installed plugin"
});
var { create: create5, of: of4, make: make4 } = factory4;
var schemas4 = {
  ...generatedSchemas4,
  schema: generatedSchemas4.schema.transform((val) => val)
};

// ../taqueria-protocol/NetworkConfig.ts
var NetworkConfig_exports = {};
__export(NetworkConfig_exports, {
  create: () => create11,
  factory: () => factory10,
  generatedSchemas: () => generatedSchemas10,
  make: () => make10,
  of: () => of10,
  rawSchema: () => rawSchema10,
  schemas: () => schemas10
});

// ../taqueria-protocol/EconomicalProtocolHash.ts
var EconomicalProtocolHash_exports = {};
__export(EconomicalProtocolHash_exports, {
  create: () => create6,
  factory: () => factory5,
  generatedSchemas: () => generatedSchemas5,
  make: () => make5,
  of: () => of5,
  rawSchema: () => rawSchema5,
  schemas: () => schemas5
});
var rawSchema5 = mod.string({ description: "Protocol hash" }).refine(
  (value2) => value2.length === 51 && value2[0] === "P" && /[A-Za-z0-9]+/.test(value2),
  (value2) => ({ message: `${value2} is an invalid hash for an economical protocol` })
);
var { schemas: generatedSchemas5, factory: factory5 } = Base_default({
  rawSchema: rawSchema5,
  parseErrMsg: (value2) => `${value2} is an invalid economical protocol hash`,
  unknownErrMsg: "Somethign went wrong trying to parse the economical protocol hash"
});
var { create: create6, of: of5, make: make5 } = factory5;
var schemas5 = {
  ...generatedSchemas5,
  schema: generatedSchemas5.schema.transform((val) => val)
};

// ../taqueria-protocol/PublicKeyHash.ts
var rawSchema6 = mod.string({ description: "Public Key Hash" }).min(1).refine(
  (val) => val.startsWith("tz1"),
  (val) => ({ message: `${val} is not a valid public key hash` })
);
var { schemas: generatedSchemas6, factory: factory6 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema6,
  parseErrMsg: (value2) => `${value2} is an invalid public key hash`,
  unknownErrMsg: "Something went wrong parsing the public key hash"
});
var { create: create7, of: of6, make: make6 } = factory6;
var schemas6 = {
  ...generatedSchemas6,
  schema: generatedSchemas6.schema.transform((val) => val)
};

// ../taqueria-protocol/Faucet.ts
var rawSchema7 = mod.object({
  pkh: mod.string({ description: "Faucet Public Key Hash" }).min(1),
  mnemonic: mod.array(
    mod.string({ description: "Faucet Mnemonic Word" }).min(1),
    { description: "Faucet Mnemonic" }
  ),
  email: mod.string({ description: "Faucet E-mail" }).regex(/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/),
  password: mod.string({ description: "Faucet Password" }).min(1),
  amount: mod.string({ description: "Faucet Account" }).min(1).regex(/^\d+$/),
  activation_code: mod.string({ description: "Faucet Activation Code" }).min(1)
}).describe("Faucet");
var internalSchema3 = mod.object({
  pkh: schemas6.schema,
  mnemonic: mod.array(
    mod.string({ description: "Faucet Mnemonic Word" }).nonempty().regex(/^[a-z]{2,}$/),
    { description: "Faucet Mnemonic" }
  ),
  email: mod.string({ description: "Faucet E-mail" }).regex(/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/),
  password: mod.string({ description: "Faucet Password" }).nonempty(),
  amount: mod.string({ description: "Faucet Account" }).nonempty().regex(/^\d+$/),
  activation_code: mod.string({ description: "Faucet Activation Code" }).nonempty()
}).describe("Faucet");
var { schemas: generatedSchemas7, factory: factory7 } = Base_default({
  rawSchema: rawSchema7,
  internalSchema: internalSchema3,
  parseErrMsg: (value2) => `${value2} is not a valid faucet configuration`,
  unknownErrMsg: "Something went wrong trying to parse the faucet"
});
var { create: create8, of: of7, make: make7 } = factory7;
var schemas7 = {
  ...generatedSchemas7,
  schema: generatedSchemas7.schema.transform((val) => val)
};

// ../taqueria-protocol/HumanReadableIdentifier.ts
var HumanReadableIdentifier_exports = {};
__export(HumanReadableIdentifier_exports, {
  create: () => create9,
  internalSchema: () => internalSchema4,
  make: () => make8,
  of: () => of8,
  rawSchema: () => rawSchema8,
  schemas: () => schemas8
});
var rawSchema8 = mod.string({ description: "Human Readable Identifier" }).regex(/^[A-Za-z]+[A-Za-z0-9-_ ]*$/, "Must be a valid human-readable identifier");
var { schemas: generatedSchemas8, factory: factory8 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema8,
  parseErrMsg: (value2) => `${value2} is not a valid human-readable identifier`,
  unknownErrMsg: "Something went wrong trying to parse the human readable identifier"
});
var internalSchema4 = generatedSchemas8.schema;
var { create: create9, of: of8, make: make8 } = factory8;
var schemas8 = {
  ...generatedSchemas8,
  schema: generatedSchemas8.schema.transform((val) => val)
};

// ../taqueria-protocol/Url.ts
var Url_exports = {};
__export(Url_exports, {
  create: () => create10,
  factory: () => factory9,
  generatedSchemas: () => generatedSchemas9,
  make: () => make9,
  of: () => of9,
  rawSchema: () => rawSchema9,
  schemas: () => schemas9,
  toComponents: () => toComponents
});
var rawSchema9 = mod.string({ description: "Url" }).url();
var { schemas: generatedSchemas9, factory: factory9 } = Base_default({
  rawSchema: rawSchema9,
  isStringLike: true,
  parseErrMsg: (value2) => `${value2} is an invalid url`,
  unknownErrMsg: "Something went wrong trying to parse the url"
});
var toComponents = (url) => {
  const parts = new URL(url.toString());
  return parts;
};
var { create: create10, of: of9, make: make9 } = factory9;
var schemas9 = {
  ...generatedSchemas9,
  schema: generatedSchemas9.schema.transform((val) => val)
};

// ../taqueria-protocol/NetworkConfig.ts
var rawSchema10 = mod.object({
  label: rawSchema8,
  rpcUrl: rawSchema9,
  protocol: rawSchema5,
  faucet: rawSchema7.describe("Network Faucet")
}).describe("Network Config");
var internalSchema5 = mod.object({
  label: schemas8.schema.describe("Network Label"),
  rpcUrl: schemas9.schema.describe("Network RPC Url"),
  protocol: schemas5.schema.describe("Network Protocol Hash"),
  faucet: schemas7.schema.describe("Network Faucet")
}).describe("Network Config");
var { schemas: generatedSchemas10, factory: factory10 } = Base_default({
  rawSchema: rawSchema10,
  internalSchema: internalSchema5,
  parseErrMsg: (value2) => `${value2} is not a valid network configuration`,
  unknownErrMsg: "Something went wrong trying to parse the network configuration"
});
var { create: create11, of: of10, make: make10 } = factory10;
var schemas10 = {
  ...generatedSchemas10,
  schema: generatedSchemas10.schema.transform((val) => val)
};

// ../taqueria-protocol/SandboxConfig.ts
var SandboxConfig_exports = {};
__export(SandboxConfig_exports, {
  create: () => create14,
  factory: () => factory13,
  generatedSchemas: () => generatedSchemas13,
  make: () => make13,
  of: () => of13,
  rawSchema: () => rawSchema13,
  schemas: () => schemas13
});

// ../taqueria-protocol/SandboxAccountConfig.ts
var SandboxAccountConfig_exports = {};
__export(SandboxAccountConfig_exports, {
  create: () => create12,
  factory: () => factory11,
  generatedSchemas: () => generatedSchemas11,
  make: () => make11,
  of: () => of11,
  rawSchema: () => rawSchema11,
  schemas: () => schemas11
});
var internalSchema6 = mod.object({
  encryptedKey: mod.string({ description: "Sandbox Account Encrypted Key" }).min(1),
  publicKeyHash: schemas6.schema.describe("Sandbox Account Public Key Hash"),
  secretKey: mod.string({ description: "Sandbox Account Secret Key" }).min(1)
}, { description: "Sandbox Account Configuration" });
var rawSchema11 = mod.object({
  encryptedKey: mod.string({ description: "Sandbox Account Encrypted Key" }).min(1),
  publicKeyHash: mod.string({ description: "Sandbox Account Public Key Hash" }).min(1),
  secretKey: mod.string({ description: "Sandbox Account Secret Key" }).min(1)
}, { description: "Sandbox Account Configuration" });
var { schemas: generatedSchemas11, factory: factory11 } = Base_default({
  rawSchema: rawSchema11,
  internalSchema: internalSchema6,
  parseErrMsg: "The sandbox account configuration is invalid",
  unknownErrMsg: "Something went wrong trying to parse the sandbox account configuration"
});
var { create: create12, of: of11, make: make11 } = factory11;
var schemas11 = {
  ...generatedSchemas11,
  schema: generatedSchemas11.schema.transform((val) => val)
};

// ../taqueria-protocol/Verb.ts
var Verb_exports = {};
__export(Verb_exports, {
  create: () => create13,
  factory: () => factory12,
  generatedSchemas: () => generatedSchemas12,
  make: () => make12,
  of: () => of12,
  rawSchema: () => rawSchema12,
  schemas: () => schemas12
});
var rawSchema12 = mod.string({ description: "Verb" }).min(1, "Must be a valid verb").regex(/^[A-Za-z\-\ ]+/, "Must be a valid verb");
var { factory: factory12, schemas: generatedSchemas12 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema12,
  parseErrMsg: (value2) => `${value2} is not an invalid verb`,
  unknownErrMsg: `Something went wrong trying to parse a verb`
});
var { create: create13, make: make12, of: of12 } = factory12;
var schemas12 = {
  ...generatedSchemas12,
  schema: generatedSchemas12.schema.transform((val) => val)
};

// ../taqueria-protocol/SandboxConfig.ts
var accountMapSchema = mod.record(
  mod.union([
    mod.string().nonempty(),
    schemas11.schema
  ])
);
var rawSchema13 = mod.object({
  label: mod.string({ description: "Sandbox Label" }).min(1),
  rpcUrl: mod.string({ description: "Sandbox RPC Url" }).min(5).url(),
  protocol: mod.string({ description: "Sandbox Protocol Hash" }).min(8),
  attributes: mod.record(
    mod.union(
      [mod.string(), mod.number(), mod.boolean()],
      { description: "Sandbox Attribute" }
    ),
    { description: "Sandbox Attributes" }
  ).optional(),
  plugin: rawSchema12.describe("Sandbox Plugin").optional(),
  accounts: mod.union([
    mod.object({ default: mod.string().min(1) }),
    mod.record(rawSchema11)
  ], { description: "Sandbox Accounts" }).optional()
});
var internalSchema7 = mod.object({
  label: schemas8.schema.describe("Sandbox Label"),
  rpcUrl: schemas9.schema.describe("Sandbox RPC Url"),
  protocol: schemas5.schema.describe("Sandbox Protocol Hash"),
  attributes: mod.record(
    mod.union([mod.string(), mod.number(), mod.boolean()]),
    { description: "Sandbox Attributes" }
  ).optional(),
  plugin: schemas12.schema.describe("Sandbox Plugin").optional(),
  accounts: accountMapSchema.optional()
}, { description: "Sandbox Configuration" });
var { schemas: generatedSchemas13, factory: factory13 } = Base_default({
  rawSchema: rawSchema13,
  internalSchema: internalSchema7,
  parseErrMsg: (value2) => `${value2} is not a valid sandbox configuration `,
  unknownErrMsg: "Something went wrong trying to parse the sandbox configuration"
});
var { create: create14, of: of13, make: make13 } = factory13;
var schemas13 = {
  ...generatedSchemas13,
  schema: generatedSchemas13.schema.transform((val) => val)
};

// ../taqueria-protocol/Tz.ts
var rawSchema14 = mod.string({ description: "Tz" }).min(1).regex(/^\d([\d_]+\d)?$/);
var { schemas: generatedSchemas14, factory: factory14 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema14,
  parseErrMsg: (value2) => `${value2} is an invalid Tz amount`,
  unknownErrMsg: "Something went wrong when parsing the Tz amount"
});
var { create: create15, of: of14, make: make14 } = factory14;
var schemas14 = {
  ...generatedSchemas14,
  schema: generatedSchemas14.schema.transform((val) => val)
};

// ../taqueria-protocol/Config.ts
var pluginsRawSchema = mod.preprocess(
  (val) => val ?? [],
  mod.array(
    rawSchema4,
    { description: "config.plugins" }
  )
);
var pluginsInternalSchema = mod.preprocess(
  (val) => val ?? [],
  mod.array(
    schemas4.schema,
    { description: "config.plugins" }
  )
);
var networkMap = mod.record(
  mod.union([
    schemas10.schema,
    mod.string({ description: "config.network" }).nonempty("Default network must reference the name of an  existing network configuration.")
  ]),
  { description: "Network configurations" }
).optional();
var sandboxMap = mod.record(
  mod.union([
    schemas13.schema,
    mod.string({ description: "config.sandbox" }).min(1, "Default sandbox must reference the name of an existing sandbox configuration.")
  ]),
  { description: "Sandbox configurations" }
).optional();
var environmentMap = mod.record(
  mod.union([
    schemas.schema,
    mod.string().min(1, "Default environment must reference the name of an existing environment.")
  ]),
  { description: "Environment configurations" }
).optional();
var accountsMap = mod.preprocess(
  (val) => val ?? {
    "bob": "5_000_000_000",
    "alice": "5_000_000_000",
    "john": "5_000_000_000"
  },
  mod.record(
    mod.union([rawSchema14, mod.number()]),
    { description: "config.accounts" }
  )
);
var commonSchema = mod.object({
  language: mod.preprocess(
    (val) => val ?? "en",
    mod.union([
      mod.literal("en"),
      mod.literal("fr")
    ], { description: "config.language" }).optional()
  ),
  plugins: pluginsInternalSchema.optional(),
  contractsDir: mod.preprocess(
    (val) => val ?? "contracts",
    mod.string({ description: "config.contractsDir" }).min(1, "config.contractsDir must have a value")
  ),
  artifactsDir: mod.preprocess(
    (val) => val ?? "artifacts",
    mod.string({ description: "config.artifactsDir" }).min(1, "config.artifactsDir must have a value")
  ),
  contracts: mod.record(
    rawSchema3
  ).optional()
}).describe("config");
var internalSchema8 = commonSchema.extend({
  network: networkMap,
  sandbox: sandboxMap,
  environment: environmentMap,
  accounts: accountsMap,
  contracts: mod.record(schemas3.schema).optional()
});
var rawSchema15 = commonSchema.extend({
  plugins: pluginsRawSchema.optional(),
  network: mod.record(
    mod.union([
      rawSchema10,
      mod.string({ description: "config.network" }).min(1, "Default network must reference the name of an  existing network configuration.")
    ])
  ).optional(),
  sandbox: mod.record(
    mod.union([
      rawSchema13,
      mod.string({ description: "config.sandbox" }).min(1, "Default sandbox must reference the name of an existing sandbox configuration.")
    ])
  ).optional(),
  environment: mod.record(
    mod.union([
      rawSchema,
      mod.string({ description: "config.environment" }).min(1, "Default environment must reference the name of an existing environment.")
    ])
  ).optional(),
  accounts: mod.record(
    mod.union([rawSchema14, mod.number()]),
    { description: "config.accounts" }
  ).optional()
}).describe("config");
var { schemas: generatedSchemas15, factory: factory15 } = Base_default({
  rawSchema: rawSchema15,
  internalSchema: internalSchema8,
  parseErrMsg: (value2) => `${value2} is not a configuration`,
  unknownErrMsg: "Something went wrong trying to parse your configuration"
});
var { create: create16, of: of15, make: make15 } = factory15;
var schemas15 = {
  ...generatedSchemas15,
  schema: generatedSchemas15.schema.transform((val) => val)
};

// ../taqueria-protocol/SanitizedAbsPath.ts
var SanitizedAbsPath_exports = {};
__export(SanitizedAbsPath_exports, {
  create: () => create17,
  factory: () => factory16,
  generatedSchemas: () => generatedSchemas16,
  make: () => make16,
  of: () => of16,
  rawSchema: () => rawSchema16,
  schemas: () => schemas16
});
import * as path from "path";
var rawSchema16 = mod.string({ description: "SanitizedAbsPath" }).min(1);
var { schemas: generatedSchemas16, factory: factory16 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema16,
  transformer: (value2) => path.resolve(value2),
  parseErrMsg: (value2) => `${value2} is an invalid absolute path`,
  unknownErrMsg: (value2) => `Something went wrong trying to parse the absolute path, ${value2}`
});
var { create: create17, make: make16, of: of16 } = factory16;
var schemas16 = {
  ...generatedSchemas16,
  schema: generatedSchemas16.schema.transform((val) => val)
};

// ../taqueria-protocol/LoadedConfig.ts
var rawSchema17 = rawSchema15.omit({ plugins: true }).extend({
  plugins: pluginsRawSchema,
  projectDir: rawSchema16.describe("loadedConfig.projectDir"),
  configFile: rawSchema16.describe("loadedConfig.configFile"),
  hash: rawSchema2.describe("loadedConfig.hash")
}).describe("LoadedConfig");
var internalSchema9 = internalSchema8.omit({ plugins: true }).extend({
  plugins: pluginsInternalSchema,
  projectDir: schemas16.schema.describe("loadedConfig.projectDir"),
  configFile: schemas16.schema.describe("loadedConfig.configFile"),
  hash: schemas2.schema.describe("loadedConfig.hash")
}).describe("LoadedConfig");
var { schemas: generatedSchemas17, factory: factory17 } = Base_default({
  rawSchema: rawSchema17,
  internalSchema: internalSchema9,
  parseErrMsg: (value2) => `The following configuration is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the configuration to load"
});
var { create: create18, of: of17, make: make17 } = factory17;
var schemas17 = {
  ...generatedSchemas17,
  schema: generatedSchemas17.schema.transform((val) => val)
};
var toConfig = (config) => make15(config);

// ../taqueria-protocol/Operation.ts
var Operation_exports = {};
__export(Operation_exports, {
  create: () => create27,
  factory: () => factory26,
  generatedSchemas: () => generatedSchemas26,
  internalSchema: () => internalSchema15,
  make: () => make26,
  of: () => of26,
  rawSchema: () => rawSchema26,
  schemas: () => schemas26
});

// ../taqueria-protocol/Command.ts
var rawSchema18 = mod.string({ description: "Command" }).min(1).regex(/^([A-Za-z-_ ]+ ?)((\[.+\] ?)|(\<.+\>) ?)*$/, "Must be a command that can be interpreted using yargs");
var { schemas: generatedSchemas18, factory: factory18 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema18,
  parseErrMsg: (value2) => `${value2} is an invalid command. Expected format is: taskName [optional] <required>`,
  unknownErrMsg: "Something went wrong when parsing the command"
});
var internalSchema10 = generatedSchemas18.schema;
var { create: create19, make: make18, of: of18 } = factory18;
var schemas18 = {
  ...generatedSchemas18,
  schema: generatedSchemas18.schema.transform((val) => val)
};

// ../taqueria-protocol/Option.ts
var Option_exports = {};
__export(Option_exports, {
  create: () => create21,
  factory: () => factory20,
  generatedSchemas: () => generatedSchemas20,
  internalSchema: () => internalSchema11,
  make: () => make20,
  of: () => of20,
  rawSchema: () => rawSchema20,
  schemas: () => schemas20
});

// ../taqueria-protocol/SingleChar.ts
var rawSchema19 = mod.string({ description: "Single character" }).regex(/^[A-Za-z]$/, "Must be a single character");
var { factory: factory19, schemas: generatedSchemas19 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema19,
  parseErrMsg: (value2) => `${value2} is not a single character`,
  unknownErrMsg: `Something went wrong trying to parse a single character`
});
var { create: create20, of: of19, make: make19 } = factory19;
var schemas19 = {
  ...generatedSchemas19,
  schema: generatedSchemas19.schema.transform((val) => val)
};

// ../taqueria-protocol/Option.ts
var internalSchema11 = mod.object({
  shortFlag: schemas19.schema.describe("Option Short Flag").optional(),
  flag: schemas12.schema.describe("Option Long Flag"),
  description: mod.string({ description: "Option Description" }).min(1),
  defaultValue: mod.union(
    [mod.string(), mod.number(), mod.boolean()],
    { description: "Option Default Value" }
  ).optional(),
  choices: mod.array(
    mod.string({ description: "Option Choice" }),
    { description: "Option Choices" }
  ).optional(),
  required: mod.boolean({ description: "Option Is Required" }).default(false).optional(),
  boolean: mod.boolean({ description: "Option Is Boolean" }).default(false).optional(),
  type: mod.union(
    [mod.literal("string"), mod.literal("number"), mod.literal("boolean")],
    { description: "Positional Arg Datatype" }
  ).optional()
}).describe("Option");
var rawSchema20 = mod.object({
  shortFlag: rawSchema19.describe("Option Short Flag").optional(),
  flag: rawSchema12.describe("Option Long Flag"),
  description: mod.string({ description: "Option Description" }).min(1),
  defaultValue: mod.union(
    [mod.string(), mod.number(), mod.boolean()],
    { description: "Option Default Value" }
  ).optional(),
  choices: mod.array(
    mod.string({ description: "Option Choice" }),
    { description: "Option Choices" }
  ).optional(),
  required: mod.boolean({ description: "Option Is Required" }).default(false).optional(),
  boolean: mod.boolean({ description: "Option Is Boolean" }).default(false).optional(),
  type: mod.union(
    [mod.literal("string"), mod.literal("number"), mod.literal("boolean")],
    { description: "Positional Arg Datatype" }
  ).optional()
}).describe("Option");
var { schemas: generatedSchemas20, factory: factory20 } = Base_default({
  rawSchema: rawSchema20,
  internalSchema: internalSchema11,
  parseErrMsg: (value2) => `The following option is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the option"
});
var { make: make20, create: create21, of: of20 } = factory20;
var schemas20 = {
  ...generatedSchemas20,
  schema: generatedSchemas20.schema.transform((val) => val)
};

// ../taqueria-protocol/PersistentState.ts
var PersistentState_exports = {};
__export(PersistentState_exports, {
  create: () => create23,
  factory: () => factory22,
  generatedSchemas: () => generatedSchemas22,
  internalSchema: () => internalSchema12,
  make: () => make22,
  of: () => of22,
  rawSchema: () => rawSchema22,
  schemas: () => schemas22
});

// ../taqueria-protocol/Timestamp.ts
var rawSchema21 = mod.number({ description: "Timestamp" }).min(1651846877);
var { factory: factory21, schemas: generatedSchemas21 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema21,
  parseErrMsg: (value2) => `${value2} is an invalid timestamp`,
  unknownErrMsg: `Something went wrong trying to parse a timestamp`
});
var { create: create22, make: make21, of: of21 } = factory21;
var schemas21 = {
  ...generatedSchemas21,
  schema: generatedSchemas21.schema.transform((val) => val)
};

// ../taqueria-protocol/PersistentState.ts
var rawOpSchema = mod.object({
  hash: rawSchema2.describe("state.op.hash"),
  time: rawSchema21.describe("state.op.time"),
  output: mod.unknown().describe("state.op.output")
}).describe("Persistent State Operation");
var rawTaskSchema = mod.object({
  task: schemas12.rawSchema,
  plugin: mod.string().min(1),
  time: rawSchema21.describe("state.task.time"),
  output: mod.unknown().describe("state.task.output")
});
var internalOpSchema = mod.object({
  hash: schemas2.schema.describe("state.op.hash"),
  time: schemas21.schema.describe("state.op.time"),
  output: mod.unknown().describe("state.op.output")
});
var internalTaskSchema = mod.object({
  task: schemas12.schema,
  plugin: mod.string().min(1),
  time: schemas21.schema.describe("state.task.time"),
  output: mod.unknown().describe("state.op.output")
});
var rawSchema22 = mod.object({
  operations: mod.record(rawOpSchema),
  tasks: mod.record(rawTaskSchema)
});
var internalSchema12 = mod.object({
  operations: mod.record(internalOpSchema),
  tasks: mod.record(internalTaskSchema)
}).transform((val) => ({
  operations: val.operations,
  tasks: val.tasks
}));
var { schemas: generatedSchemas22, factory: factory22 } = Base_default({
  rawSchema: rawSchema22,
  parseErrMsg: `The persistent state is invalid`,
  unknownErrMsg: `Something went wrong trying to parse the persistent state`
});
var { create: create23, of: of22, make: make22 } = factory22;
var schemas22 = {
  ...generatedSchemas22,
  schema: generatedSchemas22.schema.transform((val) => val)
};

// ../taqueria-protocol/PositionalArg.ts
var PositionalArg_exports = {};
__export(PositionalArg_exports, {
  create: () => create24,
  factory: () => factory23,
  generatedSchemas: () => generatedSchemas23,
  make: () => make23,
  of: () => of23,
  rawSchema: () => rawSchema23,
  schemas: () => schemas23
});
var rawSchema23 = mod.object({
  placeholder: rawSchema8.describe("Positional Arg Placeholder"),
  description: mod.string({ description: "Positional Arg Description" }).min(1),
  defaultValue: mod.union(
    [mod.string(), mod.number(), mod.boolean()],
    { description: "Positional Arg Default Value" }
  ).optional(),
  type: mod.union(
    [mod.literal("string"), mod.literal("number"), mod.literal("boolean")],
    { description: "Positional Arg Datatype" }
  ).optional(),
  required: mod.boolean().optional()
}).describe("Positional Arg");
var internalSchema13 = rawSchema23.extend({
  placeholder: schemas8.schema.describe("Positional Arg Placeholder")
}).describe("Positional Arg");
var { schemas: generatedSchemas23, factory: factory23 } = Base_default({
  rawSchema: rawSchema23,
  internalSchema: internalSchema13,
  parseErrMsg: (value2) => `The following positional argument is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong parsing the positional argument"
});
var { create: create24, of: of23, make: make23 } = factory23;
var schemas23 = {
  ...generatedSchemas23,
  schema: generatedSchemas23.schema.transform((val) => val)
};

// ../taqueria-protocol/RequestArgs.ts
var RequestArgs_exports = {};
__export(RequestArgs_exports, {
  create: () => create26,
  createProxyRequestArgs: () => createProxyRequestArgs,
  createProxyTemplateRequestArgs: () => createProxyTemplateRequestArgs,
  factory: () => factory25,
  from: () => from2,
  generatedSchemas: () => generatedSchemas25,
  make: () => make25,
  makeProxyRequestArgs: () => makeProxyRequestArgs,
  makeProxyTemplateRequestArgs: () => makeProxyTemplateRequestArgs,
  of: () => of25,
  ofProxyRequestArgs: () => ofProxyRequestArgs,
  ofProxyTemplateRequestArgs: () => ofProxyTemplateRequestArgs,
  proxy: () => proxy,
  proxyFactory: () => proxyFactory,
  proxySchemas: () => proxySchemas,
  proxyTemplate: () => proxyTemplate,
  schemas: () => schemas25
});

// ../taqueria-protocol/SanitizedArgs.ts
var SanitizedArgs_exports = {};
__export(SanitizedArgs_exports, {
  addContractArgs: () => addContractArgs,
  addContractsRawSchema: () => addContractsRawSchema,
  create: () => create25,
  createAddContractArgs: () => createAddContractArgs,
  createCreateTaskArgs: () => createCreateTaskArgs,
  createInstallTaskArgs: () => createInstallTaskArgs,
  createProvisionTaskArgs: () => createProvisionTaskArgs,
  createRemoveContractsArgs: () => createRemoveContractsArgs,
  createScaffoldTaskArgs: () => createScaffoldTaskArgs,
  createTaskArgs: () => createTaskArgs,
  createUninstallTaskArgs: () => createUninstallTaskArgs,
  factory: () => factory24,
  generatedSchemas: () => generatedSchemas24,
  installTaskArgs: () => installTaskArgs,
  make: () => make24,
  makeAddContractArgs: () => makeAddContractArgs,
  makeCreateTaskArgs: () => makeCreateTaskArgs,
  makeInstallTaskArgs: () => makeInstallTaskArgs,
  makeProvisionTaskArgs: () => makeProvisionTaskArgs,
  makeRemoveContractsArgs: () => makeRemoveContractsArgs,
  makeScaffoldTaskArgs: () => makeScaffoldTaskArgs,
  makeUninstallTaskArgs: () => makeUninstallTaskArgs,
  managePluginRawSchema: () => managePluginRawSchema,
  of: () => of24,
  ofAddContractArgs: () => ofAddContractArgs,
  ofCreateTaskArgs: () => ofCreateTaskArgs,
  ofInstallTaskArgs: () => ofInstallTaskArgs,
  ofProvisionTaskArgs: () => ofProvisionTaskArgs,
  ofRemoveContractsArgs: () => ofRemoveContractsArgs,
  ofScaffoldTaskArgs: () => ofScaffoldTaskArgs,
  ofUninstallTaskArgs: () => ofUninstallTaskArgs,
  provisionRawSchema: () => provisionRawSchema,
  provisionTaskArgs: () => provisionTaskArgs,
  rawSchema: () => rawSchema24,
  removeContractsArgs: () => removeContractsArgs,
  removeContractsRawSchema: () => removeContractsRawSchema,
  scaffoldRawSchema: () => scaffoldRawSchema,
  scaffoldTaskArgs: () => scaffoldTaskArgs,
  schemas: () => schemas24,
  templateRawSchema: () => templateRawSchema,
  uninstallTaskArgs: () => uninstallTaskArgs,
  versionRawSchema: () => versionRawSchema
});
var rawSchema24 = mod.object({
  _: mod.array(mod.union([mod.string().min(1), mod.number()])),
  projectDir: schemas16.schema,
  maxConcurrency: mod.preprocess(
    (val) => typeof val === "string" ? parseInt(val) : Number(val),
    mod.number().int().min(1).default(10)
  ),
  debug: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().default(false)
  ),
  disableState: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().default(false)
  ),
  logPluginRequests: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().default(false)
  ),
  fromVsCode: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().default(false)
  ),
  version: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().optional()
  ),
  build: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().optional()
  ),
  help: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().optional()
  ),
  yes: mod.preprocess(
    (val) => Boolean(val),
    mod.boolean().optional()
  ),
  plugin: mod.string().min(1).optional(),
  env: mod.union([mod.literal("production"), mod.literal("testing"), mod.literal("development"), mod.string().nonempty()]).default("development"),
  quickstart: mod.string().min(1).optional(),
  setBuild: mod.preprocess(
    (val) => String(val),
    mod.string().min(3)
  ),
  setVersion: mod.string().min(3),
  pluginName: mod.string().min(1).optional()
}, { description: "Sanitizied Args" }).passthrough();
var scaffoldRawSchema = rawSchema24.extend({
  scaffoldProjectDir: mod.string().min(1).transform((val) => val),
  scaffoldUrl: mod.string().min(1).url().transform((val) => val)
});
var provisionRawSchema = rawSchema24.extend({
  operation: mod.string().min(1).describe("Operation name"),
  name: mod.string().min(1).regex(
    /^[a-z0-9]+[a-z0-9-_]$/,
    "Provisioner name must consist of one or more letters/numbers and may not start with an underscore or dash."
  ).describe("Provisioner name").optional()
}).passthrough();
var templateRawSchema = rawSchema24.extend({
  template: mod.string().min(1)
}).passthrough();
var managePluginRawSchema = rawSchema24.omit({ pluginName: true }).extend({
  pluginName: mod.string().min(1)
});
var versionRawSchema = rawSchema24.extend({
  version: mod.boolean().default(true)
});
var addContractsRawSchema = mod.preprocess(
  (val) => {
    const obj = typeof val === "object" ? Object(val) : { contractName: "", sourceFile: "" };
    return !obj.contractName && obj.sourceFile ? { ...obj, contractName: obj["sourceFile"] } : obj;
  },
  rawSchema24.extend({
    sourceFile: mod.string().min(1),
    contractName: mod.string().min(1)
  })
);
var removeContractsRawSchema = rawSchema24.extend({
  contractName: mod.string().min(1)
});
var { schemas: generatedSchemas24, factory: factory24 } = Base_default({
  rawSchema: rawSchema24,
  parseErrMsg: "The arguments provided are invalid",
  unknownErrMsg: "Something went wrong parsing the command-line arguments"
});
var { create: create25, of: of24, make: make24 } = factory24;
var schemas24 = {
  ...generatedSchemas24,
  schema: generatedSchemas24.schema.transform((val) => val)
};
var scaffoldTaskArgs = Base_default({
  rawSchema: scaffoldRawSchema,
  parseErrMsg: "The arguments provided are invalid for the scaffold task",
  unknownErrMsg: "Something went wrong parsing the arguments for the scaffold task"
});
var provisionTaskArgs = Base_default({
  rawSchema: provisionRawSchema,
  parseErrMsg: "The arguments provided are invalid for the provision task",
  unknownErrMsg: "Something went wrong parsing the arguments for the provision task"
});
var installTaskArgs = Base_default({
  rawSchema: managePluginRawSchema,
  parseErrMsg: "The arguments provided are invalid for the install task",
  unknownErrMsg: "Something went wrong parsing the arguments for the install task"
});
var uninstallTaskArgs = Base_default({
  rawSchema: managePluginRawSchema,
  parseErrMsg: "The arguments provided are invalid for the uninstall task",
  unknownErrMsg: "Something went wrong parsing the arguments for the uninstall task"
});
var createTaskArgs = Base_default({
  rawSchema: templateRawSchema,
  parseErrMsg: "The arguments provided are invalid for the create task",
  unknownErrMsg: "Something went wrong parsing the arguments for the create task"
});
var addContractArgs = Base_default({
  rawSchema: addContractsRawSchema,
  parseErrMsg: "Please specify the source file to register.",
  unknownErrMsg: "Something went wrong parsing the arguments for registering a contract."
});
var removeContractsArgs = Base_default({
  rawSchema: removeContractsRawSchema,
  parseErrMsg: "Please specify the contract name to unregister.",
  unknownErrMsg: "Something went wrong parsing the arguments to unregister a contract."
});
var createScaffoldTaskArgs = scaffoldTaskArgs.factory.from;
var makeScaffoldTaskArgs = scaffoldTaskArgs.factory.make;
var ofScaffoldTaskArgs = scaffoldTaskArgs.factory.of;
var createProvisionTaskArgs = provisionTaskArgs.factory.create;
var makeProvisionTaskArgs = provisionTaskArgs.factory.make;
var ofProvisionTaskArgs = provisionTaskArgs.factory.of;
var createInstallTaskArgs = installTaskArgs.factory.create;
var makeInstallTaskArgs = installTaskArgs.factory.make;
var ofInstallTaskArgs = installTaskArgs.factory.of;
var createUninstallTaskArgs = uninstallTaskArgs.factory.create;
var makeUninstallTaskArgs = uninstallTaskArgs.factory.make;
var ofUninstallTaskArgs = uninstallTaskArgs.factory.of;
var createCreateTaskArgs = createTaskArgs.factory.create;
var makeCreateTaskArgs = createTaskArgs.factory.make;
var ofCreateTaskArgs = createTaskArgs.factory.of;
var createAddContractArgs = addContractArgs.factory.create;
var makeAddContractArgs = addContractArgs.factory.make;
var ofAddContractArgs = addContractArgs.factory.of;
var createRemoveContractsArgs = removeContractsArgs.factory.create;
var makeRemoveContractsArgs = removeContractsArgs.factory.make;
var ofRemoveContractsArgs = removeContractsArgs.factory.of;

// ../taqueria-protocol/RequestArgs.ts
var taqRunSchema = mod.union([
  mod.literal("pluginInfo"),
  mod.literal("proxy"),
  mod.literal("checkRuntimeDependencies"),
  mod.literal("installRuntimeDependencies"),
  mod.literal("proxyTemplate")
]);
var rawSchema25 = rawSchema24.extend({
  taqRun: taqRunSchema,
  config: mod.preprocess(
    (val) => typeof val === "string" ? JSON.parse(val) : val,
    rawSchema17
  )
}).describe("RequestArgs").passthrough();
var internalSchema14 = rawSchema24.extend({
  taqRun: taqRunSchema,
  config: mod.preprocess(
    (val) => typeof val === "string" ? JSON.parse(val) : val,
    schemas17.schema
  )
}).describe("RequestArgs").passthrough();
var { schemas: generatedSchemas25, factory: factory25 } = Base_default({
  rawSchema: rawSchema25,
  internalSchema: internalSchema14,
  parseErrMsg: "The request is invalid",
  unknownErrMsg: "Something went wrong trying to parse the request"
});
var schemas25 = {
  ...generatedSchemas25,
  schema: generatedSchemas25.schema.transform((val) => val)
};
var rawProxyTaskSchema = rawSchema25.extend({
  task: mod.string().min(1)
}).describe("ProxyRequestArgs").passthrough();
var internalProxyTaskSchema = internalSchema14.extend({
  task: mod.string().min(1)
}).describe("ProxyRequestArgs").passthrough();
var rawProxyTemplateSchema = rawSchema25.extend({
  template: mod.string().min(1)
});
var internalProxyTemplateSchema = rawSchema25.extend({
  template: mod.string().min(1)
});
var proxy = Base_default({
  rawSchema: rawProxyTaskSchema,
  internalSchema: internalProxyTaskSchema,
  parseErrMsg: "The request is invalid",
  unknownErrMsg: "Something went wrong trying to parse the request"
});
var proxyTemplate = Base_default({
  rawSchema: rawProxyTemplateSchema,
  internalSchema: internalProxyTemplateSchema,
  parseErrMsg: "The request is invalid",
  unknownErrMsg: "Something went wrong trying to parse the request"
});
var proxySchemas = proxy.schemas;
var proxyFactory = proxy.factory;
var createProxyRequestArgs = proxyFactory.from;
var makeProxyRequestArgs = proxyFactory.make;
var ofProxyRequestArgs = proxyFactory.of;
var createProxyTemplateRequestArgs = proxyTemplate.factory.from;
var makeProxyTemplateRequestArgs = proxyTemplate.factory.make;
var ofProxyTemplateRequestArgs = proxyTemplate.factory.of;
var { create: create26, make: make25, of: of25, from: from2 } = factory25;

// ../taqueria-protocol/Operation.ts
var rawSchema26 = mod.object({
  operation: rawSchema12.describe("Operation Name"),
  command: rawSchema18.describe("Operation Command"),
  description: mod.string({ description: "Operation Description" }).optional(),
  positionals: mod.array(rawSchema23).default([]).describe("Operation Positional Args").optional(),
  options: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      rawSchema20.describe("Operation Option"),
      { description: "Operation Options" }
    ).optional()
  ),
  handler: mod.function().args(rawSchema22).returns(
    mod.function().args(schemas25.internalSchema)
  ).describe("Operation Handler").transform((val) => val)
}).describe("Operation");
var internalSchema15 = mod.object({
  operation: schemas12.schema.describe("Operation Name"),
  command: schemas18.schema.describe("Operation Command"),
  description: mod.string({ description: "Optionation Description" }).optional(),
  positionals: mod.array(schemas23.schema).default([]).describe("Operation Positional Args").optional(),
  options: mod.preprocess(
    (val) => val ?? [],
    mod.array(schemas20.schema.describe("Operation Option"), { description: "Operation Options" }).optional()
  ),
  handler: mod.function().args(rawSchema22).returns(
    mod.function().args(schemas25.schema)
  ).describe("Operation Handler").transform((val) => val)
}).describe("Operation");
var { schemas: generatedSchemas26, factory: factory26 } = Base_default({
  rawSchema: rawSchema26,
  internalSchema: internalSchema15,
  parseErrMsg: (value2) => `The following operation is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the operation"
});
var { make: make26, of: of26, create: create27 } = factory26;
var schemas26 = {
  ...generatedSchemas26,
  schema: generatedSchemas26.schema.transform((val) => val)
};

// ../taqueria-protocol/PluginSchema.ts
var PluginSchema_exports = {};
__export(PluginSchema_exports, {
  create: () => create38,
  factory: () => factory38,
  generatedSchemas: () => generatedSchemas33,
  make: () => make37,
  of: () => of37,
  rawSchema: () => rawSchema37,
  schemas: () => schemas38
});

// ../taqueria-protocol/Alias.ts
var Alias_exports = {};
__export(Alias_exports, {
  create: () => create28,
  internalSchema: () => internalSchema16,
  make: () => make27,
  of: () => of27,
  rawSchema: () => rawSchema27,
  schemas: () => schemas27
});
var rawSchema27 = mod.union([
  rawSchema12,
  rawSchema19
], { description: "Alias" });
var internalSchema16 = mod.union([
  schemas12.schema,
  schemas19.schema
], { description: "Alias" });
var { schemas: generatedSchemas27, factory: factory27 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema27,
  internalSchema: internalSchema16,
  parseErrMsg: (value2) => `${value2} is not a valid alias`,
  unknownErrMsg: "Something went wrong trying to parse an alias"
});
var { create: create28, of: of27, make: make27 } = factory27;
var schemas27 = {
  ...generatedSchemas27,
  schema: generatedSchemas27.schema.transform((val) => val)
};

// ../taqueria-protocol/PluginDependenciesResponse.ts
var rawRuntimeDependency = mod.object({
  name: mod.string(),
  path: mod.string(),
  version: mod.string(),
  kind: mod.union([mod.literal("required"), mod.literal("optional")])
});
var { schemas: schemas28, factory: factory28 } = Base_default({
  rawSchema: rawRuntimeDependency,
  internalSchema: rawRuntimeDependency,
  parseErrMsg: (value2) => `The following runtime dependency is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the template"
});
var runtimeDependencyReport = rawRuntimeDependency.extend({ met: mod.boolean() });
var dependenciesResponseSchema = mod.object({
  report: mod.array(runtimeDependencyReport)
});
var { of: of28, make: make28, create: create29 } = factory28;

// ../taqueria-protocol/PluginInfo.ts
var PluginInfo_exports = {};
__export(PluginInfo_exports, {
  create: () => create36,
  factory: () => factory36,
  internalSchema: () => internalSchema22,
  make: () => make35,
  of: () => of35,
  rawSchema: () => rawSchema35,
  schemas: () => schemas36
});

// ../taqueria-protocol/ParsedOperation.ts
var ParsedOperation_exports = {};
__export(ParsedOperation_exports, {
  create: () => create30,
  factory: () => factory29,
  generatedSchemas: () => generatedSchemas28,
  make: () => make29,
  of: () => of29,
  rawSchema: () => rawSchema28,
  schemas: () => schemas29
});
var internalSchema17 = internalSchema15.describe("ParsedOperation").omit({ handler: true });
var rawSchema28 = rawSchema26.omit({ handler: true }).describe("ParsedOperation");
var { schemas: generatedSchemas28, factory: factory29 } = Base_default({
  rawSchema: rawSchema28,
  internalSchema: internalSchema17,
  parseErrMsg: (value2) => `Could not parse the following operation: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse an operation"
});
var { create: create30, make: make29, of: of29 } = factory29;
var schemas29 = {
  ...generatedSchemas28,
  schema: generatedSchemas28.schema.transform((val) => val)
};

// ../taqueria-protocol/ParsedTemplate.ts
var ParsedTemplate_exports = {};
__export(ParsedTemplate_exports, {
  create: () => create33,
  factory: () => factory33,
  generatedSchemas: () => generatedSchemas30,
  make: () => make32,
  of: () => of32,
  rawSchema: () => rawSchema32,
  schemas: () => schemas33
});

// ../taqueria-protocol/PluginResponseEncoding.ts
var PluginResponseEncoding_exports = {};
__export(PluginResponseEncoding_exports, {
  create: () => create31,
  factory: () => factory30,
  make: () => make30,
  of: () => of30,
  rawSchema: () => rawSchema29,
  schemas: () => schemas30
});
var rawSchema29 = mod.preprocess(
  (val) => val ?? "none",
  mod.union([
    mod.literal("json"),
    mod.literal("application/json"),
    mod.literal("none")
  ]).default("none").optional()
);
var { schemas: schemas30, factory: factory30 } = Base_default({
  rawSchema: rawSchema29,
  internalSchema: rawSchema29,
  parseErrMsg: (value2) => `The following encoding is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the encoding"
});
var { create: create31, of: of30, make: make30 } = factory30;

// ../taqueria-protocol/Template.ts
var Template_exports = {};
__export(Template_exports, {
  create: () => create32,
  factory: () => factory32,
  generatedSchemas: () => generatedSchemas29,
  internalSchema: () => internalSchema18,
  make: () => make31,
  of: () => of31,
  rawSchema: () => rawSchema31,
  schemas: () => schemas32
});

// ../taqueria-protocol/PluginJsonResponse.ts
var PluginJsonResponse_exports = {};
__export(PluginJsonResponse_exports, {
  factory: () => factory31,
  pluginJsonResponse: () => pluginJsonResponse,
  rawSchema: () => rawSchema30,
  schemas: () => schemas31
});
var rawSchema30 = mod.object({
  data: mod.unknown().optional(),
  render: mod.union([
    mod.literal("none"),
    mod.literal("table"),
    mod.literal("string")
  ]).optional()
});
var pluginJsonResponse = Base_default({
  rawSchema: rawSchema30,
  internalSchema: rawSchema30,
  parseErrMsg: (value2) => `The following JSON response is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the template"
});
var { schemas: schemas31, factory: factory31 } = pluginJsonResponse;

// ../taqueria-protocol/Template.ts
var handlerSchema = mod.union([
  mod.string().min(1),
  mod.function().args(schemas25.schema).returns(mod.union([
    mod.void(),
    schemas31.schema,
    schemas31.internalSchema,
    mod.promise(
      mod.union([
        mod.promise(mod.void()),
        mod.void(),
        schemas31.schema,
        schemas31.internalSchema
      ])
    )
  ]))
]);
var rawSchema31 = mod.object({
  template: rawSchema12,
  command: rawSchema18,
  description: mod.string().min(4),
  hidden: mod.preprocess(
    (val) => val ?? false,
    mod.boolean()
  ).optional(),
  options: mod.preprocess(
    (val) => val ?? [],
    mod.array(rawSchema20)
  ).optional(),
  positionals: mod.preprocess(
    (val) => val ?? [],
    mod.array(rawSchema23)
  ).optional(),
  handler: handlerSchema.describe("Template Handler"),
  encoding: schemas30.schema.optional()
});
var internalSchema18 = rawSchema31.extend({
  template: schemas12.schema,
  command: schemas18.schema,
  options: mod.preprocess(
    (val) => val ?? [],
    mod.array(schemas20.schema)
  ).optional(),
  positionals: mod.preprocess(
    (val) => val ?? [],
    mod.array(schemas23.schema)
  ).optional()
});
var { schemas: generatedSchemas29, factory: factory32 } = Base_default({
  rawSchema: rawSchema31,
  internalSchema: internalSchema18,
  parseErrMsg: (value2) => `The following template is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the template"
});
var { create: create32, make: make31, of: of31 } = factory32;
var schemas32 = {
  ...generatedSchemas29,
  schema: generatedSchemas29.schema.transform((val) => val)
};

// ../taqueria-protocol/ParsedTemplate.ts
var internalSchema19 = internalSchema18.extend({
  handler: mod.string(),
  encoding: schemas30.schema
}).describe("ParsedTemplate");
var rawSchema32 = rawSchema31.extend({
  handler: mod.string(),
  encoding: schemas30.schema
}).describe("ParsedTemplate");
var { schemas: generatedSchemas30, factory: factory33 } = Base_default({
  rawSchema: rawSchema32,
  internalSchema: internalSchema19,
  parseErrMsg: (value2) => `Could not parse the following template: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse an template"
});
var { create: create33, make: make32, of: of32 } = factory33;
var schemas33 = {
  ...generatedSchemas30,
  schema: generatedSchemas30.schema.transform((val) => val)
};

// ../taqueria-protocol/Task.ts
var Task_exports = {};
__export(Task_exports, {
  create: () => create34,
  factory: () => factory34,
  generatedSchemas: () => generatedSchemas31,
  make: () => make33,
  of: () => of33,
  rawSchema: () => rawSchema33,
  schemas: () => schemas34
});
var taskHandlerSchema = mod.union([
  mod.literal("proxy"),
  mod.string().min(1)
]);
var rawSchema33 = mod.object({
  task: rawSchema12.describe("Task Name"),
  command: rawSchema18.describe("Task Command"),
  aliases: mod.array(rawSchema27).default([]).describe("Task Aliases").optional(),
  description: mod.string({ description: "Task Description" }).min(3),
  example: mod.string({ description: "Task Example" }).optional(),
  hidden: mod.boolean({ description: "Task Is Hidden" }).default(false).optional(),
  encoding: rawSchema29.optional(),
  handler: taskHandlerSchema.describe("Task Handler"),
  options: mod.array(rawSchema20).default([]).describe("Task Options").optional(),
  positionals: mod.array(rawSchema23).default([]).describe("Task Positional Args").optional()
}).describe("Task");
var internalSchema20 = rawSchema33.extend({
  task: schemas12.schema.describe("Task Name"),
  command: schemas18.schema.describe("Task Command"),
  aliases: mod.array(schemas27.schema).default([]).describe("Task Aliases").optional(),
  encoding: schemas30.schema.optional(),
  handler: taskHandlerSchema.describe("Task Handler"),
  options: mod.preprocess(
    (val) => val ?? [],
    mod.array(schemas20.schema).describe("Task Options").optional()
  ),
  positionals: mod.array(schemas23.schema).default([]).describe("Task Positional Args").optional()
}).describe("Task");
var { schemas: generatedSchemas31, factory: factory34 } = Base_default({
  rawSchema: rawSchema33,
  internalSchema: internalSchema20,
  parseErrMsg: (value2) => `The following task is invalid: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the task"
});
var { create: create34, make: make33, of: of33 } = factory34;
var schemas34 = {
  ...generatedSchemas31,
  schema: generatedSchemas31.schema.transform((val) => val)
};

// ../taqueria-protocol/VersionNumber.ts
var VersionNumber_exports = {};
__export(VersionNumber_exports, {
  create: () => create35,
  internalSchema: () => internalSchema21,
  make: () => make34,
  of: () => of34,
  rawSchema: () => rawSchema34,
  schemas: () => schemas35
});
var rawSchema34 = mod.string({ description: "Version Number" }).min(1).regex(/^\d+\.\d+(\.\d+)*$/);
var { schemas: generatedSchemas32, factory: factory35 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema34,
  parseErrMsg: (value2) => `${value2} is an invalid version number`,
  unknownErrMsg: "Something went wrong trying to parse the version number"
});
var internalSchema21 = generatedSchemas32.schema;
var { create: create35, of: of34, make: make34 } = factory35;
var schemas35 = {
  ...generatedSchemas32,
  schema: generatedSchemas32.schema.transform((val) => val)
};

// ../taqueria-protocol/PluginInfo.ts
var rawSchema35 = mod.object({
  name: mod.string({ description: "Plugin Name" }).min(1),
  version: rawSchema34.describe("Plugin Version #"),
  schema: rawSchema34.describe("Plugin Schema Version #"),
  alias: rawSchema27.describe("Plugin Alias"),
  tasks: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas34.schema.describe("Plugin Task"),
      { description: "Plugin Tasks" }
    )
  ).optional(),
  operations: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas29.schema.describe("Plugin Operation"),
      { description: "Plugin Operations" }
    )
  ).optional(),
  templates: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas33.schema.describe("Plugin Template")
    )
  ).optional()
});
var internalSchema22 = rawSchema35.extend({
  version: schemas35.schema.describe("Plugin Version #"),
  schema: schemas35.schema.describe("Plugin Schema Version #"),
  alias: schemas27.schema.describe("Plugin Alias"),
  tasks: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas34.schema.describe("Plugin Task"),
      { description: "Plugin Tasks" }
    )
  ).optional(),
  operations: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas29.schema.describe("Plugin Operation"),
      { description: "Plugin Operations" }
    )
  ).optional(),
  templates: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas33.schema.describe("Plugin Template")
    )
  ).optional()
}).describe("Plugin Schema");
var { schemas: schemas36, factory: factory36 } = Base_default({
  rawSchema: rawSchema35,
  internalSchema: internalSchema22,
  parseErrMsg: "The schema returned from the plugin is invalid",
  unknownErrMsg: "Something went wrong parsing the schema from a plugin"
});
var { create: create36, of: of35, make: make35 } = factory36;

// ../taqueria-protocol/PluginProxyResponse.ts
var internalSchema23 = mod.union([
  schemas31.internalSchema,
  mod.void()
]);
var rawSchema36 = internalSchema23;
var { schemas: schemas37, factory: factory37 } = Base_default({
  rawSchema: rawSchema36,
  internalSchema: internalSchema23,
  parseErrMsg: "The response from the proxy request is invalid",
  unknownErrMsg: "Something went wrong parsing the proxy response from the plugin"
});
var { of: of36, make: make36, create: create37 } = factory37;

// ../taqueria-protocol/PluginSchema.ts
var proxyFnSchema = mod.function().args(proxySchemas.schema).returns(mod.promise(schemas37.schema));
var runtimeDependenciesFn = mod.function().args(schemas25.schema).returns(mod.promise(schemas28.schema));
var internalSchema24 = internalSchema22.extend({
  operations: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas26.schema,
      { description: "ParsedOperations" }
    ).optional()
  ),
  templates: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas32.schema
    ).optional()
  ),
  proxy: proxyFnSchema.optional(),
  checkRuntimeDependencies: runtimeDependenciesFn.optional(),
  installRuntimeDependencies: runtimeDependenciesFn.optional()
}).describe("ParsedPluginInfo");
var rawSchema37 = rawSchema35.extend({
  name: rawSchema27.optional(),
  operations: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      rawSchema26,
      { description: "ParsedOperation" }
    )
  ).optional(),
  templates: mod.preprocess(
    (val) => val ?? [],
    mod.array(
      schemas32.schema
    ).optional()
  ),
  proxy: proxyFnSchema.optional(),
  checkRuntimeDependencies: runtimeDependenciesFn.optional(),
  installRuntimeDependencies: runtimeDependenciesFn.optional()
}).describe("ParsedPluginInfo");
var { schemas: generatedSchemas33, factory: factory38 } = Base_default({
  rawSchema: rawSchema37,
  internalSchema: internalSchema24,
  parseErrMsg: (value2) => `The following plugin info gave us trouble when parsing the following plugin information: ${value2}`,
  unknownErrMsg: "Something went wrong trying to parse the plugin information"
});
var { create: create38, of: of37, make: make37 } = factory38;
var schemas38 = {
  ...generatedSchemas33,
  schema: generatedSchemas33.schema.transform((val) => val)
};

// ../taqueria-protocol/SanitizedPath.ts
var SanitizedPath_exports = {};
__export(SanitizedPath_exports, {
  create: () => create39,
  internalSchema: () => internalSchema25,
  make: () => make38,
  of: () => of38,
  rawSchema: () => rawSchema38,
  schemas: () => schemas39
});
var rawSchema38 = mod.string({ description: "Sanitized Path" }).transform((value2) => {
  const result = value2.match(/^(\.\.|\.\/|\/)/);
  return result ? value2 : `./${value2}`;
});
var { schemas: generatedSchemas34, factory: factory39 } = Base_default({
  isStringLike: true,
  rawSchema: rawSchema38,
  parseErrMsg: (value2) => `${value2} is an invalid filesystem path`,
  unknownErrMsg: (value2) => `Something went wrong trying to parse the filesystem path, ${value2}`
});
var internalSchema25 = generatedSchemas34.schema;
var { create: create39, of: of38, make: make38 } = factory39;
var schemas39 = {
  ...generatedSchemas34,
  schema: generatedSchemas34.schema.transform((val) => val)
};

// ../taqueria-protocol/taqueria-protocol-types.ts
var taqueria_protocol_types_exports = {};
__export(taqueria_protocol_types_exports, {
  Alias: () => Alias_exports,
  Config: () => Config_exports,
  EconomicalProtocolHash: () => EconomicalProtocolHash_exports,
  Environment: () => Environment_exports,
  EphemeralState: () => EphemeralState_exports,
  HumanReadableIdentifier: () => HumanReadableIdentifier_exports,
  InstalledPlugin: () => InstalledPlugin_exports,
  LoadedConfig: () => LoadedConfig_exports,
  NetworkConfig: () => NetworkConfig_exports,
  Operation: () => Operation_exports,
  Option: () => Option_exports,
  ParsedOperation: () => ParsedOperation_exports,
  ParsedTemplate: () => ParsedTemplate_exports,
  PersistentState: () => PersistentState_exports,
  PluginActionName: () => PluginActionName_exports,
  PluginInfo: () => PluginInfo_exports,
  PluginJsonResponse: () => PluginJsonResponse_exports,
  PluginResponseEncoding: () => PluginResponseEncoding_exports,
  PluginSchema: () => PluginSchema_exports,
  PositionalArg: () => PositionalArg_exports,
  RequestArgs: () => RequestArgs_exports,
  SHA256: () => SHA256_exports,
  SandboxAccountConfig: () => SandboxAccountConfig_exports,
  SandboxConfig: () => SandboxConfig_exports,
  SanitizedAbsPath: () => SanitizedAbsPath_exports,
  SanitizedArgs: () => SanitizedArgs_exports,
  SanitizedPath: () => SanitizedPath_exports,
  ScaffoldConfig: () => ScaffoldConfig_exports,
  TaqError: () => TaqError_exports,
  Task: () => Task_exports,
  Template: () => Template_exports,
  Url: () => Url_exports,
  Verb: () => Verb_exports,
  VersionNumber: () => VersionNumber_exports,
  i18n: () => i18n_exports
});

// ../taqueria-protocol/EphemeralState.ts
var EphemeralState_exports = {};
__export(EphemeralState_exports, {
  create: () => create40,
  factory: () => factory40,
  generatedSchemas: () => generatedSchemas35,
  getTasks: () => getTasks,
  make: () => make39,
  mapOperationsToPlugins: () => mapOperationsToPlugins,
  mapTasksToPlugins: () => mapTasksToPlugins,
  mapTemplatesToPlugins: () => mapTemplatesToPlugins,
  of: () => of39,
  schemas: () => schemas40
});
var eager2 = (f) => promise(
  mapRej((err) => new E_TaqError(err))(f)
);
var taskToPluginMap = mod.record(
  mod.union([
    schemas4.schema,
    schemas34.schema
  ], { description: "Task/Plugin Mapping" })
);
var operationToPluginMap = mod.record(
  mod.union([
    schemas4.schema,
    schemas29.schema
  ], { description: "Operation/Plugin Mapping" })
);
var templateToPluginMap = mod.record(
  mod.union([
    schemas4.schema,
    schemas33.schema
  ])
);
var rawSchema39 = mod.object({
  build: mod.string({ description: "cache.build" }),
  configHash: mod.string({ description: "cache.configHash" }),
  tasks: taskToPluginMap,
  operations: operationToPluginMap,
  templates: templateToPluginMap,
  plugins: mod.array(schemas36.schema, { description: "cache.plugins" })
}).describe("Ephemeral State");
var { schemas: generatedSchemas35, factory: factory40 } = Base_default({
  rawSchema: rawSchema39,
  parseErrMsg: (value2) => `${value2} is not a valid representation of ephemeral state`,
  unknownErrMsg: "Something went wrong when parsing the ephemeral state"
});
var { create: create40, of: of39, make: make39 } = factory40;
var schemas40 = {
  ...generatedSchemas35,
  schema: generatedSchemas35.schema.transform((val) => val)
};
var getTaskCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.tasks === void 0 ? {} : pluginInfo2.tasks.reduce(
      (retval2, task) => {
        const taskName = task.task;
        const providers = retval2[taskName] ? [...retval2[taskName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[taskName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getTemplateCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => !pluginInfo2.templates ? retval : pluginInfo2.templates.reduce(
      (retval2, template) => {
        const templateName = template.template;
        const providers = retval2[templateName] ? [...retval2[templateName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[templateName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var getOperationCounts = (pluginInfo) => {
  return pluginInfo.reduce(
    (retval, pluginInfo2) => pluginInfo2.operations === void 0 ? retval : pluginInfo2.operations.reduce(
      (retval2, operation) => {
        const operationName = operation.operation;
        const providers = retval2[operationName] ? [...retval2[operationName], pluginInfo2] : [pluginInfo2];
        const mapping = {};
        mapping[operationName] = providers.filter((provider) => provider !== void 0);
        return { ...retval2, ...mapping };
      },
      retval
    ),
    {}
  );
};
var toChoices = (plugins) => plugins.reduce(
  (retval, pluginInfo) => {
    return [...retval, pluginInfo.name, pluginInfo.alias];
  },
  []
);
var isComposite = (name2, counts) => counts[name2] && counts[name2].length > 1;
var getInstalledPlugin = (config, name2) => config.plugins?.find(
  (plugin) => [`taqueria-plugin-${name2}`, name2].includes(plugin.name)
);
var mapTasksToPlugins = (config, pluginInfo, i18n) => {
  const taskCounts = getTaskCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.tasks ? Promise.resolve({}) : await pluginInfo2.tasks.reduce(
        async (retval2, { task }) => {
          if (isComposite(task, taskCounts)) {
            const command = await eager2(make18(task));
            const compositeTask = await eager2(make33({
              task,
              command,
              description: i18n.__("providedByMany"),
              hidden: false,
              options: [
                await eager2(make20({
                  flag: await eager2(make12("plugin")),
                  description: "Specify which plugin should be used to execute this task",
                  choices: toChoices(taskCounts[task]),
                  required: true
                }))
              ],
              handler: "proxy"
            }));
            return { ...await retval2, [task]: compositeTask };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [task]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var mapOperationsToPlugins = (config, pluginInfo, i18n) => {
  const opCounts = getOperationCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.operations ? Promise.resolve({}) : await pluginInfo2.operations.reduce(
        async (retval2, { operation }) => {
          if (isComposite(operation, opCounts)) {
            const command = await eager2(make18(operation));
            const compositeOp = await eager2(make29({
              operation,
              command,
              description: i18n.__("providedByMany"),
              options: [
                await eager2(make20({
                  flag: await eager2(make12("plugin")),
                  description: "Specify which plugin should be used to execute this operation",
                  choices: toChoices(opCounts[operation]),
                  required: true
                }))
              ]
            }));
            return { ...await retval2, [operation]: compositeOp };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [operation]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var mapTemplatesToPlugins = (config, pluginInfo, i18n) => {
  const tmplCounts = getTemplateCounts(pluginInfo);
  return attemptP(
    async () => await pluginInfo.reduce(
      async (retval, pluginInfo2) => !pluginInfo2.templates ? Promise.resolve({}) : await pluginInfo2.templates.reduce(
        async (retval2, { template }) => {
          if (isComposite(template, tmplCounts)) {
            const command = await eager2(make18(template));
            const compositeTmpl = await eager2(make32({
              template,
              command,
              description: i18n.__("providedByMany"),
              options: [
                await eager2(make20({
                  flag: await eager2(make12("plugin")),
                  description: "Specify which plugin should be used to execute this task",
                  choices: toChoices(tmplCounts[template]),
                  required: true
                }))
              ],
              handler: "proxy",
              encoding: create31("none")
            }));
            return { ...await retval2, [template]: compositeTmpl };
          }
          const installedPlugin = getInstalledPlugin(config, pluginInfo2.name);
          return installedPlugin ? { ...await retval2, [template]: installedPlugin } : retval2;
        },
        retval
      ),
      Promise.resolve({})
    )
  ).pipe(mapRej((rej) => rej));
};
var getTasks = (pluginInfo) => pluginInfo.reduce(
  (retval, pluginInfo2) => [...retval, ...pluginInfo2.tasks ?? []],
  []
);

// ../taqueria-protocol/i18n.ts
var i18n_exports = {};
__export(i18n_exports, {
  default: () => i18n_default
});

// ../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// ../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// ../node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// ../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// ../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// ../node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// ../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// ../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// ../node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}

// ../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// ../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// ../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

// ../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// ../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../node_modules/@babel/runtime/helpers/esm/toArray.js
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

// ../node_modules/i18next/dist/esm/i18next.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn(args) {
    this.output("warn", args);
  },
  error: function error2(args) {
    this.output("error", args);
  },
  output: function output(type4, args) {
    if (console && console[type4])
      console[type4].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create41(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve3, reject2) {
    res = resolve3;
    rej = reject2;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s, t2) {
  a.forEach(function(m) {
    if (s[m])
      t2[m] = s[m];
  });
}
function getLastOfPath(object, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object, path2, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path2, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path2, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object, path2) {
  var _getLastOfPath3 = getLastOfPath(object, path2), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value2 = getPath(data, key);
  if (value2 !== void 0) {
    return value2;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape2(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c) {
    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r = new RegExp("(".concat(possibleChars.map(function(c) {
    return c === "?" ? "\\?" : c;
  }).join("|"), ")"));
  var matched = !r.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path2) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  var paths = path2.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j = 2;
      var p = paths.slice(i, i + j).join(keySeparator);
      var mix = current[p];
      while (mix === void 0 && paths.length > i + j) {
        j++;
        p = paths.slice(i, i + j).join(keySeparator);
        mix = current[p];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path2.endsWith(p)) {
        if (typeof mix === "string")
          return mix;
        if (p && typeof mix[p] === "string")
          return mix[p];
      }
      var joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path2 = [lng, ns];
      if (key && typeof key !== "string")
        path2 = path2.concat(key);
      if (key && typeof key === "string")
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      var result = getPath(this.data, path2);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value2) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path2 = [lng, ns];
      if (key)
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value2 = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value2);
      if (!options.silent)
        this.emit("added", lng, ns, key, value2);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path2, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n = data && Object.keys(data) || [];
      return !!n.find(function(v) {
        return data[v] && Object.keys(data[v]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value2, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value2 = _this.processors[processor].process(value2, key, options, translator);
    });
    return value2;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage2(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists2(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;
      if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace2 = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace2).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace2).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r;
            return resolved;
          }
          return r;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey)
                copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace2, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l, k, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace2, k, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace2, k, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l, namespace2, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace2, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace2, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve3(keys) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = "defaultValue";
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p = code.split("-");
      if (p.length === 2)
        return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p = code.split("-");
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p = code.split("-");
        if (this.options.lowerCaseLng) {
          p = p.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2)
            p[1] = p[1].toUpperCase();
          if (p[0] !== "sgn" && p[2].length === 2)
            p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1)
            p[2] = capitalize(p[2].toLowerCase());
        }
        return p.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c) {
        if (!c)
          return;
        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _2(n) {
    return Number(n != 1);
  },
  3: function _3(n) {
    return 0;
  },
  4: function _4(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _7(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _9(n) {
    return Number(n >= 2);
  },
  10: function _10(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _11(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _12(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _13(n) {
    return Number(n !== 0);
  },
  14: function _14(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _15(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _17(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _18(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _19(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _20(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _21(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _22(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value2) {
      return value2;
    };
    this.init(options);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape2;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match;
      var value2;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path2;
        }
        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value2 = handleFormat(matchedVar);
          if (value2 === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options);
              value2 = typeof temp === "string" ? temp : "";
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value2 = "";
            } else if (skipOnVariables) {
              value2 = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value2 = "";
            }
          } else if (typeof value2 !== "string" && !_this.useRawValueToEscape) {
            value2 = makeString(value2);
          }
          var safeValue = todo.safeValue(value2);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value2.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value2;
      var clonedOptions = _objectSpread$3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value2 && match[0] === str && typeof value2 !== "string")
          return value2;
        if (typeof value2 !== "string")
          value2 = makeString(value2);
        if (!value2) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value2 = "";
        }
        if (doReduce) {
          value2 = formatters.reduce(function(v, f) {
            return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value2.trim());
        }
        str = str.replace(match[0], value2);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: function number(val, lng, options2) {
        return new Intl.NumberFormat(lng, options2).format(val);
      },
      currency: function currency(val, lng, options2) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options2), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options2) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options2)).format(val);
      },
      relativetime: function relativetime(val, lng, options2) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options2)).format(val, options2.range || "day");
      },
      list: function list(val, lng, options2) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options2)).format(val);
      }
    };
    this.init(options);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name2, fc) {
      this.formats[name2.toLowerCase().trim()] = fc;
    }
  }, {
    key: "format",
    value: function format(value2, _format, lng, options) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f) {
        var _parseFormatStr = parseFormatStr(f), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value2);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q, name2) {
  if (q.pending[name2] !== void 0) {
    delete q.pending[name2];
    q.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name2 = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name2] = 2;
          } else if (_this2.state[name2] < 0)
            ;
          else if (_this2.state[name2] === 1) {
            if (pending[name2] === void 0)
              pending[name2] = true;
          } else {
            _this2.state[name2] = 1;
            hasAllNamespaces = false;
            if (pending[name2] === void 0)
              pending[name2] = true;
            if (toLoad[name2] === void 0)
              toLoad[name2] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name2, err, data) {
      var s = name2.split("|");
      var lng = s[0];
      var ns = s[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name2] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        removePending(q, name2);
        if (err)
          q.errors.push(err);
        if (q.pendingCount === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l])
              loaded2[l] = {};
            var loadedKeys = q.loaded[l];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loaded2[l][ns2] === void 0)
                  loaded2[l][ns2] = true;
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name2) {
        _this4.loadOne(name2);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name2) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name2.split("|");
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name2, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace2, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace2)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace2, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace2, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace2, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value2, _format, lng, options) {
        return value2;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop2() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init)
            s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop2;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback(err, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources2(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0)
              toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources2(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop2;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use2(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l) {
      if (!l || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage2(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l);
      };
      var done2 = function done3(err, l) {
        if (l) {
          setLngProps(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            setLngProps(l);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done2(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT2(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists2() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace2(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n) {
        if (_this7.options.ns.indexOf(n) < 0)
          _this7.options.ns.push(n);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone[m] = _this8[m];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;
var i18next_default = instance;

// ../taqueria-protocol/i18n.ts
var i18n_default = async () => {
  const i18n = {
    ...await i18next_default.init({
      lng: "en",
      debug: false,
      resources: {
        en: {
          translation: {
            "appName": "Taqueria",
            "appDesc": "Taqueria is an integrated environment for compiling, testing, and deploying Tezos software.",
            "versionDesc": "Display the version number of the Taqueria program",
            "betaWarning": "Taqueria is currently in BETA. You've been warned. :)",
            "configDirDesc": "Config directory (default ./.taq)",
            "initDesc": "Initialize a new project",
            "optInDesc": "Opt-in to sharing anonymous usage analytics",
            "optOutDesc": "Opt-out of sharing anonymous usage analytics",
            "initPathDesc": "Path to your project directory",
            "scaffoldDesc": "Generate a new project using pre-made scaffold",
            "scaffoldUrlDesc": "Alias or Url for the scaffold project",
            "scaffoldProjectDirDesc": "Path where to create the new project. This must be a new directory.",
            "scaffoldDoneMsg": "The project was created using the scaffold.",
            "installDesc": "Install a plugin",
            "pluginInstalled": "Plugin installed successfully",
            "pluginUninstalled": "Plugin uninstalled successfully",
            "uninstallDesc": "Uninstall a plugin",
            "pluginNameDesc": "The name of the plugin",
            "promptForTask": "Please specify which task you would like to execute. If you're starting a new project, please run 'init'.\n",
            "pluginKindDesc": "Kind of plugin (NPM, Binary)",
            "pluginAlreadyInstalled": "That plugin is already installed.",
            "pluginOptionDesc": "Use the task from this plugin",
            "bootstrapMsg": "Project taq'ified!",
            "maxConcurrencyDesc": "Set the maximum concurrency limit used internally",
            "providedByMany": "Provided by more than one plugin. The option --plugin is required.",
            "pluginDesc": "Specify what plugin should execute this command. Use this when more than one plugin provide a task of the same name.",
            "listNetworks": "List known networks",
            "envDesc": "Specify an environment configuration",
            "disableStateDesc": "Does not use the saved state.json file. State is computed for each execution.",
            "logPluginCallsDesc": "Logs any execution calls to a plugin to the console",
            "npmInitRequired": "This project isn't a valid NPM project. Please run: npm init",
            "testFromVsCode": "An internal command used by VS Code to test for the taq binary",
            "fromVsCode": "An internal flag used to indicate that taq is executed via vscode",
            "buildDesc": "Display build information about the current version",
            "pluginOption": "Use to specify what plugin you'd like when running this task.",
            "yesOptionDesc": 'Select "yes" to any prompt',
            "templateNotFound": "Template not found. Perhaps you need to install a plugin?",
            "createDesc": "Create files from pre-existing templates",
            "templateDesc": "Name of the template to use",
            "addContractDesc": "Add a contract to the contract registry",
            "addSourceFileDesc": "Source file to add to the contract registry",
            "removeContractDesc": "Remove a contract from the contract registry",
            "removeContractNameDesc": "The name of the contract to remove",
            "noContractsRegistered": "No registered contracts found",
            "listContractsDesc": "List registered contracts"
          }
        }
      }
    }),
    __: i18next_default.t
  };
  return i18n;
};

// ../taqueria-protocol/PluginActionName.ts
var PluginActionName_exports = {};
__export(PluginActionName_exports, {
  schemas: () => schemas41
});
var rawSchema40 = mod.union([
  mod.literal("checkRuntimeDependencies"),
  mod.literal("installRuntimeDependencies"),
  mod.literal("proxy"),
  mod.literal("proxyTemplate"),
  mod.literal("pluginInfo")
]);
var internalSchema26 = rawSchema40;
var pluginActionNotSupportedSchema = mod.object({
  status: mod.literal("notSupported"),
  msg: mod.string()
});
var schemas41 = {
  schema: internalSchema26,
  internalSchema: internalSchema26,
  rawSchema: rawSchema40
};

// ../taqueria-protocol/ScaffoldConfig.ts
var ScaffoldConfig_exports = {};
export {
  Environment_exports as Environment,
  LoadedConfig_exports as LoadedConfig,
  NetworkConfig_exports as NetworkConfig,
  Operation_exports as Operation,
  Option_exports as Option,
  PersistentState_exports as PersistentState,
  PluginSchema_exports as PluginSchema,
  PositionalArg_exports as PositionalArg,
  taqueria_protocol_types_exports as Protocol,
  RequestArgs_exports as RequestArgs,
  SandboxAccountConfig_exports as SandboxAccountConfig,
  SandboxConfig_exports as SandboxConfig,
  SanitizedAbsPath_exports as SanitizedAbsPath,
  SanitizedPath_exports as SanitizedPath,
  TaqError_exports as TaqError,
  Task_exports as Task,
  Template_exports as Template
};
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
//# sourceMappingURL=types.esm.js.map
