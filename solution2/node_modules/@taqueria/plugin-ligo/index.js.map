{"mappings":"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","sources":["taqueria-plugin-ligo/index.ts","taqueria-plugin-ligo/compile.ts","taqueria-plugin-ligo/createContract.ts","taqueria-plugin-ligo/ligo_templates.ts"],"sourcesContent":["import { Option, Plugin, PositionalArg, Task, Template } from '@taqueria/node-sdk';\nimport compile from './compile';\nimport createContract from './createContract';\n\nPlugin.create(i18n => ({\n\tschema: '1.0',\n\tversion: '0.1',\n\talias: 'ligo',\n\ttasks: [\n\t\tTask.create({\n\t\t\ttask: 'compile',\n\t\t\tcommand: 'compile [sourceFile]',\n\t\t\taliases: ['c', 'compile-ligo'],\n\t\t\tdescription: 'Compile a smart contract written in a Ligo syntax to Michelson code',\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 'e',\n\t\t\t\t\tflag: 'entrypoint',\n\t\t\t\t\tdescription: 'The entry point that will be compiled',\n\t\t\t\t}),\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 's',\n\t\t\t\t\tflag: 'syntax',\n\t\t\t\t\tdescription: 'The syntax used in the contract',\n\t\t\t\t}),\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 'i',\n\t\t\t\t\tflag: 'infer',\n\t\t\t\t\tdescription: 'Enable type inference',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: 'proxy',\n\t\t\tencoding: 'json',\n\t\t}),\n\t],\n\ttemplates: [\n\t\tTemplate.create({\n\t\t\ttemplate: 'contract',\n\t\t\tcommand: 'contract <sourceFileName>',\n\t\t\tdescription: 'Create a LIGO contract with boilerplate code',\n\t\t\tpositionals: [\n\t\t\t\tPositionalArg.create({\n\t\t\t\t\tplaceholder: 'sourceFileName',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The name of the LIGO contract to generate',\n\t\t\t\t}),\n\t\t\t],\n\t\t\toptions: [\n\t\t\t\tOption.create({\n\t\t\t\t\tshortFlag: 's',\n\t\t\t\t\tflag: 'syntax',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: 'The syntax used in the contract',\n\t\t\t\t}),\n\t\t\t],\n\t\t\thandler: createContract,\n\t\t}),\n\t],\n\tproxy: compile,\n}), process.argv);\n","import { execCmd, getArch, getContracts, sendAsyncErr, sendErr, sendJsonRes } from '@taqueria/node-sdk';\nimport { RequestArgs } from '@taqueria/node-sdk/types';\nimport { basename, extname, join } from 'path';\n\ninterface Opts extends RequestArgs.t {\n\tentrypoint?: string;\n\tsyntax?: string;\n\tsourceFile?: string;\n}\n\nconst getContractArtifactFilename = (opts: Opts) =>\n\t(sourceFile: string) => {\n\t\tconst outFile = basename(sourceFile, extname(sourceFile));\n\t\treturn join(opts.config.artifactsDir, `${outFile}.tz`);\n\t};\n\nconst getInputFilename = (opts: Opts) =>\n\t(sourceFile: string) => {\n\t\treturn join(opts.config.contractsDir, sourceFile);\n\t};\n\nconst getCompileCommand = (opts: Opts) =>\n\t(sourceFile: string) => {\n\t\tconst projectDir = process.env.PROJECT_DIR ?? opts.projectDir;\n\n\t\tif (!projectDir) throw `No project directory provided`;\n\n\t\tconst inputFile = getInputFilename(opts)(sourceFile);\n\t\tconst baseCommand =\n\t\t\t`DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \\\"${projectDir}\\\":/project -w /project -u $(id -u):$(id -g) ligolang/ligo:next compile contract ${inputFile}`;\n\t\tconst entryPoint = opts.entrypoint ? `-e ${opts.entrypoint}` : '';\n\t\tconst syntax = opts['syntax'] ? `-s ${opts['syntax']} : \"\"` : '';\n\t\tconst outFile = `-o ${getContractArtifactFilename(opts)(sourceFile)}`;\n\t\tconst cmd = `${baseCommand} ${entryPoint} ${syntax} ${outFile}`;\n\t\treturn cmd;\n\t};\n\nconst compileContract = (opts: Opts) =>\n\t(sourceFile: string): Promise<{ contract: string; artifact: string }> =>\n\t\tgetArch()\n\t\t\t.then(() => getCompileCommand(opts)(sourceFile))\n\t\t\t.then(execCmd)\n\t\t\t.then(({ stderr }) => { // How should we output warnings?\n\t\t\t\tif (stderr.length > 0) sendErr(stderr);\n\t\t\t\treturn {\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: getContractArtifactFilename(opts)(sourceFile),\n\t\t\t\t};\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tsendErr(' ');\n\t\t\t\tsendErr(err.message.split('\\n').slice(1).join('\\n'));\n\t\t\t\treturn Promise.resolve({\n\t\t\t\t\tcontract: sourceFile,\n\t\t\t\t\tartifact: 'Not compiled',\n\t\t\t\t});\n\t\t\t});\n\nconst compileAll = (parsedArgs: Opts) =>\n\tPromise.all(getContracts(/\\.(ligo|religo|mligo|jsligo)$/, parsedArgs.config))\n\t\t.then(entries => entries.map(compileContract(parsedArgs)))\n\t\t.then(processes => {\n\t\t\tif (processes.length > 0) return processes;\n\t\t\treturn [];\n\t\t})\n\t\t.then(promises => Promise.all(promises));\n\nexport const compile = (parsedArgs: Opts) => {\n\tconst p = parsedArgs.sourceFile\n\t\t? compileContract(parsedArgs)(parsedArgs.sourceFile as string)\n\t\t\t.then(result => [result])\n\t\t: compileAll(parsedArgs)\n\t\t\t.then(results => {\n\t\t\t\tif (results.length === 0) {\n\t\t\t\t\tsendErr('No contracts found to compile. Have you run \"taq add-contract [sourceFile]\" ?');\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t});\n\n\treturn p\n\t\t.then(sendJsonRes)\n\t\t.catch(err => sendAsyncErr(err, false));\n};\n\nexport default compile;\n","import { experimental, sendAsyncErr } from '@taqueria/node-sdk';\nimport * as RequestArgs from '@taqueria/protocol/RequestArgs';\nimport { writeFile } from 'fs/promises';\nimport { jsligo_template, mligo_template, pascaligo_template, religo_template } from './ligo_templates';\n\ninterface Opts extends RequestArgs.t {\n\tsourceFileName?: string;\n\tsyntax?: string;\n}\n\nconst registerContract = (arg: Opts, contractName: string) => {\n\texperimental.registerContract(arg, contractName);\n};\n\nconst getLigoTemplate = async (contractName: string, syntax: string | undefined): Promise<string> => {\n\tconst matchResult = contractName.match(/\\.[^.]+$/);\n\tconst ext = matchResult ? matchResult[0].substring(1) : null;\n\n\tif (syntax === 'mligo') return mligo_template;\n\tif (syntax === 'ligo') return pascaligo_template;\n\tif (syntax === 'religo') return religo_template;\n\tif (syntax === 'jsligo') return jsligo_template;\n\n\tif (syntax === undefined) {\n\t\tif (ext === 'mligo') return mligo_template;\n\t\tif (ext === 'ligo') return pascaligo_template;\n\t\tif (ext === 'religo') return religo_template;\n\t\tif (ext === 'jsligo') return jsligo_template;\n\t\treturn sendAsyncErr(\n\t\t\t`Unable to infer LIGO syntax from \"${contractName}\". Please specify a LIGO syntax via the --syntax option`,\n\t\t);\n\t} else {\n\t\treturn sendAsyncErr(`\"${syntax}\" is not a valid syntax. Please specify a valid LIGO syntax`);\n\t}\n};\n\nconst createContract = (arg: Opts) => {\n\tconst contractName = arg.sourceFileName as string;\n\tconst syntax = arg.syntax;\n\tconst contractsDir = `${arg.config.projectDir}/${arg.config.contractsDir}`;\n\treturn getLigoTemplate(contractName, syntax)\n\t\t.then(ligo_template => writeFile(`${contractsDir}/${contractName}`, ligo_template))\n\t\t.then(_ => registerContract(arg, contractName));\n};\n\nexport default createContract;\n","export const mligo_template = `\ntype storage = int\n\ntype parameter =\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return = operation list * storage\n\n// Two entrypoints\n\nlet add (store, delta : storage * int) : storage = store + delta\nlet sub (store, delta : storage * int) : storage = store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nlet main (action, store : parameter * storage) : return =\n ([] : operation list),    // No operations\n (match action with\n   Increment (n) -> add (store, n)\n | Decrement (n) -> sub (store, n)\n | Reset         -> 0)\n`;\n\nexport const pascaligo_template = `\ntype storage is int\n\ntype parameter is\n  Increment of int\n| Decrement of int\n| Reset\n\ntype return is list (operation) * storage\n\n// Two entrypoints\n\nfunction add (const store : storage; const delta : int) : storage is \n  store + delta\n\nfunction sub (const store : storage; const delta : int) : storage is \n  store - delta\n\n(* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. *)\n   \nfunction main (const action : parameter; const store : storage) : return is\n ((nil : list (operation)),    // No operations\n  case action of [\n    Increment (n) -> add (store, n)\n  | Decrement (n) -> sub (store, n)\n  | Reset         -> 0\n  ])\n`;\n\nexport const religo_template = `\ntype storage = int;\n\ntype parameter =\n  Increment (int)\n| Decrement (int)\n| Reset;\n\ntype return = (list (operation), storage);\n\n// Two entrypoints\n\nlet add = ((store, delta) : (storage, int)) : storage => store + delta;\nlet sub = ((store, delta) : (storage, int)) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n   \nlet main = ((action, store) : (parameter, storage)) : return => {\n (([] : list (operation)),    // No operations\n (switch (action) {\n  | Increment (n) => add ((store, n))\n  | Decrement (n) => sub ((store, n))\n  | Reset         => 0}))\n};\n`;\n\nexport const jsligo_template = `\ntype storage = int;\n\ntype parameter =\n  [\"Increment\", int]\n| [\"Decrement\", int]\n| [\"Reset\"];\n\ntype ret = [list<operation>, storage];\n\n// Two entrypoints\n\nconst add = ([store, delta] : [storage, int]) : storage => store + delta;\nconst sub = ([store, delta] : [storage, int]) : storage => store - delta;\n\n/* Main access point that dispatches to the entrypoints according to\n   the smart contract parameter. */\n\nconst main = ([action, store] : [parameter, storage]) : ret => {\n return [list([]) as list<operation>,    // No operations\n match (action, {\n  Increment:(n: int) => add ([store, n]),\n  Decrement:(n: int) => sub ([store, n]),\n  Reset    :()  => 0})]\n};\n`;\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../"}