var $kQNfl$taquerianodesdk = require("@taqueria/node-sdk");
var $kQNfl$path = require("path");
var $kQNfl$fspromises = require("fs/promises");




const $24b2f47d8f306cb3$var$getContractArtifactFilename = (opts)=>(sourceFile)=>{
        const outFile = (0, $kQNfl$path.basename)(sourceFile, (0, $kQNfl$path.extname)(sourceFile));
        return (0, $kQNfl$path.join)(opts.config.artifactsDir, `${outFile}.tz`);
    };
const $24b2f47d8f306cb3$var$getInputFilename = (opts)=>(sourceFile)=>{
        return (0, $kQNfl$path.join)(opts.config.contractsDir, sourceFile);
    };
const $24b2f47d8f306cb3$var$getCompileCommand = (opts)=>(sourceFile)=>{
        const projectDir = process.env.PROJECT_DIR ?? opts.projectDir;
        if (!projectDir) throw `No project directory provided`;
        const inputFile = $24b2f47d8f306cb3$var$getInputFilename(opts)(sourceFile);
        const baseCommand = `DOCKER_DEFAULT_PLATFORM=linux/amd64 docker run --rm -v \"${projectDir}\":/project -w /project -u $(id -u):$(id -g) ligolang/ligo:next compile contract ${inputFile}`;
        const entryPoint = opts.entrypoint ? `-e ${opts.entrypoint}` : "";
        const syntax = opts["syntax"] ? `-s ${opts["syntax"]} : ""` : "";
        const outFile = `-o ${$24b2f47d8f306cb3$var$getContractArtifactFilename(opts)(sourceFile)}`;
        const cmd = `${baseCommand} ${entryPoint} ${syntax} ${outFile}`;
        return cmd;
    };
const $24b2f47d8f306cb3$var$compileContract = (opts)=>(sourceFile)=>(0, $kQNfl$taquerianodesdk.getArch)().then(()=>$24b2f47d8f306cb3$var$getCompileCommand(opts)(sourceFile)).then((0, $kQNfl$taquerianodesdk.execCmd)).then(({ stderr: stderr  })=>{
            if (stderr.length > 0) (0, $kQNfl$taquerianodesdk.sendErr)(stderr);
            return {
                contract: sourceFile,
                artifact: $24b2f47d8f306cb3$var$getContractArtifactFilename(opts)(sourceFile)
            };
        }).catch((err)=>{
            (0, $kQNfl$taquerianodesdk.sendErr)(" ");
            (0, $kQNfl$taquerianodesdk.sendErr)(err.message.split("\n").slice(1).join("\n"));
            return Promise.resolve({
                contract: sourceFile,
                artifact: "Not compiled"
            });
        });
const $24b2f47d8f306cb3$var$compileAll = (parsedArgs)=>Promise.all((0, $kQNfl$taquerianodesdk.getContracts)(/\.(ligo|religo|mligo|jsligo)$/, parsedArgs.config)).then((entries)=>entries.map($24b2f47d8f306cb3$var$compileContract(parsedArgs))).then((processes)=>{
        if (processes.length > 0) return processes;
        return [];
    }).then((promises)=>Promise.all(promises));
const $24b2f47d8f306cb3$export$ef7acd7185315e22 = (parsedArgs)=>{
    const p = parsedArgs.sourceFile ? $24b2f47d8f306cb3$var$compileContract(parsedArgs)(parsedArgs.sourceFile).then((result)=>[
            result
        ]) : $24b2f47d8f306cb3$var$compileAll(parsedArgs).then((results)=>{
        if (results.length === 0) (0, $kQNfl$taquerianodesdk.sendErr)('No contracts found to compile. Have you run "taq add-contract [sourceFile]" ?');
        return results;
    });
    return p.then((0, $kQNfl$taquerianodesdk.sendJsonRes)).catch((err)=>(0, $kQNfl$taquerianodesdk.sendAsyncErr)(err, false));
};
var $24b2f47d8f306cb3$export$2e2bcd8739ae039 = $24b2f47d8f306cb3$export$ef7acd7185315e22;




const $9d8c61104c8e60ad$export$1336661d942c7074 = `
type storage = int

type parameter =
  Increment of int
| Decrement of int
| Reset

type return = operation list * storage

// Two entrypoints

let add (store, delta : storage * int) : storage = store + delta
let sub (store, delta : storage * int) : storage = store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
let main (action, store : parameter * storage) : return =
 ([] : operation list),    // No operations
 (match action with
   Increment (n) -> add (store, n)
 | Decrement (n) -> sub (store, n)
 | Reset         -> 0)
`;
const $9d8c61104c8e60ad$export$ec41334b92330d9b = `
type storage is int

type parameter is
  Increment of int
| Decrement of int
| Reset

type return is list (operation) * storage

// Two entrypoints

function add (const store : storage; const delta : int) : storage is 
  store + delta

function sub (const store : storage; const delta : int) : storage is 
  store - delta

(* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. *)
   
function main (const action : parameter; const store : storage) : return is
 ((nil : list (operation)),    // No operations
  case action of [
    Increment (n) -> add (store, n)
  | Decrement (n) -> sub (store, n)
  | Reset         -> 0
  ])
`;
const $9d8c61104c8e60ad$export$9e59f1f7960689be = `
type storage = int;

type parameter =
  Increment (int)
| Decrement (int)
| Reset;

type return = (list (operation), storage);

// Two entrypoints

let add = ((store, delta) : (storage, int)) : storage => store + delta;
let sub = ((store, delta) : (storage, int)) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
   
let main = ((action, store) : (parameter, storage)) : return => {
 (([] : list (operation)),    // No operations
 (switch (action) {
  | Increment (n) => add ((store, n))
  | Decrement (n) => sub ((store, n))
  | Reset         => 0}))
};
`;
const $9d8c61104c8e60ad$export$6d35abb7f92d1079 = `
type storage = int;

type parameter =
  ["Increment", int]
| ["Decrement", int]
| ["Reset"];

type ret = [list<operation>, storage];

// Two entrypoints

const add = ([store, delta] : [storage, int]) : storage => store + delta;
const sub = ([store, delta] : [storage, int]) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */

const main = ([action, store] : [parameter, storage]) : ret => {
 return [list([]) as list<operation>,    // No operations
 match (action, {
  Increment:(n: int) => add ([store, n]),
  Decrement:(n: int) => sub ([store, n]),
  Reset    :()  => 0})]
};
`;


const $40622e3a438d0515$var$registerContract = (arg, contractName)=>{
    (0, $kQNfl$taquerianodesdk.experimental).registerContract(arg, contractName);
};
const $40622e3a438d0515$var$getLigoTemplate = async (contractName, syntax)=>{
    const matchResult = contractName.match(/\.[^.]+$/);
    const ext = matchResult ? matchResult[0].substring(1) : null;
    if (syntax === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
    if (syntax === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
    if (syntax === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
    if (syntax === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
    if (syntax === undefined) {
        if (ext === "mligo") return 0, $9d8c61104c8e60ad$export$1336661d942c7074;
        if (ext === "ligo") return 0, $9d8c61104c8e60ad$export$ec41334b92330d9b;
        if (ext === "religo") return 0, $9d8c61104c8e60ad$export$9e59f1f7960689be;
        if (ext === "jsligo") return 0, $9d8c61104c8e60ad$export$6d35abb7f92d1079;
        return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`Unable to infer LIGO syntax from "${contractName}". Please specify a LIGO syntax via the --syntax option`);
    } else return (0, $kQNfl$taquerianodesdk.sendAsyncErr)(`"${syntax}" is not a valid syntax. Please specify a valid LIGO syntax`);
};
const $40622e3a438d0515$var$createContract = (arg)=>{
    const contractName = arg.sourceFileName;
    const syntax = arg.syntax;
    const contractsDir = `${arg.config.projectDir}/${arg.config.contractsDir}`;
    return $40622e3a438d0515$var$getLigoTemplate(contractName, syntax).then((ligo_template)=>(0, $kQNfl$fspromises.writeFile)(`${contractsDir}/${contractName}`, ligo_template)).then((_)=>$40622e3a438d0515$var$registerContract(arg, contractName));
};
var $40622e3a438d0515$export$2e2bcd8739ae039 = $40622e3a438d0515$var$createContract;


(0, $kQNfl$taquerianodesdk.Plugin).create((i18n)=>({
        schema: "1.0",
        version: "0.1",
        alias: "ligo",
        tasks: [
            (0, $kQNfl$taquerianodesdk.Task).create({
                task: "compile",
                command: "compile [sourceFile]",
                aliases: [
                    "c",
                    "compile-ligo"
                ],
                description: "Compile a smart contract written in a Ligo syntax to Michelson code",
                options: [
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "e",
                        flag: "entrypoint",
                        description: "The entry point that will be compiled"
                    }),
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "s",
                        flag: "syntax",
                        description: "The syntax used in the contract"
                    }),
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "i",
                        flag: "infer",
                        description: "Enable type inference"
                    }), 
                ],
                handler: "proxy",
                encoding: "json"
            }), 
        ],
        templates: [
            (0, $kQNfl$taquerianodesdk.Template).create({
                template: "contract",
                command: "contract <sourceFileName>",
                description: "Create a LIGO contract with boilerplate code",
                positionals: [
                    (0, $kQNfl$taquerianodesdk.PositionalArg).create({
                        placeholder: "sourceFileName",
                        type: "string",
                        description: "The name of the LIGO contract to generate"
                    }), 
                ],
                options: [
                    (0, $kQNfl$taquerianodesdk.Option).create({
                        shortFlag: "s",
                        flag: "syntax",
                        type: "string",
                        description: "The syntax used in the contract"
                    }), 
                ],
                handler: (0, $40622e3a438d0515$export$2e2bcd8739ae039)
            }), 
        ],
        proxy: (0, $24b2f47d8f306cb3$export$2e2bcd8739ae039)
    }), process.argv);


//# sourceMappingURL=index.js.map
