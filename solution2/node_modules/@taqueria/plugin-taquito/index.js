var $iVZbm$taquerianodesdk = require("@taqueria/node-sdk");
var $iVZbm$taquitosigner = require("@taquito/signer");
var $iVZbm$taquitotaquito = require("@taquito/taquito");
var $iVZbm$fastglob = require("fast-glob");
var $iVZbm$fspromises = require("fs/promises");
var $iVZbm$path = require("path");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}







const $806c5c6032403442$var$getFirstAccountAlias = (sandboxName, opts)=>{
    const aliases = (0, $iVZbm$taquerianodesdk.getSandboxAccountNames)(opts)(sandboxName);
    return aliases.shift();
};
const $806c5c6032403442$var$getContractAbspath = (contractFilename, parsedArgs)=>(0, $iVZbm$path.join)(parsedArgs.config.artifactsDir, /\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`);
const $806c5c6032403442$var$addOrigination = (parsedArgs, batch)=>async (mapping)=>{
        const contractAbspath = $806c5c6032403442$var$getContractAbspath(mapping.filename, parsedArgs);
        const contractData = await (0, $iVZbm$fspromises.readFile)(contractAbspath, "utf-8");
        return (await batch).withOrigination({
            code: contractData,
            storage: mapping.storage
        });
    };
const $806c5c6032403442$var$getValidContracts = async (parsedArgs)=>{
    const contracts = parsedArgs.contract ? [
        parsedArgs.contract
    ] : await (0, ($parcel$interopDefault($iVZbm$fastglob)))("**/*.tz", {
        cwd: parsedArgs.config.artifactsDir
    });
    return contracts.reduce((retval, filename)=>{
        const storage = (0, $iVZbm$taquerianodesdk.getInitialStorage)(parsedArgs)(filename);
        if (storage === undefined || storage === null) {
            (0, $iVZbm$taquerianodesdk.sendErr)(`Michelson artifact ${filename} has no initial storage specified for the target environment.\nStorage is expected to be specified in .taq/config.json at JSON path: environment.${(0, $iVZbm$taquerianodesdk.getCurrentEnvironment)(parsedArgs)}.storage."${filename}"\n`);
            return retval;
        }
        return [
            ...retval,
            {
                filename: filename,
                storage: storage
            }
        ];
    }, []);
};
const $806c5c6032403442$var$mapOpToContract = async (contracts, op, destination)=>{
    const results = await op.operationResults();
    return contracts.reduce((retval, contract)=>{
        // If initial storage was provided for the contract
        // then we submitted an operation to originate that contract
        if (contract.storage) {
            // WARNING - using side effect here.
            // For each iteration of reduce, results array is being modified-in-place.
            // TODO: Adjust to use recursion to avoid side-effect.
            const result = results.shift();
            const address = result && result.metadata.operation_result.originated_contracts ? result.metadata.operation_result.originated_contracts.join(",") : "Error";
            return [
                ...retval,
                {
                    contract: contract.filename,
                    address: address,
                    destination: destination
                }, 
            ];
        }
        return [
            ...retval,
            {
                contract: contract.filename,
                address: "Error",
                destination: destination
            }, 
        ];
    }, []);
};
const $806c5c6032403442$var$createBatch = async (parsedArgs, tezos, destination)=>{
    const contracts = await $806c5c6032403442$var$getValidContracts(parsedArgs);
    if (!contracts.length) return undefined;
    const batch1 = await contracts.reduce((batch, contractMapping)=>contractMapping.storage ? $806c5c6032403442$var$addOrigination(parsedArgs, batch)(contractMapping) : batch, Promise.resolve(tezos.wallet.batch()));
    try {
        const op = await batch1.send();
        const confirmed = await op.confirmation();
        return await $806c5c6032403442$var$mapOpToContract(contracts, op, destination);
    } catch (err) {
        const error = err;
        if (error.message) (0, $iVZbm$taquerianodesdk.sendErr)(error.message);
        return undefined;
    }
};
const $806c5c6032403442$var$originateToNetworks = (parsedArgs, currentEnv)=>currentEnv.networks ? currentEnv.networks.reduce((retval, networkName)=>{
        const network = (0, $iVZbm$taquerianodesdk.getNetworkConfig)(parsedArgs)(networkName);
        if (network) {
            if (network.rpcUrl) {
                if (network.faucet) {
                    const result = (async ()=>{
                        const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(network.rpcUrl);
                        await (0, $iVZbm$taquitosigner.importKey)(tezos, network.faucet.email, network.faucet.password, network.faucet.mnemonic.join(" "), network.faucet.activation_code);
                        return await $806c5c6032403442$var$createBatch(parsedArgs, tezos, networkName);
                    })();
                    return [
                        ...retval,
                        result
                    ];
                } else (0, $iVZbm$taquerianodesdk.sendErr)(`Network ${networkName} requires a valid faucet in config.json.`);
            } else (0, $iVZbm$taquerianodesdk.sendErr)(`Network "${networkName} is missing an RPC url in config.json."`);
        } else (0, $iVZbm$taquerianodesdk.sendErr)(`The current environment is configured to use a network called '${networkName}'; however, no network of this name has been configured in .taq/config.json.`);
        return retval;
    }, []) : [];
const $806c5c6032403442$var$originateToSandboxes = (parsedArgs, currentEnv)=>currentEnv.sandboxes ? currentEnv.sandboxes.reduce((retval, sandboxName)=>{
        const sandbox = (0, $iVZbm$taquerianodesdk.getSandboxConfig)(parsedArgs)(sandboxName);
        if (sandbox) {
            if (sandbox.rpcUrl) {
                let defaultAccount = (0, $iVZbm$taquerianodesdk.getDefaultAccount)(parsedArgs)(sandboxName);
                if (!defaultAccount) {
                    const first = $806c5c6032403442$var$getFirstAccountAlias(sandboxName, parsedArgs);
                    if (first) {
                        defaultAccount = (0, $iVZbm$taquerianodesdk.getSandboxAccountConfig)(parsedArgs)(sandboxName)(first);
                        // TODO: The error should be a warning, not an error. Descriptive string should not begin with 'Warning:'
                        (0, $iVZbm$taquerianodesdk.sendErr)(`Warning: A default origination account has not been specified for sandbox ${sandboxName}. Taqueria will use the account ${first} for this origination.\nA default account can be specified in .taq/config.json at JSON path: sandbox.${sandboxName}.accounts.default\n`);
                    }
                }
                if (defaultAccount) {
                    const secretKey = defaultAccount.secretKey;
                    const result = (async ()=>{
                        const tezos = new (0, $iVZbm$taquitotaquito.TezosToolkit)(sandbox.rpcUrl);
                        tezos.setProvider({
                            signer: new (0, $iVZbm$taquitosigner.InMemorySigner)(secretKey.replace(/^unencrypted:/, ""))
                        });
                        return await $806c5c6032403442$var$createBatch(parsedArgs, tezos, sandboxName);
                    })();
                    return [
                        ...retval,
                        result
                    ];
                } else (0, $iVZbm$taquerianodesdk.sendErr)(`No accounts are available for the sandbox called ${sandboxName} to perform origination.`);
            } else (0, $iVZbm$taquerianodesdk.sendErr)(`Sandbox "${sandboxName} is missing an RPC url in config.json."`);
        } else (0, $iVZbm$taquerianodesdk.sendErr)(`The current environment is configured to use a sandbox called '${sandboxName}'; however, no sandbox of this name has been configured in .taq/config.json.`);
        return retval;
    }, []) : [];
const $806c5c6032403442$export$acf571c34911f824 = (parsedArgs)=>{
    const env = (0, $iVZbm$taquerianodesdk.getCurrentEnvironmentConfig)(parsedArgs);
    if (!env) return (0, $iVZbm$taquerianodesdk.sendAsyncErr)(`There is no environment called ${parsedArgs.env} in your config.json.`);
    const jobs1 = [
        ...$806c5c6032403442$var$originateToNetworks(parsedArgs, env),
        ...$806c5c6032403442$var$originateToSandboxes(parsedArgs, env), 
    ];
    return Promise.all(jobs1).then((jobs)=>jobs.reduce((retval, originations)=>{
            return originations ? [
                ...retval,
                ...originations
            ] : retval;
        }, [])).then((results)=>results && results.length > 0 ? (0, $iVZbm$taquerianodesdk.sendJsonRes)(results) : (0, $iVZbm$taquerianodesdk.sendErr)(`No contracts originated.`));
};
var $806c5c6032403442$export$2e2bcd8739ae039 = $806c5c6032403442$export$acf571c34911f824;


(0, $iVZbm$taquerianodesdk.Plugin).create((_i18n)=>({
        alias: "taquito",
        schema: "1.0",
        version: "0.1",
        tasks: [
            (0, $iVZbm$taquerianodesdk.Task).create({
                task: "deploy",
                command: "deploy [contract]",
                description: "Deploy a smart contract to a particular environment",
                options: [],
                aliases: [
                    "originate"
                ],
                handler: "proxy",
                encoding: "application/json"
            }), 
        ],
        proxy: (0, $806c5c6032403442$export$2e2bcd8739ae039)
    }), process.argv);


//# sourceMappingURL=index.js.map
