"use strict";
/**
 * @packageDocumentation
 * @module @taquito/local-forging
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localForger = exports.LocalForger = exports.getCodec = exports.ProtocolsHash = exports.VERSION = exports.CODEC = void 0;
const constants_1 = require("./constants");
const decoder_1 = require("./decoder");
const encoder_1 = require("./encoder");
const uint8array_consumer_1 = require("./uint8array-consumer");
const utils_1 = require("@taquito/utils");
const error_1 = require("./error");
const validator_1 = require("./validator");
const protocols_1 = require("./protocols");
const encoder_proto13_1 = require("./proto13-jakarta/encoder-proto13");
const decoder_proto13_1 = require("./proto13-jakarta/decoder-proto13");
var constants_2 = require("./constants");
Object.defineProperty(exports, "CODEC", { enumerable: true, get: function () { return constants_2.CODEC; } });
__exportStar(require("./decoder"), exports);
__exportStar(require("./encoder"), exports);
__exportStar(require("./uint8array-consumer"), exports);
__exportStar(require("./interface"), exports);
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var protocols_2 = require("./protocols");
Object.defineProperty(exports, "ProtocolsHash", { enumerable: true, get: function () { return protocols_2.ProtocolsHash; } });
const PROTOCOL_CURRENT = protocols_1.ProtocolsHash.Psithaca2;
function getCodec(codec, proto) {
    if (proto === protocols_1.ProtocolsHash.Psithaca2 || protocols_1.ProtoInferiorTo(proto, protocols_1.ProtocolsHash.Psithaca2)) {
        return {
            encoder: encoder_1.encoders[codec],
            decoder: (hex) => {
                const consumer = uint8array_consumer_1.Uint8ArrayConsumer.fromHexString(hex);
                return decoder_1.decoders[codec](consumer);
            },
        };
    }
    else {
        return {
            encoder: encoder_proto13_1.encodersProto13[codec],
            decoder: (hex) => {
                const consumer = uint8array_consumer_1.Uint8ArrayConsumer.fromHexString(hex);
                return decoder_proto13_1.decodersProto13[codec](consumer);
            },
        };
    }
}
exports.getCodec = getCodec;
class LocalForger {
    constructor(protocolHash = PROTOCOL_CURRENT) {
        this.protocolHash = protocolHash;
        this.codec = getCodec(constants_1.CODEC.MANAGER, this.protocolHash);
    }
    forge(params) {
        if (utils_1.validateBlock(params.branch) !== utils_1.ValidationResult.VALID) {
            throw new error_1.InvalidBlockHashError(`The block hash ${params.branch} is invalid`);
        }
        for (const content of params.contents) {
            if (!validator_1.validateOperationKind(content.kind)) {
                throw new utils_1.InvalidOperationKindError(content.kind);
            }
            const diff = validator_1.validateMissingProperty(content);
            if (diff.length === 1) {
                if (content.kind === 'delegation' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'origination' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                    continue;
                }
                else if (content.kind === 'tx_rollup_submit_batch' &&
                    diff[0] === 'burn_limit') {
                    continue;
                }
                else {
                    throw new error_1.InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
                }
            }
            else if (diff.length > 1) {
                throw new error_1.InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
            }
        }
        const forged = this.codec.encoder(params).toLowerCase();
        return Promise.resolve(forged);
    }
    parse(hex) {
        return Promise.resolve(this.codec.decoder(hex));
    }
}
exports.LocalForger = LocalForger;
exports.localForger = new LocalForger();
//# sourceMappingURL=taquito-local-forging.js.map