"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.burnLimitDecoder = exports.burnLimitEncoder = exports.txRollupBatchContentDecoderProto13 = exports.txRollupBatchContentEncoderProto13 = exports.txRollupIdDecoderProto13 = exports.txRollupIdEncoderProto13 = exports.txRollupOriginationParamDecoderProto13 = exports.txRollupOriginationParamEncoderProto13 = exports.valueParameterEncoderProto13 = exports.parametersEncoderProto13 = exports.entrypointNameDecoderProto13 = exports.entrypointNameEncoderProto13 = exports.entrypointEncoderProto13 = exports.valueParameterDecoderProto13 = exports.parametersDecoderProto13 = void 0;
const utils_1 = require("@taquito/utils");
const codec_1 = require("../codec");
const constants_1 = require("../constants");
const error_1 = require("../error");
const codec_2 = require("../michelson/codec");
const uint8array_consumer_1 = require("../uint8array-consumer");
const utils_2 = require("../utils");
const codec_proto13_1 = require("./michelson-proto13/codec-proto13");
const parametersDecoderProto13 = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = codec_1.entrypointDecoder(val);
        const params = codec_2.extractRequiredLen(val);
        const parameters = codec_proto13_1.valueDecoderProto13(new uint8array_consumer_1.Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
exports.parametersDecoderProto13 = parametersDecoderProto13;
const valueParameterDecoderProto13 = (val) => {
    const value = codec_2.extractRequiredLen(val);
    return codec_proto13_1.valueDecoderProto13(new uint8array_consumer_1.Uint8ArrayConsumer(value));
};
exports.valueParameterDecoderProto13 = valueParameterDecoderProto13;
const entrypointEncoderProto13 = (entrypoint) => {
    if (entrypoint in constants_1.entrypointMappingReverse) {
        return `${constants_1.entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > constants_1.ENTRYPOINT_MAX_LENGTH) {
            throw new error_1.OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${codec_proto13_1.valueEncoderProto13(value).slice(8)}`;
    }
};
exports.entrypointEncoderProto13 = entrypointEncoderProto13;
const entrypointNameEncoderProto13 = (entrypoint) => {
    const value = { string: entrypoint };
    return `${codec_proto13_1.valueEncoderProto13(value).slice(2)}`;
};
exports.entrypointNameEncoderProto13 = entrypointNameEncoderProto13;
const entrypointNameDecoderProto13 = (val) => {
    const entry = codec_2.extractRequiredLen(val);
    return Buffer.from(entry).toString('utf8');
};
exports.entrypointNameDecoderProto13 = entrypointNameDecoderProto13;
const parametersEncoderProto13 = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = exports.entrypointEncoderProto13(val.entrypoint);
    const parameters = codec_proto13_1.valueEncoderProto13(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
exports.parametersEncoderProto13 = parametersEncoderProto13;
const valueParameterEncoderProto13 = (value) => {
    const valueEncoded = codec_proto13_1.valueEncoderProto13(value);
    return `${utils_2.pad(valueEncoded.length / 2)}${valueEncoded}`;
};
exports.valueParameterEncoderProto13 = valueParameterEncoderProto13;
const txRollupOriginationParamEncoderProto13 = (_value) => {
    return '';
};
exports.txRollupOriginationParamEncoderProto13 = txRollupOriginationParamEncoderProto13;
const txRollupOriginationParamDecoderProto13 = (_val) => {
    return {};
};
exports.txRollupOriginationParamDecoderProto13 = txRollupOriginationParamDecoderProto13;
exports.txRollupIdEncoderProto13 = codec_1.prefixEncoder(utils_1.Prefix.TXR1);
exports.txRollupIdDecoderProto13 = codec_1.prefixDecoder(utils_1.Prefix.TXR1);
const txRollupBatchContentEncoderProto13 = (value) => {
    return `${utils_2.pad(value.length / 2)}${value}`;
};
exports.txRollupBatchContentEncoderProto13 = txRollupBatchContentEncoderProto13;
const txRollupBatchContentDecoderProto13 = (val) => {
    const value = codec_2.extractRequiredLen(val);
    return Buffer.from(value).toString('hex');
};
exports.txRollupBatchContentDecoderProto13 = txRollupBatchContentDecoderProto13;
const burnLimitEncoder = (val) => {
    return !val ? '00' : `ff${codec_1.zarithEncoder(val)}`;
};
exports.burnLimitEncoder = burnLimitEncoder;
const burnLimitDecoder = (value) => {
    const prefix = value.consume(1);
    if (Buffer.from(prefix).toString('hex') !== '00') {
        return codec_1.zarithDecoder(value);
    }
};
exports.burnLimitDecoder = burnLimitDecoder;
//# sourceMappingURL=codec-proto13.js.map