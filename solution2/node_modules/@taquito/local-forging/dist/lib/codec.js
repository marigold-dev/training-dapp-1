"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockPayloadHashDecoder = exports.blockPayloadHashEncoder = exports.valueParameterDecoder = exports.valueParameterEncoder = exports.parametersEncoder = exports.entrypointEncoder = exports.parametersDecoder = exports.entrypointDecoder = exports.zarithDecoder = exports.zarithEncoder = exports.addressDecoder = exports.publicKeyDecoder = exports.addressEncoder = exports.publicKeyEncoder = exports.pkhEncoder = exports.delegateDecoder = exports.boolDecoder = exports.int16Decoder = exports.int16Encoder = exports.int32Decoder = exports.int32Encoder = exports.delegateEncoder = exports.ballotDecoder = exports.ballotEncoder = exports.proposalsEncoder = exports.proposalsDecoder = exports.proposalDecoder = exports.proposalEncoder = exports.boolEncoder = exports.tz1Encoder = exports.branchEncoder = exports.pkhDecoder = exports.branchDecoder = exports.tz1Decoder = exports.prefixDecoder = exports.prefixEncoder = void 0;
const utils_1 = require("@taquito/utils");
const error_1 = require("./error");
const bignumber_js_1 = require("bignumber.js");
const constants_1 = require("./constants");
const codec_1 = require("./michelson/codec");
const uint8array_consumer_1 = require("./uint8array-consumer");
const utils_2 = require("./utils");
const prefixEncoder = (prefix) => (str) => {
    return utils_1.buf2hex(Buffer.from(utils_1.b58cdecode(str, utils_1.prefix[prefix])));
};
exports.prefixEncoder = prefixEncoder;
const prefixDecoder = (pre) => (str) => {
    const val = str.consume(utils_1.prefixLength[pre]);
    return utils_1.b58cencode(val, utils_1.prefix[pre]);
};
exports.prefixDecoder = prefixDecoder;
exports.tz1Decoder = exports.prefixDecoder(utils_1.Prefix.TZ1);
exports.branchDecoder = exports.prefixDecoder(utils_1.Prefix.B);
const pkhDecoder = (val) => {
    const prefix = val.consume(1);
    if (prefix[0] === 0x00) {
        return exports.prefixDecoder(utils_1.Prefix.TZ1)(val);
    }
    else if (prefix[0] === 0x01) {
        return exports.prefixDecoder(utils_1.Prefix.TZ2)(val);
    }
    else if (prefix[0] === 0x02) {
        return exports.prefixDecoder(utils_1.Prefix.TZ3)(val);
    }
};
exports.pkhDecoder = pkhDecoder;
exports.branchEncoder = exports.prefixEncoder(utils_1.Prefix.B);
exports.tz1Encoder = exports.prefixEncoder(utils_1.Prefix.TZ1);
const boolEncoder = (bool) => (bool ? 'ff' : '00');
exports.boolEncoder = boolEncoder;
const proposalEncoder = (proposal) => {
    return exports.prefixEncoder(utils_1.Prefix.P)(proposal);
};
exports.proposalEncoder = proposalEncoder;
const proposalDecoder = (proposal) => {
    return exports.prefixDecoder(utils_1.Prefix.P)(proposal);
};
exports.proposalDecoder = proposalDecoder;
const proposalsDecoder = (proposal) => {
    const proposals = [];
    proposal.consume(4);
    while (proposal.length() > 0) {
        proposals.push(exports.proposalDecoder(proposal));
    }
    return proposals;
};
exports.proposalsDecoder = proposalsDecoder;
const proposalsEncoder = (proposals) => {
    return utils_2.pad(32 * proposals.length) + proposals.map((x) => exports.proposalEncoder(x)).join('');
};
exports.proposalsEncoder = proposalsEncoder;
const ballotEncoder = (ballot) => {
    switch (ballot) {
        case 'yay':
            return '00';
        case 'nay':
            return '01';
        case 'pass':
            return '02';
        default:
            throw new error_1.InvalidBallotValueError(ballot);
    }
};
exports.ballotEncoder = ballotEncoder;
const ballotDecoder = (ballot) => {
    const value = ballot.consume(1);
    switch (value[0]) {
        case 0x00:
            return 'yay';
        case 0x01:
            return 'nay';
        case 0x02:
            return 'pass';
        default:
            throw new error_1.DecodeBallotValueError(value[0].toString());
    }
};
exports.ballotDecoder = ballotDecoder;
const delegateEncoder = (val) => {
    if (val) {
        return exports.boolEncoder(true) + exports.pkhEncoder(val);
    }
    else {
        return exports.boolEncoder(false);
    }
};
exports.delegateEncoder = delegateEncoder;
const int32Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 4; i++) {
        const shiftBy = (4 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
exports.int32Encoder = int32Encoder;
const int32Decoder = (val) => {
    const num = val.consume(4);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
exports.int32Decoder = int32Decoder;
const int16Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 2; i++) {
        const shiftBy = (2 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
exports.int16Encoder = int16Encoder;
const int16Decoder = (val) => {
    const num = val.consume(2);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
exports.int16Decoder = int16Decoder;
const boolDecoder = (val) => {
    const bool = val.consume(1);
    return bool[0] === 0xff;
};
exports.boolDecoder = boolDecoder;
const delegateDecoder = (val) => {
    const hasDelegate = exports.boolDecoder(val);
    if (hasDelegate) {
        return exports.pkhDecoder(val);
    }
};
exports.delegateDecoder = delegateDecoder;
const pkhEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case utils_1.Prefix.TZ1:
            return '00' + exports.prefixEncoder(utils_1.Prefix.TZ1)(val);
        case utils_1.Prefix.TZ2:
            return '01' + exports.prefixEncoder(utils_1.Prefix.TZ2)(val);
        case utils_1.Prefix.TZ3:
            return '02' + exports.prefixEncoder(utils_1.Prefix.TZ3)(val);
        default:
            throw new utils_1.InvalidKeyHashError(val);
    }
};
exports.pkhEncoder = pkhEncoder;
const publicKeyEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 4);
    switch (pubkeyPrefix) {
        case utils_1.Prefix.EDPK:
            return '00' + exports.prefixEncoder(utils_1.Prefix.EDPK)(val);
        case utils_1.Prefix.SPPK:
            return '01' + exports.prefixEncoder(utils_1.Prefix.SPPK)(val);
        case utils_1.Prefix.P2PK:
            return '02' + exports.prefixEncoder(utils_1.Prefix.P2PK)(val);
        default:
            throw new utils_1.InvalidPublicKeyError(val);
    }
};
exports.publicKeyEncoder = publicKeyEncoder;
const addressEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case utils_1.Prefix.TZ1:
        case utils_1.Prefix.TZ2:
        case utils_1.Prefix.TZ3:
            return '00' + exports.pkhEncoder(val);
        case utils_1.Prefix.KT1:
            return '01' + exports.prefixEncoder(utils_1.Prefix.KT1)(val) + '00';
        default:
            throw new utils_1.InvalidAddressError(val);
    }
};
exports.addressEncoder = addressEncoder;
const publicKeyDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return exports.prefixDecoder(utils_1.Prefix.EDPK)(val);
        case 0x01:
            return exports.prefixDecoder(utils_1.Prefix.SPPK)(val);
        case 0x02:
            return exports.prefixDecoder(utils_1.Prefix.P2PK)(val);
        default:
            throw new utils_1.InvalidPublicKeyError(val.toString());
    }
};
exports.publicKeyDecoder = publicKeyDecoder;
const addressDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return exports.pkhDecoder(val);
        case 0x01: {
            const address = exports.prefixDecoder(utils_1.Prefix.KT1)(val);
            val.consume(1);
            return address;
        }
        default:
            throw new utils_1.InvalidAddressError(val.toString());
    }
};
exports.addressDecoder = addressDecoder;
const zarithEncoder = (n) => {
    const fn = [];
    let nn = new bignumber_js_1.default(n, 10);
    if (nn.isNaN()) {
        throw new TypeError(`Invalid zarith number ${n}`);
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (nn.lt(128)) {
            if (nn.lt(16))
                fn.push('0');
            fn.push(nn.toString(16));
            break;
        }
        else {
            let b = nn.mod(128);
            nn = nn.minus(b);
            nn = nn.dividedBy(128);
            b = b.plus(128);
            fn.push(b.toString(16));
        }
    }
    return fn.join('');
};
exports.zarithEncoder = zarithEncoder;
const zarithDecoder = (n) => {
    let mostSignificantByte = 0;
    while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
        mostSignificantByte += 1;
    }
    let num = new bignumber_js_1.default(0);
    for (let i = mostSignificantByte; i >= 0; i -= 1) {
        const tmp = n.get(i) & 0x7f;
        num = num.multipliedBy(128);
        num = num.plus(tmp);
    }
    n.consume(mostSignificantByte + 1);
    return new bignumber_js_1.default(num).toString();
};
exports.zarithDecoder = zarithDecoder;
const entrypointDecoder = (value) => {
    const preamble = utils_2.pad(value.consume(1)[0], 2);
    if (preamble in constants_1.entrypointMapping) {
        return constants_1.entrypointMapping[preamble];
    }
    else {
        const entry = codec_1.extractRequiredLen(value, 1);
        const entrypoint = Buffer.from(entry).toString('utf8');
        if (entrypoint.length > constants_1.ENTRYPOINT_MAX_LENGTH) {
            throw new error_1.OversizedEntryPointError(entrypoint);
        }
        return entrypoint;
    }
};
exports.entrypointDecoder = entrypointDecoder;
const parametersDecoder = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = exports.entrypointDecoder(val);
        const params = codec_1.extractRequiredLen(val);
        const parameters = codec_1.valueDecoder(new uint8array_consumer_1.Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
exports.parametersDecoder = parametersDecoder;
const entrypointEncoder = (entrypoint) => {
    if (entrypoint in constants_1.entrypointMappingReverse) {
        return `${constants_1.entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > constants_1.ENTRYPOINT_MAX_LENGTH) {
            throw new error_1.OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${codec_1.valueEncoder(value).slice(8)}`;
    }
};
exports.entrypointEncoder = entrypointEncoder;
const parametersEncoder = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = exports.entrypointEncoder(val.entrypoint);
    const parameters = codec_1.valueEncoder(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
exports.parametersEncoder = parametersEncoder;
const valueParameterEncoder = (value) => {
    const valueEncoded = codec_1.valueEncoder(value);
    return `${utils_2.pad(valueEncoded.length / 2)}${valueEncoded}`;
};
exports.valueParameterEncoder = valueParameterEncoder;
const valueParameterDecoder = (val) => {
    const value = codec_1.extractRequiredLen(val);
    return codec_1.valueDecoder(new uint8array_consumer_1.Uint8ArrayConsumer(value));
};
exports.valueParameterDecoder = valueParameterDecoder;
exports.blockPayloadHashEncoder = exports.prefixEncoder(utils_1.Prefix.VH);
exports.blockPayloadHashDecoder = exports.prefixDecoder(utils_1.Prefix.VH);
//# sourceMappingURL=codec.js.map