import { Prefix, prefixLength, b58cencode, prefix, buf2hex, b58cdecode, InvalidKeyHashError, InvalidPublicKeyError, InvalidAddressError, InvalidOperationKindError, validateBlock, ValidationResult } from '@taquito/utils';
import BigNumber$1, { BigNumber } from 'bignumber.js';

const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
const pad = (num, paddingLen = 8) => {
    return num.toString(16).padStart(paddingLen, '0');
};

/*
 * Some code in this file is originally from sotez
 * Copyright (c) 2018 Andrew Kishino
 */
// See: https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
const ENTRYPOINT_MAX_LENGTH = 31;
var CODEC;
(function (CODEC) {
    CODEC["SECRET"] = "secret";
    CODEC["RAW"] = "raw";
    CODEC["TZ1"] = "tz1";
    CODEC["BRANCH"] = "branch";
    CODEC["ZARITH"] = "zarith";
    CODEC["PUBLIC_KEY"] = "public_key";
    CODEC["PKH"] = "pkh";
    CODEC["DELEGATE"] = "delegate";
    CODEC["SCRIPT"] = "script";
    CODEC["BALLOT_STATEMENT"] = "ballotStmt";
    CODEC["PROPOSAL"] = "proposal";
    CODEC["PROPOSAL_ARR"] = "proposalArr";
    CODEC["INT32"] = "int32";
    CODEC["INT16"] = "int16";
    CODEC["PARAMETERS"] = "parameters";
    CODEC["ADDRESS"] = "address";
    CODEC["VALUE"] = "value";
    CODEC["MANAGER"] = "manager";
    CODEC["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
    CODEC["ENTRYPOINT"] = "entrypoint";
    CODEC["OPERATION"] = "operation";
    CODEC["OP_ACTIVATE_ACCOUNT"] = "activate_account";
    CODEC["OP_DELEGATION"] = "delegation";
    CODEC["OP_TRANSACTION"] = "transaction";
    CODEC["OP_ORIGINATION"] = "origination";
    CODEC["OP_BALLOT"] = "ballot";
    CODEC["OP_ENDORSEMENT"] = "endorsement";
    CODEC["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
    CODEC["OP_REVEAL"] = "reveal";
    CODEC["OP_PROPOSALS"] = "proposals";
    CODEC["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
    CODEC["OP_TRANSFER_TICKET"] = "transfer_ticket";
    CODEC["OP_TX_ROLLUP_ORIGINATION"] = "tx_rollup_origination";
    CODEC["OP_TX_ROLLUP_SUBMIT_BATCH"] = "tx_rollup_submit_batch";
    CODEC["BURN_LIMIT"] = "burn_limit";
    CODEC["TX_ROLLUP_ORIGINATION_PARAM"] = "tx_rollup_origination_param";
    CODEC["TX_ROLLUP_ID"] = "tx_rollup_id";
    CODEC["TX_ROLLUP_BATCH_CONTENT"] = "tx_rollup_batch_content";
})(CODEC || (CODEC = {}));
// See https://tezos.gitlab.io/whitedoc/michelson.html#full-grammar
const opMapping = {
    '00': 'parameter',
    '01': 'storage',
    '02': 'code',
    '03': 'False',
    '04': 'Elt',
    '05': 'Left',
    '06': 'None',
    '07': 'Pair',
    '08': 'Right',
    '09': 'Some',
    '0a': 'True',
    '0b': 'Unit',
    '0c': 'PACK',
    '0d': 'UNPACK',
    '0e': 'BLAKE2B',
    '0f': 'SHA256',
    '10': 'SHA512',
    '11': 'ABS',
    '12': 'ADD',
    '13': 'AMOUNT',
    '14': 'AND',
    '15': 'BALANCE',
    '16': 'CAR',
    '17': 'CDR',
    '18': 'CHECK_SIGNATURE',
    '19': 'COMPARE',
    '1a': 'CONCAT',
    '1b': 'CONS',
    '1c': 'CREATE_ACCOUNT',
    '1d': 'CREATE_CONTRACT',
    '1e': 'IMPLICIT_ACCOUNT',
    '1f': 'DIP',
    '20': 'DROP',
    '21': 'DUP',
    '22': 'EDIV',
    '23': 'EMPTY_MAP',
    '24': 'EMPTY_SET',
    '25': 'EQ',
    '26': 'EXEC',
    '27': 'FAILWITH',
    '28': 'GE',
    '29': 'GET',
    '2a': 'GT',
    '2b': 'HASH_KEY',
    '2c': 'IF',
    '2d': 'IF_CONS',
    '2e': 'IF_LEFT',
    '2f': 'IF_NONE',
    '30': 'INT',
    '31': 'LAMBDA',
    '32': 'LE',
    '33': 'LEFT',
    '34': 'LOOP',
    '35': 'LSL',
    '36': 'LSR',
    '37': 'LT',
    '38': 'MAP',
    '39': 'MEM',
    '3a': 'MUL',
    '3b': 'NEG',
    '3c': 'NEQ',
    '3d': 'NIL',
    '3e': 'NONE',
    '3f': 'NOT',
    '40': 'NOW',
    '41': 'OR',
    '42': 'PAIR',
    '43': 'PUSH',
    '44': 'RIGHT',
    '45': 'SIZE',
    '46': 'SOME',
    '47': 'SOURCE',
    '48': 'SENDER',
    '49': 'SELF',
    '4a': 'STEPS_TO_QUOTA',
    '4b': 'SUB',
    '4c': 'SWAP',
    '4d': 'TRANSFER_TOKENS',
    '4e': 'SET_DELEGATE',
    '4f': 'UNIT',
    '50': 'UPDATE',
    '51': 'XOR',
    '52': 'ITER',
    '53': 'LOOP_LEFT',
    '54': 'ADDRESS',
    '55': 'CONTRACT',
    '56': 'ISNAT',
    '57': 'CAST',
    '58': 'RENAME',
    '59': 'bool',
    '5a': 'contract',
    '5b': 'int',
    '5c': 'key',
    '5d': 'key_hash',
    '5e': 'lambda',
    '5f': 'list',
    '60': 'map',
    '61': 'big_map',
    '62': 'nat',
    '63': 'option',
    '64': 'or',
    '65': 'pair',
    '66': 'set',
    '67': 'signature',
    '68': 'string',
    '69': 'bytes',
    '6a': 'mutez',
    '6b': 'timestamp',
    '6c': 'unit',
    '6d': 'operation',
    '6e': 'address',
    '6f': 'SLICE',
    '70': 'DIG',
    '71': 'DUG',
    '72': 'EMPTY_BIG_MAP',
    '73': 'APPLY',
    '74': 'chain_id',
    '75': 'CHAIN_ID',
    '76': 'LEVEL',
    '77': 'SELF_ADDRESS',
    '78': 'never',
    '79': 'NEVER',
    '7a': 'UNPAIR',
    '7b': 'VOTING_POWER',
    '7c': 'TOTAL_VOTING_POWER',
    '7d': 'KECCAK',
    '7e': 'SHA3',
    '7f': 'PAIRING_CHECK',
    '80': 'bls12_381_g1',
    '81': 'bls12_381_g2',
    '82': 'bls12_381_fr',
    '83': 'sapling_state',
    '84': 'sapling_transaction',
    '85': 'SAPLING_EMPTY_STATE',
    '86': 'SAPLING_VERIFY_UPDATE',
    '87': 'ticket',
    '88': 'TICKET',
    '89': 'READ_TICKET',
    '8a': 'SPLIT_TICKET',
    '8b': 'JOIN_TICKETS',
    '8c': 'GET_AND_UPDATE',
    '8d': 'chest',
    '8e': 'chest_key',
    '8f': 'OPEN_CHEST',
    '90': 'VIEW',
    '91': 'view',
    '92': 'constant',
    '93': 'SUB_MUTEZ',
};
const opMappingReverse = (() => {
    const result = {};
    Object.keys(opMapping).forEach((key) => {
        result[opMapping[key]] = key;
    });
    return result;
})();
// See https://tezos.gitlab.io/api/p2p.html
const kindMapping = {
    0x04: 'activate_account',
    0x6b: 'reveal',
    0x6e: 'delegation',
    0x6c: 'transaction',
    0x6d: 'origination',
    0x06: 'ballot',
    0x15: 'endorsement',
    0x01: 'seed_nonce_revelation',
    0x05: 'proposals',
    0x6f: 'register_global_constant',
    0x96: 'tx_rollup_origination',
    0x97: 'tx_rollup_submit_batch',
    0x9e: 'transfer_ticket',
};
const kindMappingReverse = (() => {
    const result = {};
    Object.keys(kindMapping).forEach((key) => {
        const keyNum = typeof key === 'string' ? parseInt(key, 10) : key;
        result[kindMapping[keyNum]] = pad(keyNum, 2);
    });
    return result;
})();
// See https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
const entrypointMapping = {
    '00': 'default',
    '01': 'root',
    '02': 'do',
    '03': 'set_delegate',
    '04': 'remove_delegate',
};
const entrypointMappingReverse = (() => {
    const result = {};
    Object.keys(entrypointMapping).forEach((key) => {
        result[entrypointMapping[key]] = key;
    });
    return result;
})();

/**
 *  @category Error
 *  @description Error that indicates an invalid block hash being passed or used
 */
class InvalidBlockHashError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'InvalidBlockHashError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid operation schema being passed or used
 */ class InvalidOperationSchemaError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'InvalidOperationSchemaError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an entrypoint exceeding maximum size
 */
class OversizedEntryPointError extends Error {
    constructor(entrypoint) {
        super(`Oversized entrypoint: ${entrypoint}. The maximum length of entrypoint is ${ENTRYPOINT_MAX_LENGTH}`);
        this.entrypoint = entrypoint;
        this.name = 'OversizedEntryPointError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid ballot value
 */
class InvalidBallotValueError extends Error {
    constructor(ballotValue) {
        super(`The ballot value '${ballotValue}' is invalid`);
        this.ballotValue = ballotValue;
        this.name = 'InvalidBallotValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to decode ballot value
 */
class DecodeBallotValueError extends Error {
    constructor(ballotValue) {
        super(`Failed to decode ballot value ${ballotValue}`);
        this.ballotValue = ballotValue;
        this.name = 'DecodeBallotValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid hex string have been passed or used
 */
class InvalidHexStringError extends Error {
    constructor(hexString) {
        super(`The hex string '${hexString}' is invalid`);
        this.hexString = hexString;
        this.name = 'InvalidHexStringError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates unexpected Michelson Value being passed or used
 */
class UnexpectedMichelsonValueError extends Error {
    constructor(value) {
        super(`Failed to encode michelson value '${value}'`);
        this.value = value;
        this.name = 'UnexpectedMichelsonValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to decode an operation
 */
class OperationDecodingError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'OperationDecodingError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to encode an operation
 */
class OperationEncodingError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'OperationEncodingError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an unsupported operation being passed or used
 */
class UnsupportedOperationError extends Error {
    constructor(op) {
        super(`The operation '${op}' is unsupported`);
        this.op = op;
        this.name = 'UnsupportedOperationError';
    }
}

class Uint8ArrayConsumer {
    constructor(arr, offset = 0) {
        this.arr = arr;
        this.offset = offset;
    }
    static fromHexString(hex) {
        const lowHex = hex.toLowerCase();
        if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
            const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
            return new Uint8ArrayConsumer(arr);
        }
        else {
            throw new InvalidHexStringError(lowHex);
        }
    }
    consume(count) {
        const subArr = this.arr.subarray(this.offset, this.offset + count);
        this.offset += count;
        return subArr;
    }
    get(idx) {
        return this.arr[this.offset + idx];
    }
    length() {
        return this.arr.length - this.offset;
    }
}

const isPrim = (value) => {
    return 'prim' in value;
};
const isBytes = (value) => {
    return 'bytes' in value && typeof value.bytes === 'string';
};
const isString = (value) => {
    return 'string' in value && typeof value.string === 'string';
};
const isInt = (value) => {
    return 'int' in value && typeof value.int === 'string';
};
const scriptEncoder = (script) => {
    const code = valueEncoder(script.code);
    const storage = valueEncoder(script.storage);
    return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoder = (value) => {
    const code = extractRequiredLen(value);
    const storage = extractRequiredLen(value);
    return {
        code: valueDecoder(new Uint8ArrayConsumer(code)),
        storage: valueDecoder(new Uint8ArrayConsumer(storage)),
    };
};
const valueEncoder = (value) => {
    if (Array.isArray(value)) {
        const encoded = value.map((x) => valueEncoder(x)).join('');
        const len = encoded.length / 2;
        return `02${pad(len)}${encoded}`;
    }
    else if (isPrim(value)) {
        return primEncoder(value);
    }
    else if (isBytes(value)) {
        return bytesEncoder(value);
    }
    else if (isString(value)) {
        return stringEncoder(value);
    }
    else if (isInt(value)) {
        return intEncoder(value);
    }
    throw new UnexpectedMichelsonValueError(value);
};
const valueDecoder = (value) => {
    const preamble = value.consume(1);
    switch (preamble[0]) {
        case 0x0a:
            return bytesDecoder(value);
        case 0x01:
            return stringDecoder(value);
        case 0x00:
            return intDecoder(value);
        case 0x02: {
            const val = new Uint8ArrayConsumer(extractRequiredLen(value));
            const results = [];
            while (val.length() > 0) {
                results.push(valueDecoder(val));
            }
            return results;
        }
        default:
            return primDecoder(value, preamble);
    }
};
const extractRequiredLen = (value, bytesLength = 4) => {
    const len = value.consume(bytesLength);
    const valueLen = parseInt(Buffer.from(len).toString('hex'), 16);
    return value.consume(valueLen);
};
const bytesEncoder = (value) => {
    if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
        throw new InvalidHexStringError(value.bytes);
    }
    const len = value.bytes.length / 2;
    return `0a${pad(len)}${value.bytes}`;
};
const bytesDecoder = (value) => {
    const bytes = extractRequiredLen(value);
    return {
        bytes: Buffer.from(bytes).toString('hex'),
    };
};
const stringEncoder = (value) => {
    const str = Buffer.from(value.string, 'utf8').toString('hex');
    const hexLength = str.length / 2;
    return `01${pad(hexLength)}${str}`;
};
const stringDecoder = (value) => {
    const str = extractRequiredLen(value);
    return {
        string: Buffer.from(str).toString('utf8'),
    };
};
const intEncoder = ({ int }) => {
    const num = new BigNumber(int, 10);
    const positiveMark = num.toString(2)[0] === '-' ? '1' : '0';
    const binary = num.toString(2).replace(/-/g, '');
    const pad = binary.length <= 6
        ? 6
        : (binary.length - 6) % 7
            ? binary.length + 7 - ((binary.length - 6) % 7)
            : binary.length;
    const splitted = binary.padStart(pad, '0').match(/\d{6,7}/g);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const reversed = splitted.reverse();
    reversed[0] = positiveMark + reversed[0];
    const numHex = reversed.map((x, i) => 
    // Add one to the last chunk
    parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)
        .toString(16)
        .padStart(2, '0'));
    return `00${numHex.join('')}`;
};
const intDecoder = (value) => {
    let c = value.consume(1)[0];
    const hexNumber = [];
    const isNotLastChunkMask = 1 << 7;
    while (c & isNotLastChunkMask) {
        hexNumber.push(c);
        c = value.consume(1)[0];
    }
    hexNumber.push(c);
    const isNegative = !!((1 << 6) & hexNumber[0]);
    hexNumber[0] = hexNumber[0] & 0b1111111;
    const numBin = hexNumber
        .map((x, i) => x
        .toString(2)
        .slice(i === 0 ? -6 : -7)
        .padStart(i === 0 ? 6 : 7, '0'))
        .reverse();
    let num = new BigNumber(numBin.join(''), 2);
    if (isNegative) {
        num = num.times(-1);
    }
    return {
        int: num.toFixed(),
    };
};
const primEncoder = (value) => {
    const hasAnnot = +Array.isArray(value.annots);
    const argsCount = Array.isArray(value.args) ? value.args.length : 0;
    // Specify the number of args max is 3 without annotation
    const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
    const op = opMappingReverse[value.prim];
    let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join('');
    const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
    if (value.prim === 'LAMBDA' && argsCount) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
        encodedArgs =
            encodedAnnots === ''
                ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                : pad(encodedArgs.length / 2) + encodedArgs;
    }
    if (value.prim === 'view' && value.args) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoder = (value, preamble) => {
    const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
    let argsCount = Math.floor((preamble[0] - 0x03) / 2);
    const op = value.consume(1)[0].toString(16).padStart(2, '0');
    const result = {
        prim: opMapping[op],
    };
    if (opMapping[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (opMapping[op] === 'view') {
        if (argsCount != 0) {
            return primViewDecoder(value, result);
        }
        else {
            return result;
        }
    }
    let combPairArgs;
    let combPairAnnots;
    if ((opMapping[op] === 'pair' || opMapping[op] === 'Pair') && argsCount > 2) {
        combPairArgs = decodeCombPair$1(value);
        argsCount = 0;
        combPairAnnots = decodeAnnots(value);
    }
    const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
    if (opMapping[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (combPairArgs) {
        result['args'] = combPairArgs;
    }
    else if (args.length) {
        result['args'] = args;
    }
    if (combPairAnnots && combPairAnnots[0] !== '') {
        result['annots'] = combPairAnnots;
    }
    else if (hasAnnot) {
        result['annots'] = decodeAnnots(value);
    }
    return result;
};
const primViewDecoder = (value, result) => {
    value.consume(4);
    result['args'] = new Array(4).fill(0).map(() => valueDecoder(value));
    value.consume(4);
    return result;
};
const decodeCombPair$1 = (val) => {
    const array = new Uint8ArrayConsumer(extractRequiredLen(val));
    const args = [];
    while (array.length() > 0) {
        args.push(valueDecoder(array));
    }
    return args;
};
const encodeAnnots = (value) => {
    const mergedAnnot = value
        .map((x) => {
        return Buffer.from(x, 'utf8').toString('hex');
    })
        .join('20');
    const len = mergedAnnot.length / 2;
    return `${pad(len)}${mergedAnnot}`;
};
const decodeAnnots = (val) => {
    const len = val.consume(4);
    const annotLen = parseInt(Buffer.from(len).toString('hex'), 16);
    const restOfAnnot = val.consume(annotLen);
    const restOfAnnotHex = Buffer.from(restOfAnnot).toString('hex');
    return restOfAnnotHex.split('20').map((x) => Buffer.from(x, 'hex').toString('utf8'));
};

const prefixEncoder = (prefix$1) => (str) => {
    return buf2hex(Buffer.from(b58cdecode(str, prefix[prefix$1])));
};
const prefixDecoder = (pre) => (str) => {
    const val = str.consume(prefixLength[pre]);
    return b58cencode(val, prefix[pre]);
};
const tz1Decoder = prefixDecoder(Prefix.TZ1);
const branchDecoder = prefixDecoder(Prefix.B);
const pkhDecoder = (val) => {
    const prefix = val.consume(1);
    if (prefix[0] === 0x00) {
        return prefixDecoder(Prefix.TZ1)(val);
    }
    else if (prefix[0] === 0x01) {
        return prefixDecoder(Prefix.TZ2)(val);
    }
    else if (prefix[0] === 0x02) {
        return prefixDecoder(Prefix.TZ3)(val);
    }
};
const branchEncoder = prefixEncoder(Prefix.B);
const tz1Encoder = prefixEncoder(Prefix.TZ1);
const boolEncoder = (bool) => (bool ? 'ff' : '00');
const proposalEncoder = (proposal) => {
    return prefixEncoder(Prefix.P)(proposal);
};
const proposalDecoder = (proposal) => {
    return prefixDecoder(Prefix.P)(proposal);
};
const proposalsDecoder = (proposal) => {
    const proposals = [];
    proposal.consume(4);
    while (proposal.length() > 0) {
        proposals.push(proposalDecoder(proposal));
    }
    return proposals;
};
const proposalsEncoder = (proposals) => {
    return pad(32 * proposals.length) + proposals.map((x) => proposalEncoder(x)).join('');
};
const ballotEncoder = (ballot) => {
    switch (ballot) {
        case 'yay':
            return '00';
        case 'nay':
            return '01';
        case 'pass':
            return '02';
        default:
            throw new InvalidBallotValueError(ballot);
    }
};
const ballotDecoder = (ballot) => {
    const value = ballot.consume(1);
    switch (value[0]) {
        case 0x00:
            return 'yay';
        case 0x01:
            return 'nay';
        case 0x02:
            return 'pass';
        default:
            throw new DecodeBallotValueError(value[0].toString());
    }
};
const delegateEncoder = (val) => {
    if (val) {
        return boolEncoder(true) + pkhEncoder(val);
    }
    else {
        return boolEncoder(false);
    }
};
const int32Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 4; i++) {
        const shiftBy = (4 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
const int32Decoder = (val) => {
    const num = val.consume(4);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
const int16Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 2; i++) {
        const shiftBy = (2 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
const int16Decoder = (val) => {
    const num = val.consume(2);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
const boolDecoder = (val) => {
    const bool = val.consume(1);
    return bool[0] === 0xff;
};
const delegateDecoder = (val) => {
    const hasDelegate = boolDecoder(val);
    if (hasDelegate) {
        return pkhDecoder(val);
    }
};
const pkhEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case Prefix.TZ1:
            return '00' + prefixEncoder(Prefix.TZ1)(val);
        case Prefix.TZ2:
            return '01' + prefixEncoder(Prefix.TZ2)(val);
        case Prefix.TZ3:
            return '02' + prefixEncoder(Prefix.TZ3)(val);
        default:
            throw new InvalidKeyHashError(val);
    }
};
const publicKeyEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 4);
    switch (pubkeyPrefix) {
        case Prefix.EDPK:
            return '00' + prefixEncoder(Prefix.EDPK)(val);
        case Prefix.SPPK:
            return '01' + prefixEncoder(Prefix.SPPK)(val);
        case Prefix.P2PK:
            return '02' + prefixEncoder(Prefix.P2PK)(val);
        default:
            throw new InvalidPublicKeyError(val);
    }
};
const addressEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case Prefix.TZ1:
        case Prefix.TZ2:
        case Prefix.TZ3:
            return '00' + pkhEncoder(val);
        case Prefix.KT1:
            return '01' + prefixEncoder(Prefix.KT1)(val) + '00';
        default:
            throw new InvalidAddressError(val);
    }
};
const publicKeyDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return prefixDecoder(Prefix.EDPK)(val);
        case 0x01:
            return prefixDecoder(Prefix.SPPK)(val);
        case 0x02:
            return prefixDecoder(Prefix.P2PK)(val);
        default:
            throw new InvalidPublicKeyError(val.toString());
    }
};
const addressDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return pkhDecoder(val);
        case 0x01: {
            const address = prefixDecoder(Prefix.KT1)(val);
            val.consume(1);
            return address;
        }
        default:
            throw new InvalidAddressError(val.toString());
    }
};
const zarithEncoder = (n) => {
    const fn = [];
    let nn = new BigNumber$1(n, 10);
    if (nn.isNaN()) {
        throw new TypeError(`Invalid zarith number ${n}`);
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (nn.lt(128)) {
            if (nn.lt(16))
                fn.push('0');
            fn.push(nn.toString(16));
            break;
        }
        else {
            let b = nn.mod(128);
            nn = nn.minus(b);
            nn = nn.dividedBy(128);
            b = b.plus(128);
            fn.push(b.toString(16));
        }
    }
    return fn.join('');
};
const zarithDecoder = (n) => {
    let mostSignificantByte = 0;
    while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
        mostSignificantByte += 1;
    }
    let num = new BigNumber$1(0);
    for (let i = mostSignificantByte; i >= 0; i -= 1) {
        const tmp = n.get(i) & 0x7f;
        num = num.multipliedBy(128);
        num = num.plus(tmp);
    }
    n.consume(mostSignificantByte + 1);
    return new BigNumber$1(num).toString();
};
const entrypointDecoder = (value) => {
    const preamble = pad(value.consume(1)[0], 2);
    if (preamble in entrypointMapping) {
        return entrypointMapping[preamble];
    }
    else {
        const entry = extractRequiredLen(value, 1);
        const entrypoint = Buffer.from(entry).toString('utf8');
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        return entrypoint;
    }
};
const parametersDecoder = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = entrypointDecoder(val);
        const params = extractRequiredLen(val);
        const parameters = valueDecoder(new Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
const entrypointEncoder = (entrypoint) => {
    if (entrypoint in entrypointMappingReverse) {
        return `${entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${valueEncoder(value).slice(8)}`;
    }
};
const parametersEncoder = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = entrypointEncoder(val.entrypoint);
    const parameters = valueEncoder(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoder = (value) => {
    const valueEncoded = valueEncoder(value);
    return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
const valueParameterDecoder = (val) => {
    const value = extractRequiredLen(val);
    return valueDecoder(new Uint8ArrayConsumer(value));
};
const blockPayloadHashEncoder = prefixEncoder(Prefix.VH);
const blockPayloadHashDecoder = prefixDecoder(Prefix.VH);

const ManagerOperationSchema = {
    branch: CODEC.BRANCH,
    contents: [CODEC.OPERATION],
};
const ActivationSchema = {
    pkh: CODEC.TZ1,
    secret: CODEC.SECRET,
};
const RevealSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    public_key: CODEC.PUBLIC_KEY,
};
const DelegationSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    delegate: CODEC.DELEGATE,
};
const TransactionSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    amount: CODEC.ZARITH,
    destination: CODEC.ADDRESS,
    parameters: CODEC.PARAMETERS,
};
const OriginationSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    balance: CODEC.ZARITH,
    delegate: CODEC.DELEGATE,
    script: CODEC.SCRIPT,
};
const BallotSchema = {
    source: CODEC.PKH,
    period: CODEC.INT32,
    proposal: CODEC.PROPOSAL,
    ballot: CODEC.BALLOT_STATEMENT,
};
const EndorsementSchema = {
    slot: CODEC.INT16,
    level: CODEC.INT32,
    round: CODEC.INT32,
    block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH,
};
const SeedNonceRevelationSchema = {
    level: CODEC.INT32,
    nonce: CODEC.RAW,
};
const ProposalsSchema = {
    source: CODEC.PKH,
    period: CODEC.INT32,
    proposals: CODEC.PROPOSAL_ARR,
};
const RegisterGlobalConstantSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    value: CODEC.VALUE,
};
const operationEncoder = (encoders) => (operation) => {
    if (!(operation.kind in encoders) || !(operation.kind in kindMappingReverse)) {
        throw new InvalidOperationKindError(operation.kind);
    }
    return kindMappingReverse[operation.kind] + encoders[operation.kind](operation);
};
const operationDecoder = (decoders) => (value) => {
    const op = value.consume(1);
    const operationName = kindMapping[op[0]];
    if (operationName === undefined) {
        throw new UnsupportedOperationError(op[0].toString());
    }
    const decodedObj = decoders[operationName](value);
    if (typeof decodedObj !== 'object') {
        throw new OperationDecodingError('Decoded invalid operation');
    }
    return Object.assign({ kind: operationName }, decodedObj);
};
const schemaEncoder = (encoders) => (schema) => (value) => {
    const keys = Object.keys(schema);
    return keys.reduce((prev, key) => {
        const valueToEncode = schema[key];
        if (value && Array.isArray(valueToEncode)) {
            const encoder = encoders[valueToEncode[0]];
            const values = value[key];
            if (!Array.isArray(values)) {
                throw new OperationEncodingError(`Expected value to be Array ${JSON.stringify(values)}`);
            }
            return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), '');
        }
        else {
            const encoder = encoders[valueToEncode];
            return prev + encoder(value[key]);
        }
    }, '');
};
const schemaDecoder = (decoders) => (schema) => (value) => {
    const keys = Object.keys(schema);
    return keys.reduce((prev, key) => {
        const valueToEncode = schema[key];
        if (Array.isArray(valueToEncode)) {
            const decoder = decoders[valueToEncode[0]];
            const decoded = [];
            const lastLength = value.length();
            while (value.length() > 0) {
                decoded.push(decoder(value));
                if (lastLength === value.length()) {
                    throw new OperationDecodingError('Unable to decode value');
                }
            }
            return Object.assign(Object.assign({}, prev), { [key]: decoded });
        }
        else {
            const decoder = decoders[valueToEncode];
            const result = decoder(value);
            if (typeof result !== 'undefined') {
                return Object.assign(Object.assign({}, prev), { [key]: result });
            }
            else {
                return Object.assign({}, prev);
            }
        }
    }, {});
};

const decoders = {
    [CODEC.SECRET]: (val) => toHexString(val.consume(20)),
    [CODEC.RAW]: (val) => toHexString(val.consume(32)),
    [CODEC.TZ1]: tz1Decoder,
    [CODEC.BRANCH]: branchDecoder,
    [CODEC.ZARITH]: zarithDecoder,
    [CODEC.PUBLIC_KEY]: publicKeyDecoder,
    [CODEC.PKH]: pkhDecoder,
    [CODEC.DELEGATE]: delegateDecoder,
    [CODEC.INT32]: int32Decoder,
    [CODEC.SCRIPT]: scriptDecoder,
    [CODEC.BALLOT_STATEMENT]: ballotDecoder,
    [CODEC.PROPOSAL]: proposalDecoder,
    [CODEC.PROPOSAL_ARR]: proposalsDecoder,
    [CODEC.PARAMETERS]: parametersDecoder,
    [CODEC.ADDRESS]: addressDecoder,
    [CODEC.VALUE]: valueParameterDecoder,
    [CODEC.INT16]: int16Decoder,
    [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,
};
decoders[CODEC.OPERATION] = operationDecoder(decoders);
decoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
decoders[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
decoders[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
decoders[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
decoders[CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
decoders[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
decoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
decoders[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
decoders[CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
decoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
decoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);

const encoders = {
    [CODEC.SECRET]: (val) => val,
    [CODEC.RAW]: (val) => val,
    [CODEC.TZ1]: tz1Encoder,
    [CODEC.BRANCH]: branchEncoder,
    [CODEC.ZARITH]: zarithEncoder,
    [CODEC.PUBLIC_KEY]: publicKeyEncoder,
    [CODEC.PKH]: pkhEncoder,
    [CODEC.DELEGATE]: delegateEncoder,
    [CODEC.SCRIPT]: scriptEncoder,
    [CODEC.BALLOT_STATEMENT]: ballotEncoder,
    [CODEC.PROPOSAL]: proposalEncoder,
    [CODEC.PROPOSAL_ARR]: proposalsEncoder,
    [CODEC.INT32]: int32Encoder,
    [CODEC.PARAMETERS]: parametersEncoder,
    [CODEC.ADDRESS]: addressEncoder,
    [CODEC.VALUE]: valueParameterEncoder,
    [CODEC.INT16]: int16Encoder,
    [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,
};
encoders[CODEC.OPERATION] = operationEncoder(encoders);
encoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
encoders[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
encoders[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
encoders[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
encoders[CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
encoders[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
encoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
encoders[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
encoders[CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
encoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
encoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);

const TransferTicketSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    ticket_contents: CODEC.VALUE,
    ticket_ty: CODEC.VALUE,
    ticket_ticketer: CODEC.ADDRESS,
    ticket_amount: CODEC.ZARITH,
    destination: CODEC.ADDRESS,
    entrypoint: CODEC.ENTRYPOINT,
};
const TxRollupOriginationSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    tx_rollup_origination: CODEC.TX_ROLLUP_ORIGINATION_PARAM,
};
const TxRollupSubmitBatchSchema = {
    source: CODEC.PKH,
    fee: CODEC.ZARITH,
    counter: CODEC.ZARITH,
    gas_limit: CODEC.ZARITH,
    storage_limit: CODEC.ZARITH,
    rollup: CODEC.TX_ROLLUP_ID,
    content: CODEC.TX_ROLLUP_BATCH_CONTENT,
    burn_limit: CODEC.BURN_LIMIT,
};

const OperationKindMapping = {
    activate_account: ActivationSchema,
    reveal: RevealSchema,
    delegation: DelegationSchema,
    transaction: TransactionSchema,
    origination: OriginationSchema,
    ballot: BallotSchema,
    endorsement: EndorsementSchema,
    seed_nonce_revelation: SeedNonceRevelationSchema,
    proposals: ProposalsSchema,
    register_global_constant: RegisterGlobalConstantSchema,
    transfer_ticket: TransferTicketSchema,
    tx_rollup_origination: TxRollupOriginationSchema,
    tx_rollup_submit_batch: TxRollupSubmitBatchSchema,
};
// Asymmetric difference: only account for things in arr2 that are not present in arr1, not vice versa
const getArrayDifference = (arr1, arr2) => {
    return arr2.filter((x) => !arr1.includes(x));
};
const deleteArrayElementByValue = (array, item) => {
    return array.filter((e) => e !== item);
};
/**
 * @returns A boolean value to indicate whether the operation kind is valid or not
 */
const validateOperationKind = (opKind) => {
    const opKindList = Object.keys(OperationKindMapping);
    return opKindList.includes(opKind);
};
/**
 *  returns 0 when the two array of properties are identical or the passed property
 *  does not have any missing parameters from the corresponding schema
 *
 *  @returns array element differences if there are missing required property keys
 */
const validateMissingProperty = (operationContent) => {
    const kind = operationContent.kind;
    const keys = Object.keys(operationContent);
    const cleanKeys = deleteArrayElementByValue(keys, 'kind');
    const schemaKeys = Object.keys(OperationKindMapping[kind]);
    return getArrayDifference(cleanKeys, schemaKeys);
};

var ProtocolsHash;
(function (ProtocolsHash) {
    ProtocolsHash["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
    ProtocolsHash["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
    ProtocolsHash["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
    ProtocolsHash["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
    ProtocolsHash["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
    ProtocolsHash["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
    ProtocolsHash["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
    ProtocolsHash["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
    ProtocolsHash["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
    ProtocolsHash["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
    ProtocolsHash["PtJakart2"] = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY";
    ProtocolsHash["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(ProtocolsHash || (ProtocolsHash = {}));
const protoLevel = {
    Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
    PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
    PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
    PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
    PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
    PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
    PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
    PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
    PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
    Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
    PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,
    ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 14,
};
function ProtoInferiorTo(a, b) {
    return protoLevel[a] < protoLevel[b];
}

const opMappingProto13 = Object.assign(Object.assign({}, opMapping), { '84': 'sapling_transaction_deprecated', '94': 'tx_rollup_l2_address', '95': 'MIN_BLOCK_TIME', '96': 'sapling_transaction' });
const opMappingReverseProto13 = (() => {
    const result = {};
    Object.keys(opMappingProto13).forEach((key) => {
        result[opMappingProto13[key]] = key;
    });
    return result;
})();

const scriptEncoderProto13 = (script) => {
    const code = valueEncoderProto13(script.code);
    const storage = valueEncoderProto13(script.storage);
    return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoderProto13 = (value) => {
    const code = extractRequiredLen(value);
    const storage = extractRequiredLen(value);
    return {
        code: valueDecoderProto13(new Uint8ArrayConsumer(code)),
        storage: valueDecoderProto13(new Uint8ArrayConsumer(storage)),
    };
};
const valueEncoderProto13 = (value) => {
    if (Array.isArray(value)) {
        const encoded = value.map((x) => valueEncoderProto13(x)).join('');
        const len = encoded.length / 2;
        return `02${pad(len)}${encoded}`;
    }
    else if (isPrim(value)) {
        return primEncoderProto13(value);
    }
    else if (isBytes(value)) {
        return bytesEncoder(value);
    }
    else if (isString(value)) {
        return stringEncoder(value);
    }
    else if (isInt(value)) {
        return intEncoder(value);
    }
    throw new UnexpectedMichelsonValueError('Unexpected value');
};
const valueDecoderProto13 = (value) => {
    const preamble = value.consume(1);
    switch (preamble[0]) {
        case 0x0a:
            return bytesDecoder(value);
        case 0x01:
            return stringDecoder(value);
        case 0x00:
            return intDecoder(value);
        case 0x02: {
            const val = new Uint8ArrayConsumer(extractRequiredLen(value));
            const results = [];
            while (val.length() > 0) {
                results.push(valueDecoderProto13(val));
            }
            return results;
        }
        default:
            return primDecoderProto13(value, preamble);
    }
};
const primEncoderProto13 = (value) => {
    const hasAnnot = +Array.isArray(value.annots);
    const argsCount = Array.isArray(value.args) ? value.args.length : 0;
    // Specify the number of args max is 3 without annotation
    const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
    const op = opMappingReverseProto13[value.prim];
    let encodedArgs = (value.args || []).map((arg) => valueEncoderProto13(arg)).join('');
    const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
    if (value.prim === 'LAMBDA' && argsCount) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
        encodedArgs =
            encodedAnnots === ''
                ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                : pad(encodedArgs.length / 2) + encodedArgs;
    }
    if (value.prim === 'view' && value.args) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoderProto13 = (value, preamble) => {
    const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
    let argsCount = Math.floor((preamble[0] - 0x03) / 2);
    const op = value.consume(1)[0].toString(16).padStart(2, '0');
    const result = {
        prim: opMappingProto13[op],
    };
    if (opMappingProto13[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (opMappingProto13[op] === 'view') {
        if (argsCount != 0) {
            return primViewDecoderProto13(value, result);
        }
        else {
            return result;
        }
    }
    let combPairArgs;
    let combPairAnnots;
    if ((opMappingProto13[op] === 'pair' || opMappingProto13[op] === 'Pair') && argsCount > 2) {
        combPairArgs = decodeCombPair(value);
        argsCount = 0;
        combPairAnnots = decodeAnnots(value);
    }
    const args = new Array(argsCount).fill(0).map(() => valueDecoderProto13(value));
    if (opMappingProto13[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (combPairArgs) {
        result['args'] = combPairArgs;
    }
    else if (args.length) {
        result['args'] = args;
    }
    if (combPairAnnots && combPairAnnots[0] !== '') {
        result['annots'] = combPairAnnots;
    }
    else if (hasAnnot) {
        result['annots'] = decodeAnnots(value);
    }
    return result;
};
const primViewDecoderProto13 = (value, result) => {
    value.consume(4);
    result['args'] = new Array(4).fill(0).map(() => valueDecoderProto13(value));
    value.consume(4);
    return result;
};
const decodeCombPair = (val) => {
    const array = new Uint8ArrayConsumer(extractRequiredLen(val));
    const args = [];
    while (array.length() > 0) {
        args.push(valueDecoderProto13(array));
    }
    return args;
};

const parametersDecoderProto13 = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = entrypointDecoder(val);
        const params = extractRequiredLen(val);
        const parameters = valueDecoderProto13(new Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
const valueParameterDecoderProto13 = (val) => {
    const value = extractRequiredLen(val);
    return valueDecoderProto13(new Uint8ArrayConsumer(value));
};
const entrypointEncoderProto13 = (entrypoint) => {
    if (entrypoint in entrypointMappingReverse) {
        return `${entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${valueEncoderProto13(value).slice(8)}`;
    }
};
const entrypointNameEncoderProto13 = (entrypoint) => {
    const value = { string: entrypoint };
    return `${valueEncoderProto13(value).slice(2)}`;
};
const entrypointNameDecoderProto13 = (val) => {
    const entry = extractRequiredLen(val);
    return Buffer.from(entry).toString('utf8');
};
const parametersEncoderProto13 = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = entrypointEncoderProto13(val.entrypoint);
    const parameters = valueEncoderProto13(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoderProto13 = (value) => {
    const valueEncoded = valueEncoderProto13(value);
    return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
const txRollupOriginationParamEncoderProto13 = (_value) => {
    return '';
};
const txRollupOriginationParamDecoderProto13 = (_val) => {
    return {};
};
const txRollupIdEncoderProto13 = prefixEncoder(Prefix.TXR1);
const txRollupIdDecoderProto13 = prefixDecoder(Prefix.TXR1);
const txRollupBatchContentEncoderProto13 = (value) => {
    return `${pad(value.length / 2)}${value}`;
};
const txRollupBatchContentDecoderProto13 = (val) => {
    const value = extractRequiredLen(val);
    return Buffer.from(value).toString('hex');
};
const burnLimitEncoder = (val) => {
    return !val ? '00' : `ff${zarithEncoder(val)}`;
};
const burnLimitDecoder = (value) => {
    const prefix = value.consume(1);
    if (Buffer.from(prefix).toString('hex') !== '00') {
        return zarithDecoder(value);
    }
};

const encodersProto13 = Object.assign(Object.assign({}, encoders), { [CODEC.SCRIPT]: scriptEncoderProto13, [CODEC.PARAMETERS]: parametersEncoderProto13, [CODEC.VALUE]: valueParameterEncoderProto13, [CODEC.ENTRYPOINT]: entrypointNameEncoderProto13, [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamEncoderProto13, [CODEC.TX_ROLLUP_ID]: txRollupIdEncoderProto13, [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentEncoderProto13, [CODEC.BURN_LIMIT]: burnLimitEncoder });
encodersProto13[CODEC.OPERATION] = operationEncoder(encodersProto13);
encodersProto13[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encodersProto13)(ActivationSchema)(val);
encodersProto13[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encodersProto13)(DelegationSchema)(val);
encodersProto13[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encodersProto13)(TransactionSchema)(val);
encodersProto13[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encodersProto13)(OriginationSchema)(val);
encodersProto13[CODEC.OP_BALLOT] = (val) => schemaEncoder(encodersProto13)(BallotSchema)(val);
encodersProto13[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encodersProto13)(EndorsementSchema)(val);
encodersProto13[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encodersProto13)(SeedNonceRevelationSchema)(val);
encodersProto13[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encodersProto13)(ProposalsSchema)(val);
encodersProto13[CODEC.OP_REVEAL] = (val) => schemaEncoder(encodersProto13)(RevealSchema)(val);
encodersProto13[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encodersProto13)(RegisterGlobalConstantSchema)(val);
encodersProto13[CODEC.OP_TRANSFER_TICKET] = (val) => schemaEncoder(encodersProto13)(TransferTicketSchema)(val);
encodersProto13[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaEncoder(encodersProto13)(TxRollupOriginationSchema)(val);
encodersProto13[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaEncoder(encodersProto13)(TxRollupSubmitBatchSchema)(val);
encodersProto13[CODEC.MANAGER] = schemaEncoder(encodersProto13)(ManagerOperationSchema);

const decodersProto13 = Object.assign(Object.assign({}, decoders), { [CODEC.SCRIPT]: scriptDecoderProto13, [CODEC.PARAMETERS]: parametersDecoderProto13, [CODEC.VALUE]: valueParameterDecoderProto13, [CODEC.ENTRYPOINT]: entrypointNameDecoderProto13, [CODEC.TX_ROLLUP_ORIGINATION_PARAM]: txRollupOriginationParamDecoderProto13, [CODEC.TX_ROLLUP_ID]: txRollupIdDecoderProto13, [CODEC.TX_ROLLUP_BATCH_CONTENT]: txRollupBatchContentDecoderProto13, [CODEC.BURN_LIMIT]: burnLimitDecoder });
decodersProto13[CODEC.OPERATION] = operationDecoder(decodersProto13);
decodersProto13[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decodersProto13)(ActivationSchema)(val);
decodersProto13[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decodersProto13)(DelegationSchema)(val);
decodersProto13[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decodersProto13)(TransactionSchema)(val);
decodersProto13[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decodersProto13)(OriginationSchema)(val);
decodersProto13[CODEC.OP_BALLOT] = (val) => schemaDecoder(decodersProto13)(BallotSchema)(val);
decodersProto13[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decodersProto13)(EndorsementSchema)(val);
decodersProto13[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decodersProto13)(SeedNonceRevelationSchema)(val);
decodersProto13[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decodersProto13)(ProposalsSchema)(val);
decodersProto13[CODEC.OP_REVEAL] = (val) => schemaDecoder(decodersProto13)(RevealSchema)(val);
decodersProto13[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decodersProto13)(RegisterGlobalConstantSchema)(val);
decodersProto13[CODEC.OP_TRANSFER_TICKET] = (val) => schemaDecoder(decodersProto13)(TransferTicketSchema)(val);
decodersProto13[CODEC.OP_TX_ROLLUP_ORIGINATION] = (val) => schemaDecoder(decodersProto13)(TxRollupOriginationSchema)(val);
decodersProto13[CODEC.OP_TX_ROLLUP_SUBMIT_BATCH] = (val) => schemaDecoder(decodersProto13)(TxRollupSubmitBatchSchema)(val);
decodersProto13[CODEC.MANAGER] = schemaDecoder(decodersProto13)(ManagerOperationSchema);

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
const VERSION = {
    "commitHash": "6d90b3d5e616a6e9b9ad9dd8453b5068e7396fff",
    "version": "13.0.1"
};

/**
 * @packageDocumentation
 * @module @taquito/local-forging
 */
const PROTOCOL_CURRENT = ProtocolsHash.Psithaca2;
function getCodec(codec, proto) {
    if (proto === ProtocolsHash.Psithaca2 || ProtoInferiorTo(proto, ProtocolsHash.Psithaca2)) {
        return {
            encoder: encoders[codec],
            decoder: (hex) => {
                const consumer = Uint8ArrayConsumer.fromHexString(hex);
                return decoders[codec](consumer);
            },
        };
    }
    else {
        return {
            encoder: encodersProto13[codec],
            decoder: (hex) => {
                const consumer = Uint8ArrayConsumer.fromHexString(hex);
                return decodersProto13[codec](consumer);
            },
        };
    }
}
class LocalForger {
    constructor(protocolHash = PROTOCOL_CURRENT) {
        this.protocolHash = protocolHash;
        this.codec = getCodec(CODEC.MANAGER, this.protocolHash);
    }
    forge(params) {
        if (validateBlock(params.branch) !== ValidationResult.VALID) {
            throw new InvalidBlockHashError(`The block hash ${params.branch} is invalid`);
        }
        for (const content of params.contents) {
            if (!validateOperationKind(content.kind)) {
                throw new InvalidOperationKindError(content.kind);
            }
            const diff = validateMissingProperty(content);
            if (diff.length === 1) {
                if (content.kind === 'delegation' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'origination' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                    continue;
                }
                else if (content.kind === 'tx_rollup_submit_batch' &&
                    diff[0] === 'burn_limit') {
                    continue;
                }
                else {
                    throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
                }
            }
            else if (diff.length > 1) {
                throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
            }
        }
        const forged = this.codec.encoder(params).toLowerCase();
        return Promise.resolve(forged);
    }
    parse(hex) {
        return Promise.resolve(this.codec.decoder(hex));
    }
}
const localForger = new LocalForger();

export { CODEC, LocalForger, ProtocolsHash, Uint8ArrayConsumer, VERSION, decoders, encoders, getCodec, localForger };
//# sourceMappingURL=taquito-local-forging.es6.js.map
