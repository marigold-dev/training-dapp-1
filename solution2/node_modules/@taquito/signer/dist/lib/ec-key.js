"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tz2 = exports.Tz3 = exports.ECKey = void 0;
const blake2b_1 = require("@stablelib/blake2b");
const utils_1 = require("@taquito/utils");
const typedarray_to_buffer_1 = require("typedarray-to-buffer");
const elliptic_1 = require("elliptic");
const pref = {
    p256: {
        pk: utils_1.prefix['p2pk'],
        sk: utils_1.prefix['p2sk'],
        pkh: utils_1.prefix.tz3,
        sig: utils_1.prefix.p2sig,
    },
    secp256k1: {
        pk: utils_1.prefix['sppk'],
        sk: utils_1.prefix['spsk'],
        pkh: utils_1.prefix.tz2,
        sig: utils_1.prefix.spsig,
    },
};
/**
 * @description Provide signing logic for elliptic curve based key (tz2, tz3)
 */
class ECKey {
    /**
     *
     * @param curve Curve to use with the key
     * @param key Encoded private key
     * @param encrypted Is the private key encrypted
     * @param decrypt Decrypt function
     */
    constructor(curve, key, encrypted, decrypt) {
        this.curve = curve;
        this.key = key;
        const keyPrefix = key.substr(0, encrypted ? 5 : 4);
        if (!utils_1.isValidPrefix(keyPrefix)) {
            throw new utils_1.InvalidKeyError(key, 'Key contains invalid prefix');
        }
        this._key = decrypt(utils_1.b58cdecode(this.key, utils_1.prefix[keyPrefix]));
        const keyPair = new elliptic_1.default.ec(this.curve).keyFromPrivate(this._key);
        const keyPairY = keyPair.getPublic().getY().toArray();
        const parityByte = keyPairY.length < 32 ? keyPairY[keyPairY.length - 1] : keyPairY[31];
        const pref = parityByte % 2 ? 3 : 2;
        const pad = new Array(32).fill(0);
        this._publicKey = typedarray_to_buffer_1.default(new Uint8Array([pref].concat(pad.concat(keyPair.getPublic().getX().toArray()).slice(-32))));
    }
    /**
     *
     * @param bytes Bytes to sign
     * @param bytesHash Blake2b hash of the bytes to sign
     */
    sign(bytes, bytesHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = new elliptic_1.default.ec(this.curve).keyFromPrivate(this._key);
            const sig = key.sign(bytesHash, { canonical: true });
            const signature = sig.r.toString('hex', 64) + sig.s.toString('hex', 64);
            const sbytes = bytes + signature;
            return {
                bytes,
                sig: utils_1.b58cencode(signature, utils_1.prefix.sig),
                prefixSig: utils_1.b58cencode(signature, pref[this.curve].sig),
                sbytes,
            };
        });
    }
    /**
     * @returns Encoded public key
     */
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.b58cencode(this._publicKey, pref[this.curve].pk);
        });
    }
    /**
     * @returns Encoded public key hash
     */
    publicKeyHash() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.b58cencode(blake2b_1.hash(new Uint8Array(this._publicKey), 20), pref[this.curve].pkh);
        });
    }
    /**
     * @returns Encoded private key
     */
    secretKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this._key;
            return utils_1.b58cencode(key, pref[this.curve].sk);
        });
    }
}
exports.ECKey = ECKey;
/**
 * @description Tz3 key class using the p256 curve
 */
exports.Tz3 = ECKey.bind(null, 'p256');
/**
 * @description Tz3 key class using the secp256k1 curve
 */
exports.Tz2 = ECKey.bind(null, 'secp256k1');
//# sourceMappingURL=ec-key.js.map