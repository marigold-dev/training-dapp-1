"use strict";
/**
 * @packageDocumentation
 * @module @taquito/utils
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes2Char = exports.char2Bytes = exports.getPkhfromPk = exports.buf2hex = exports.mic2arr = exports.mergebuf = exports.hex2buf = exports.encodeKeyHash = exports.encodeKey = exports.encodeL2Address = exports.encodePubKey = exports.b58decodeL2Address = exports.b58decode = exports.b58cdecode = exports.b58cencode = exports.encodeOpHash = exports.encodeExpr = exports.validatePkAndExtractPrefix = exports.verifySignature = exports.prefixLength = exports.Prefix = exports.prefix = exports.VERSION = void 0;
/*
 * Some code in this file is originally from sotez and eztz
 * Copyright (c) 2018 Andrew Kishino
 * Copyright (c) 2017 Stephen Andrews
 */
const buffer_1 = require("buffer");
const constants_1 = require("./constants");
const verify_signature_1 = require("./verify-signature");
const blake2b_1 = require("@stablelib/blake2b");
const blakejs_1 = require("blakejs");
const bs58check_1 = require("bs58check");
const errors_1 = require("./errors");
__exportStar(require("./validators"), exports);
var version_1 = require("./version");
Object.defineProperty(exports, "VERSION", { enumerable: true, get: function () { return version_1.VERSION; } });
var constants_2 = require("./constants");
Object.defineProperty(exports, "prefix", { enumerable: true, get: function () { return constants_2.prefix; } });
Object.defineProperty(exports, "Prefix", { enumerable: true, get: function () { return constants_2.Prefix; } });
Object.defineProperty(exports, "prefixLength", { enumerable: true, get: function () { return constants_2.prefixLength; } });
var verify_signature_2 = require("./verify-signature");
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return verify_signature_2.verifySignature; } });
Object.defineProperty(exports, "validatePkAndExtractPrefix", { enumerable: true, get: function () { return verify_signature_2.validatePkAndExtractPrefix; } });
__exportStar(require("./errors"), exports);
/**
 *
 * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it
 *
 * @param value Value in hex
 */
function encodeExpr(value) {
    const blakeHash = blakejs_1.default.blake2b(exports.hex2buf(value), undefined, 32);
    return b58cencode(blakeHash, constants_1.prefix['expr']);
}
exports.encodeExpr = encodeExpr;
/**
 *
 * @description Return the operation hash of a signed operation
 * @param value Value in hex of a signed operation
 */
function encodeOpHash(value) {
    const blakeHash = blakejs_1.default.blake2b(exports.hex2buf(value), undefined, 32);
    return b58cencode(blakeHash, constants_1.prefix.o);
}
exports.encodeOpHash = encodeOpHash;
/**
 *
 * @description Base58 encode a string or a Uint8Array and append a prefix to it
 *
 * @param value Value to base58 encode
 * @param prefix prefix to append to the encoded string
 */
function b58cencode(value, prefix) {
    const payloadAr = typeof value === 'string' ? Uint8Array.from(buffer_1.Buffer.from(value, 'hex')) : value;
    const n = new Uint8Array(prefix.length + payloadAr.length);
    n.set(prefix);
    n.set(payloadAr, prefix.length);
    return bs58check_1.default.encode(buffer_1.Buffer.from(n.buffer));
}
exports.b58cencode = b58cencode;
/**
 *
 * @description Base58 decode a string and remove the prefix from it
 *
 * @param value Value to base58 decode
 * @param prefix prefix to remove from the decoded string
 */
const b58cdecode = (enc, prefixArg) => bs58check_1.default.decode(enc).slice(prefixArg.length);
exports.b58cdecode = b58cdecode;
/**
 *
 * @description Base58 decode a string with predefined prefix
 *
 * @param value Value to base58 decode
 */
function b58decode(payload) {
    const buf = bs58check_1.default.decode(payload);
    const prefixMap = {
        [constants_1.prefix.tz1.toString()]: '0000',
        [constants_1.prefix.tz2.toString()]: '0001',
        [constants_1.prefix.tz3.toString()]: '0002',
    };
    const rollupPrefMap = {
        [constants_1.prefix.txr1.toString()]: '02',
    };
    const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];
    const rollupPref = rollupPrefMap[new Uint8Array(buf.slice(0, 4)).toString()];
    if (pref) {
        // tz addresses
        const hex = exports.buf2hex(buf.slice(3));
        return pref + hex;
    }
    else if (rollupPref) {
        const hex = exports.buf2hex(buf.slice(4));
        return rollupPref + hex + '00';
    }
    else {
        // other (kt addresses)
        return '01' + exports.buf2hex(buf.slice(3, 42)) + '00';
    }
}
exports.b58decode = b58decode;
/**
 *
 * @description b58 decode a string without predefined prefix
 * @param value
 * @returns string of bytes
 */
function b58decodeL2Address(payload) {
    const buf = bs58check_1.default.decode(payload);
    // tz4 address currently
    return exports.buf2hex(buf.slice(3, 42));
}
exports.b58decodeL2Address = b58decodeL2Address;
/**
 *
 * @description Base58 encode an address using predefined prefix
 *
 * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)
 */
function encodePubKey(value) {
    if (value.substring(0, 2) === '00') {
        const pref = {
            '0000': constants_1.prefix.tz1,
            '0001': constants_1.prefix.tz2,
            '0002': constants_1.prefix.tz3,
        };
        return b58cencode(value.substring(4), pref[value.substring(0, 4)]);
    }
    else if (value.substring(0, 2) === '02') {
        // 42 also works but the removes the 00 padding at the end
        return b58cencode(value.substring(2, value.length - 2), constants_1.prefix.txr1);
    }
    return b58cencode(value.substring(2, 42), constants_1.prefix.KT);
}
exports.encodePubKey = encodePubKey;
/**
 *
 * @description Base58 encode an address without predefined prefix
 * @param value Address to base58 encode (tz4) hex dec
 * @returns return address
 */
function encodeL2Address(value) {
    return b58cencode(value, constants_1.prefix.tz4);
}
exports.encodeL2Address = encodeL2Address;
/**
 *
 * @description Base58 encode a key according to its prefix
 *
 * @param value Key to base58 encode
 */
function encodeKey(value) {
    if (value[0] === '0') {
        const pref = {
            '00': new Uint8Array([13, 15, 37, 217]),
            '01': new Uint8Array([3, 254, 226, 86]),
            '02': new Uint8Array([3, 178, 139, 127]),
        };
        return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
    }
}
exports.encodeKey = encodeKey;
/**
 *
 * @description Base58 encode a key hash according to its prefix
 *
 * @param value Key hash to base58 encode
 */
function encodeKeyHash(value) {
    if (value[0] === '0') {
        const pref = {
            '00': new Uint8Array([6, 161, 159]),
            '01': new Uint8Array([6, 161, 161]),
            '02': new Uint8Array([6, 161, 164]),
        };
        return b58cencode(value.substring(2), pref[value.substring(0, 2)]);
    }
}
exports.encodeKeyHash = encodeKeyHash;
/**
 *
 * @description Convert an hex string to a Uint8Array
 *
 * @param hex Hex string to convert
 */
const hex2buf = (hex) => {
    const match = hex.match(/[\da-f]{2}/gi);
    if (match) {
        return new Uint8Array(match.map((h) => parseInt(h, 16)));
    }
    else {
        throw new errors_1.ValueConversionError(hex, 'Uint8Array');
    }
};
exports.hex2buf = hex2buf;
/**
 *
 * @description Merge 2 buffers together
 *
 * @param b1 First buffer
 * @param b2 Second buffer
 */
const mergebuf = (b1, b2) => {
    const r = new Uint8Array(b1.length + b2.length);
    r.set(b1);
    r.set(b2, b1.length);
    return r;
};
exports.mergebuf = mergebuf;
/**
 *
 * @description Flatten a michelson json representation to an array
 *
 * @param s michelson json
 */
const mic2arr = function me2(s) {
    let ret = [];
    if (Object.prototype.hasOwnProperty.call(s, 'prim')) {
        if (s.prim === 'Pair') {
            ret.push(me2(s.args[0]));
            ret = ret.concat(me2(s.args[1]));
        }
        else if (s.prim === 'Elt') {
            ret = {
                key: me2(s.args[0]),
                val: me2(s.args[1]),
            };
        }
        else if (s.prim === 'True') {
            ret = true;
        }
        else if (s.prim === 'False') {
            ret = false;
        }
    }
    else if (Array.isArray(s)) {
        const sc = s.length;
        for (let i = 0; i < sc; i++) {
            const n = me2(s[i]);
            if (typeof n.key !== 'undefined') {
                if (Array.isArray(ret)) {
                    ret = {
                        keys: [],
                        vals: [],
                    };
                }
                ret.keys.push(n.key);
                ret.vals.push(n.val);
            }
            else {
                ret.push(n);
            }
        }
    }
    else if (Object.prototype.hasOwnProperty.call(s, 'string')) {
        ret = s.string;
    }
    else if (Object.prototype.hasOwnProperty.call(s, 'int')) {
        ret = parseInt(s.int, 10);
    }
    else {
        ret = s;
    }
    return ret;
};
exports.mic2arr = mic2arr;
/**
 *
 * @description Convert a buffer to an hex string
 *
 * @param buffer Buffer to convert
 */
const buf2hex = (buffer) => {
    const byteArray = new Uint8Array(buffer);
    const hexParts = [];
    byteArray.forEach((byte) => {
        const hex = byte.toString(16);
        const paddedHex = `00${hex}`.slice(-2);
        hexParts.push(paddedHex);
    });
    return hexParts.join('');
};
exports.buf2hex = buf2hex;
/**
 *
 *  @description Gets Tezos address (PKH) from Public Key
 *
 *  @param publicKey Public Key
 *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key
 */
const getPkhfromPk = (publicKey) => {
    let encodingPrefix;
    let prefixLen;
    const keyPrefix = verify_signature_1.validatePkAndExtractPrefix(publicKey);
    const decoded = exports.b58cdecode(publicKey, constants_1.prefix[keyPrefix]);
    switch (keyPrefix) {
        case constants_1.Prefix.EDPK:
            encodingPrefix = constants_1.prefix[constants_1.Prefix.TZ1];
            prefixLen = constants_1.prefixLength[constants_1.Prefix.TZ1];
            break;
        case constants_1.Prefix.SPPK:
            encodingPrefix = constants_1.prefix[constants_1.Prefix.TZ2];
            prefixLen = constants_1.prefixLength[constants_1.Prefix.TZ2];
            break;
        case constants_1.Prefix.P2PK:
            encodingPrefix = constants_1.prefix[constants_1.Prefix.TZ3];
            prefixLen = constants_1.prefixLength[constants_1.Prefix.TZ3];
            break;
        case constants_1.Prefix.BLPK:
            encodingPrefix = constants_1.prefix[constants_1.Prefix.TZ4];
            prefixLen = constants_1.prefixLength[constants_1.Prefix.TZ4];
    }
    const hashed = blake2b_1.hash(decoded, prefixLen);
    const result = b58cencode(hashed, encodingPrefix);
    return result;
};
exports.getPkhfromPk = getPkhfromPk;
/**
 *
 * @description Convert a string to bytes
 *
 * @param str String to convert
 */
function char2Bytes(str) {
    return buffer_1.Buffer.from(str, 'utf8').toString('hex');
}
exports.char2Bytes = char2Bytes;
/**
 *
 * @description Convert bytes to a string
 *
 * @param str Bytes to convert
 */
function bytes2Char(hex) {
    return buffer_1.Buffer.from(exports.hex2buf(hex)).toString('utf8');
}
exports.bytes2Char = bytes2Char;
//# sourceMappingURL=taquito-utils.js.map