"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dummyContract = exports.Contract = void 0;
const michelson_typecheck_1 = require("./michelson-typecheck");
const micheline_parser_1 = require("./micheline-parser");
const michelson_validator_1 = require("./michelson-validator");
const error_1 = require("./error");
class Contract {
    constructor(contract, opt) {
        this.contract = contract;
        this.ctx = Object.assign({ contract }, opt);
        this.output = michelson_typecheck_1.assertContractValid(contract, this.ctx);
    }
    static parse(src, opt) {
        const p = new micheline_parser_1.Parser(opt);
        const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
        if (expr === null) {
            throw new error_1.InvalidContractError('empty contract');
        }
        if (michelson_validator_1.assertMichelsonContract(expr)) {
            return new Contract(expr, opt);
        }
        throw undefined;
    }
    static parseTypeExpression(src, opt) {
        const p = new micheline_parser_1.Parser(opt);
        const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
        if (expr === null) {
            throw new error_1.InvalidTypeExpressionError('empty type expression');
        }
        if (michelson_validator_1.assertMichelsonType(expr) && michelson_typecheck_1.assertTypeAnnotationsValid(expr)) {
            return expr;
        }
        throw undefined;
    }
    static parseDataExpression(src, opt) {
        const p = new micheline_parser_1.Parser(opt);
        const expr = typeof src === 'string' ? p.parseScript(src) : p.parseJSON(src);
        if (expr === null) {
            throw new error_1.InvalidDataExpressionError('empty data expression');
        }
        if (michelson_validator_1.assertMichelsonData(expr)) {
            return expr;
        }
        throw undefined;
    }
    section(section) {
        return michelson_typecheck_1.contractSection(this.contract, section);
    }
    entryPoints() {
        return michelson_typecheck_1.contractEntryPoints(this.contract);
    }
    entryPoint(ep) {
        return michelson_typecheck_1.contractEntryPoint(this.contract, ep);
    }
    assertDataValid(d, t) {
        michelson_typecheck_1.assertDataValid(d, t, this.ctx);
    }
    isDataValid(d, t) {
        return michelson_typecheck_1.isDataValid(d, t, this.ctx);
    }
    assertParameterValid(ep, d) {
        const t = this.entryPoint(ep || undefined);
        if (t === null) {
            throw new error_1.InvalidEntrypointError(ep === null || ep === void 0 ? void 0 : ep.toString());
        }
        this.assertDataValid(d, t);
    }
    isParameterValid(ep, d) {
        try {
            this.assertParameterValid(ep, d);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    functionType(inst, stack) {
        return michelson_typecheck_1.functionType(inst, stack, this.ctx);
    }
}
exports.Contract = Contract;
exports.dummyContract = new Contract([
    { prim: 'parameter', args: [{ prim: 'unit' }] },
    { prim: 'storage', args: [{ prim: 'unit' }] },
    {
        prim: 'code',
        args: [[{ prim: 'CAR' }, { prim: 'NIL', args: [{ prim: 'operation' }] }, { prim: 'PAIR' }]],
    },
]);
//# sourceMappingURL=michelson-contract.js.map