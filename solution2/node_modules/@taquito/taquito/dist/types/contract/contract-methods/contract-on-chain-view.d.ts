import { ViewSchema } from '@taquito/michelson-encoder';
import { MichelsonV1Expression, RpcClientInterface } from '@taquito/rpc';
import { TzReadProvider } from '../../read-provider/interface';
export interface ExecutionContextParams {
    source?: string;
    viewCaller: string;
}
export declare class OnChainView {
    private _rpc;
    private _readProvider;
    private _contractAddress;
    private _smartContractViewSchema;
    private _contractStorageType;
    private _args;
    constructor(_rpc: RpcClientInterface, _readProvider: TzReadProvider, _contractAddress: string, _smartContractViewSchema: ViewSchema, _contractStorageType: MichelsonV1Expression, _args?: any);
    /**
     * @description Get the signature of the smart contract view
     */
    getSignature(): {
        parameter: any;
        result: any;
    };
    /**
     * @description Get the result of the view simulation
     * @param executionContext.source the public key hash of the account who initialized this view execution.
     * @param executionContext.viewCaller the contract address which is the caller of view.
     */
    executeView(executionContext: ExecutionContextParams): Promise<any>;
    private verifyContextExecution;
    private transformArgsToMichelson;
    /**
     * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.
     *
     * Certain specific instructions have different semantics in view:
     * BALANCE represents the current amount of mutez held by the contract where view is;
     * SENDER represents the contract which is the caller of view;
     * SELF_ADDRESS represents the contract where view is;
     * AMOUNT is always 0 mutez.
     *
     */
    private adaptViewCodeToContext;
    private executeViewAndDecodeResult;
}
