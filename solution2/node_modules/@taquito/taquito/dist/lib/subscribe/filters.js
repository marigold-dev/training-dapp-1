"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateFilter = exports.evaluateExpression = exports.evaluateOpFilter = void 0;
const error_1 = require("../error");
const opHashFilter = (op, filter) => op.hash === filter.opHash;
const sourceFilter = (x, filter) => {
    switch (x.kind) {
        case 'endorsement':
            return 'metadata' in x && x.metadata.delegate === filter.source;
        case 'activate_account':
            return 'metadata' in x && x.pkh === filter.source;
        default:
            return 'source' in x && x.source === filter.source;
    }
};
const kindFilter = (x, filter) => 'kind' in x && x.kind === filter.kind;
const destinationFilter = (x, filter) => {
    switch (x.kind) {
        case 'delegation':
            return x.delegate === filter.destination;
        case 'origination':
            if ('metadata' in x &&
                'operation_result' in x.metadata &&
                'originated_contracts' in x.metadata.operation_result &&
                Array.isArray(x.metadata.operation_result.originated_contracts)) {
                return x.metadata.operation_result.originated_contracts.some((contract) => contract === filter.destination);
            }
            break;
        case 'transaction':
            return x.destination === filter.destination;
        default:
            return false;
    }
};
const evaluateOpFilter = (op, filter) => {
    if ('opHash' in filter) {
        return opHashFilter(op, filter);
    }
    else if ('source' in filter) {
        return sourceFilter(op, filter);
    }
    else if ('kind' in filter) {
        return kindFilter(op, filter);
    }
    else if ('destination' in filter) {
        return destinationFilter(op, filter);
    }
    return false;
};
exports.evaluateOpFilter = evaluateOpFilter;
const evaluateExpression = (op, exp) => {
    if (Array.isArray(exp.and)) {
        return exp.and.every((x) => exports.evaluateFilter(op, x));
    }
    else if (Array.isArray(exp.or)) {
        return exp.or.some((x) => exports.evaluateFilter(op, x));
    }
    else {
        throw new error_1.InvalidFilterExpressionError('Filter expression must contain either and/or property');
    }
};
exports.evaluateExpression = evaluateExpression;
const evaluateFilter = (op, filter) => {
    const filters = [];
    if (!Array.isArray(filter)) {
        filters.push(filter);
    }
    else {
        filters.push(...filter);
    }
    return filters.every((filterOrExp) => {
        if ('and' in filterOrExp || 'or' in filterOrExp) {
            return exports.evaluateExpression(op, filterOrExp);
        }
        else {
            return exports.evaluateOpFilter(op, filterOrExp);
        }
    });
};
exports.evaluateFilter = evaluateFilter;
//# sourceMappingURL=filters.js.map