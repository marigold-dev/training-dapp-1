"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcContractProvider = void 0;
const http_utils_1 = require("@taquito/http-utils");
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const rpc_1 = require("@taquito/rpc");
const utils_1 = require("@taquito/utils");
const rpc_batch_provider_1 = require("../batch/rpc-batch-provider");
const delegate_operation_1 = require("../operations/delegate-operation");
const operation_emitter_1 = require("../operations/operation-emitter");
const origination_operation_1 = require("../operations/origination-operation");
const register_global_constant_operation_1 = require("../operations/register-global-constant-operation");
const reveal_operation_1 = require("../operations/reveal-operation");
const transaction_operation_1 = require("../operations/transaction-operation");
const types_1 = require("../operations/types");
const contract_1 = require("./contract");
const errors_1 = require("./errors");
const prepare_1 = require("./prepare");
const semantic_1 = require("./semantic");
const utils_2 = require("@taquito/utils");
const tx_rollup_origination_operation_1 = require("../operations/tx-rollup-origination-operation");
const tx_rollup_batch_operation_1 = require("../operations/tx-rollup-batch-operation");
class RpcContractProvider extends operation_emitter_1.OperationEmitter {
    constructor(context, estimator) {
        super(context);
        this.estimator = estimator;
        this.contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');
    }
    /**
     *
     * @description Return a well formatted json object of the contract storage
     *
     * @param contract contract address you want to get the storage from
     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
     *
     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script
     */
    getStorage(contract, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_2.validateContractAddress(contract) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidContractAddressError(contract);
            }
            const script = yield this.context.readProvider.getScript(contract, 'head');
            if (!schema) {
                schema = script;
            }
            let contractSchema;
            if (michelson_encoder_1.Schema.isSchema(schema)) {
                contractSchema = schema;
            }
            else {
                contractSchema = michelson_encoder_1.Schema.fromRPCResponse({ script: schema });
            }
            return contractSchema.Execute(script.storage, semantic_1.smartContractAbstractionSemantic(this)); // Cast into T because only the caller can know the true type of the storage
        });
    }
    /**
     *
     * @description Return a well formatted json object of the contract big map storage
     *
     * @param contract contract address you want to get the storage from
     * @param key contract big map key to fetch value from
     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema
     *
     * @deprecated Deprecated in favor of getBigMapKeyByID
     *
     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
     */
    getBigMapKey(contract, key, schema) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_2.validateContractAddress(contract) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidContractAddressError(contract);
            }
            if (!schema) {
                schema = (yield this.rpc.getContract(contract)).script;
            }
            let contractSchema;
            if (michelson_encoder_1.Schema.isSchema(schema)) {
                contractSchema = schema;
            }
            else {
                contractSchema = michelson_encoder_1.Schema.fromRPCResponse({ script: schema });
            }
            const encodedKey = contractSchema.EncodeBigMapKey(key);
            const val = yield this.rpc.getBigMapKey(contract, encodedKey);
            return contractSchema.ExecuteOnBigMapValue(val); // Cast into T because only the caller can know the true type of the storage
        });
    }
    /**
     *
     * @description Return a well formatted json object of a big map value
     *
     * @param id Big Map ID
     * @param keyToEncode key to query (will be encoded properly according to the schema)
     * @param schema Big Map schema (can be determined using your contract type)
     * @param block optional block level to fetch the values from
     *
     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr
     */
    getBigMapKeyByID(id, keyToEncode, schema, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { key, type } = schema.EncodeBigMapKey(keyToEncode);
            const { packed } = yield this.context.packer.packData({ data: key, type });
            const encodedExpr = utils_1.encodeExpr(packed);
            const bigMapValue = block
                ? yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, block)
                : yield this.context.readProvider.getBigMapValue({ id: id.toString(), expr: encodedExpr }, 'head');
            return schema.ExecuteOnBigMapValue(bigMapValue, semantic_1.smartContractAbstractionSemantic(this));
        });
    }
    /**
     *
     * @description Fetch multiple values in a big map
     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.
     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.
     * If one of the keys does not exist in the big map, its value will be set to undefined.
     *
     * @param id Big Map ID
     * @param keys Array of keys to query (will be encoded properly according to the schema)
     * @param schema Big Map schema (can be determined using your contract type)
     * @param block optional block level to fetch the values from
     * @param batchSize optional batch size representing the number of requests to execute in parallel
     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format
     *
     */
    getBigMapKeysByID(id, keys, schema, block, batchSize = 5) {
        return __awaiter(this, void 0, void 0, function* () {
            const level = yield this.getBlockForRequest(keys, block);
            const bigMapValues = new michelson_encoder_1.MichelsonMap();
            // Execute batch of promises in series
            let position = 0;
            let results = [];
            while (position < keys.length) {
                const keysBatch = keys.slice(position, position + batchSize);
                const batch = keysBatch.map((keyToEncode) => this.getBigMapValueOrUndefined(keyToEncode, id, schema, level));
                results = [...results, ...(yield Promise.all(batch))];
                position += batchSize;
            }
            for (let i = 0; i < results.length; i++) {
                bigMapValues.set(keys[i], results[i]);
            }
            return bigMapValues;
        });
    }
    getBlockForRequest(keys, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return keys.length === 1 || typeof block !== 'undefined'
                ? block
                : yield this.context.readProvider.getBlockLevel('head');
        });
    }
    getBigMapValueOrUndefined(keyToEncode, id, schema, level) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.getBigMapKeyByID(id, keyToEncode, schema, level);
            }
            catch (ex) {
                if (ex instanceof http_utils_1.HttpResponseError && ex.status === http_utils_1.STATUS_CODE.NOT_FOUND) {
                    return;
                }
                else {
                    throw ex;
                }
            }
        });
    }
    /**
     *
     * @description Return a well formatted json object of a sapling state
     *
     * @param id Sapling state ID
     * @param block optional block level to fetch the value from
     *
     */
    getSaplingDiffByID(id, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const saplingState = block
                ? yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, block)
                : yield this.context.readProvider.getSaplingDiffById({ id: id.toString() }, 'head');
            return saplingState;
        });
    }
    addRevealOperationIfNeeded(operation, publicKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (types_1.isOpRequireReveal(operation)) {
                const ops = [operation];
                const publicKey = yield this.signer.publicKey();
                const estimateReveal = yield this.estimator.reveal();
                if (estimateReveal) {
                    const reveal = { kind: rpc_1.OpKind.REVEAL };
                    const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () { return estimateReveal; }));
                    ops.unshift(yield prepare_1.createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
                    return ops;
                }
            }
            return operation;
        });
    }
    /**
     *
     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)
     *
     * @param OriginationOperation Originate operation parameter
     */
    originate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));
            const publicKeyHash = yield this.signer.publicKeyHash();
            const operation = yield prepare_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimate)));
            const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
            const preparedOrigination = yield this.prepareOperation({
                operation: ops,
                source: publicKeyHash,
            });
            const forgedOrigination = yield this.forge(preparedOrigination);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(forgedOrigination);
            return new origination_operation_1.OriginationOperation(hash, operation, forgedBytes, opResponse, context, this);
        });
    }
    /**
     *
     * @description Set the delegate for a contract. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param SetDelegate operation parameter
     */
    setDelegate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (params.source && utils_2.validateAddress(params.source) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidAddressError(params.source);
            }
            if (params.delegate && utils_2.validateAddress(params.delegate) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidAddressError(params.delegate);
            }
            // Since babylon delegation source cannot smart contract
            if (/kt1/i.test(params.source)) {
                throw new errors_1.InvalidDelegationSource(params.source);
            }
            const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));
            const publicKeyHash = yield this.signer.publicKeyHash();
            const operation = yield prepare_1.createSetDelegateOperation(Object.assign(Object.assign({}, params), estimate));
            const sourceOrDefault = params.source || publicKeyHash;
            const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
            const prepared = yield this.prepareOperation({
                operation: ops,
                source: sourceOrDefault,
            });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new delegate_operation_1.DelegateOperation(hash, operation, sourceOrDefault, forgedBytes, opResponse, context);
        });
    }
    /**
     *
     * @description Register the current address as delegate. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param RegisterDelegate operation parameter
     */
    registerDelegate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));
            const source = yield this.signer.publicKeyHash();
            const operation = yield prepare_1.createRegisterDelegateOperation(Object.assign(Object.assign({}, params), estimate), source);
            const ops = yield this.addRevealOperationIfNeeded(operation, source);
            const prepared = yield this.prepareOperation({ operation: ops });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new delegate_operation_1.DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);
        });
    }
    /**
     *
     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param Transfer operation parameter
     */
    transfer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_2.validateAddress(params.to) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidAddressError(params.to);
            }
            if (params.source && utils_2.validateAddress(params.source) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidAddressError(params.source);
            }
            const publickKeyHash = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));
            const operation = yield prepare_1.createTransferOperation(Object.assign(Object.assign({}, params), estimate));
            const source = params.source || publickKeyHash;
            const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
            const prepared = yield this.prepareOperation({ operation: ops, source: params.source });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new transaction_operation_1.TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);
        });
    }
    /**
     *
     * @description Reveal the current address. Will throw an error if the address is already revealed.
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param RevealParams operation parameter
     */
    reveal(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKeyHash = yield this.signer.publicKeyHash();
            const estimateReveal = yield this.estimator.reveal(params);
            if (estimateReveal) {
                const estimated = yield this.estimate(params, () => __awaiter(this, void 0, void 0, function* () { return estimateReveal; }));
                const operation = yield prepare_1.createRevealOperation(Object.assign({}, estimated), publicKeyHash, yield this.signer.publicKey());
                const prepared = yield this.prepareOperation({ operation, source: publicKeyHash });
                const opBytes = yield this.forge(prepared);
                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
                return new reveal_operation_1.RevealOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
            }
            else {
                throw new errors_1.RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);
            }
        });
    }
    /**
     *
     * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param params registerGlobalConstant operation parameter
     */
    registerGlobalConstant(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const publickKeyHash = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));
            const operation = yield prepare_1.createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimate));
            const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);
            const prepared = yield this.prepareOperation({ operation: ops, source: publickKeyHash });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new register_global_constant_operation_1.RegisterGlobalConstantOperation(hash, operation, publickKeyHash, forgedBytes, opResponse, context);
        });
    }
    /**
     *
     * @description Originate a new tx rollup. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param TxRollupOriginateParams Originate rollup operation parameter
     */
    txRollupOriginate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKeyHash = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate(params ? params : {}, this.estimator.txRollupOriginate.bind(this.estimator));
            const operation = yield prepare_1.createTxRollupOriginationOperation(Object.assign(Object.assign({}, params), estimate));
            const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
            const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new tx_rollup_origination_operation_1.TxRollupOriginationOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
        });
    }
    /**
     *
     * @description Submit a tx rollup batch. Will sign and inject an operation using the current context
     *
     * @returns An operation handle with the result from the rpc node
     *
     * @param TxRollupBatchParams Batch tx rollup operation parameter
     */
    txRollupSubmitBatch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKeyHash = yield this.signer.publicKeyHash();
            const estimate = yield this.estimate(params, this.estimator.txRollupSubmitBatch.bind(this.estimator));
            const operation = yield prepare_1.createTxRollupBatchOperation(Object.assign(Object.assign({}, params), estimate));
            const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);
            const prepared = yield this.prepareOperation({ operation: ops, source: publicKeyHash });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new tx_rollup_batch_operation_1.TxRollupBatchOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);
        });
    }
    at(address, contractAbstractionComposer = (x) => x) {
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_2.validateContractAddress(address) !== utils_2.ValidationResult.VALID) {
                throw new utils_2.InvalidContractAddressError(address);
            }
            const rpc = this.context.withExtensions().rpc;
            const readProvider = this.context.withExtensions().readProvider;
            const script = yield readProvider.getScript(address, 'head');
            const entrypoints = yield readProvider.getEntrypoints(address);
            const abs = new contract_1.ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);
            return contractAbstractionComposer(abs, this.context);
        });
    }
    /**
     *
     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
     *
     * @returns A batch object from which we can add more operation or send a command to execute the batch
     *
     * @param params List of operation to batch together
     */
    batch(params) {
        const batch = new rpc_batch_provider_1.OperationBatch(this.context, this.estimator);
        if (Array.isArray(params)) {
            batch.with(params);
        }
        return batch;
    }
}
exports.RpcContractProvider = RpcContractProvider;
//# sourceMappingURL=rpc-contract-provider.js.map