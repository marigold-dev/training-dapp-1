"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcReadAdapter = void 0;
/**
 * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.
 */
class RpcReadAdapter {
    constructor(context) {
        this.context = context;
    }
    /**
     * @description Access the balance of a contract.
     * @param address address from which we want to retrieve the balance
     * @param block from which we want to retrieve the balance
     * @returns the balance in mutez
     */
    getBalance(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getBalance(address, { block: String(block) });
        });
    }
    /**
     * @description Access the delegate of a contract, if any.
     * @param address contract address from which we want to retrieve the delegate (baker)
     * @param block from which we want to retrieve the delegate
     * @returns the public key hash of the delegate or null if no delegate
     */
    getDelegate(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getDelegate(address, { block: String(block) });
        });
    }
    /**
     * @description Access the next protocol hash
     * @param block from which we want to retrieve the next protocol hash
     */
    getNextProtocol(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const protocols = yield this.context.rpc.getProtocols({ block: String(block) });
            return protocols.next_protocol;
        });
    }
    /**
     * @description Access protocol constants used in Taquito
     * @param block from which we want to retrieve the constants
     */
    getProtocolConstants(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { time_between_blocks, minimal_block_delay, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, tx_rollup_origination_size, } = yield this.context.rpc.getConstants({ block: String(block) });
            return {
                time_between_blocks,
                minimal_block_delay,
                hard_gas_limit_per_operation,
                hard_gas_limit_per_block,
                hard_storage_limit_per_operation,
                cost_per_byte,
                tx_rollup_origination_size,
            };
        });
    }
    /**
     * @description Access the script (code and storage) of a smart contract
     * @param contract contract address from which we want to retrieve the script
     * @param block from which we want to retrieve the storage value
     * @returns Note: The code must be in the JSON format and not contain global constant
     */
    getScript(contract, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { script } = yield this.context.rpc.getContract(contract, { block: String(block) });
            return script;
        });
    }
    /**
     * @description Access the storage value of a contract
     * @param contract contract address from which we want to retrieve the storage
     * @param block from which we want to retrieve the storage value
     */
    getStorage(contract, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getStorage(contract, { block: String(block) });
        });
    }
    /**
     * @description Access the block hash
     */
    getBlockHash(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { hash } = yield this.context.rpc.getBlockHeader({ block: String(block) });
            return hash;
        });
    }
    /**
     * @description Access the block level
     */
    getBlockLevel(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { level } = yield this.context.rpc.getBlockHeader({ block: String(block) });
            return level;
        });
    }
    /**
     * @description Access the counter of an address
     * @param pkh from which we want to retrieve the counter
     * @param block from which we want to retrieve the counter
     */
    getCounter(pkh, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { counter } = yield this.context.rpc.getContract(pkh, { block: String(block) });
            return counter || '0';
        });
    }
    /**
     * @description Access the timestamp of a block
     * @param block from which we want to retrieve the timestamp
     * @returns date ISO format zero UTC offset ("2022-01-19T22:37:07Z")
     */
    getBlockTimestamp(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timestamp } = yield this.context.rpc.getBlockHeader({ block: String(block) });
            return timestamp;
        });
    }
    /**
     * @description Access the value associated with a key in a big map.
     * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)
     * @param block from which we want to retrieve the big map value
     */
    getBigMapValue(bigMapQuery, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {
                block: String(block),
            });
        });
    }
    /**
     * @description Access the value associated with a sapling state ID.
     * @param id Sapling state ID
     * @param block from which we want to retrieve the sapling state
     */
    getSaplingDiffById(saplingStateQuery, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getSaplingDiffById(saplingStateQuery.id, { block: String(block) });
        });
    }
    /**
     * @description Return the list of entrypoints of the contract
     * @param contract address of the contract we want to get the entrypoints of
     */
    getEntrypoints(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getEntrypoints(contract);
        });
    }
    /**
     * @description Access the chain id
     */
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getChainId();
        });
    }
    /**
     * @description Indicate if an account is revealed
     * @param publicKeyHash of the account
     * @param block from which we want to know if the account is revealed
     */
    isAccountRevealed(publicKeyHash, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const manager = yield this.context.rpc.getManagerKey(publicKeyHash, { block: String(block) });
            const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;
            return haveManager;
        });
    }
    /**
     * @description Return all the information about a block
     * @param block from which we want to retrieve the information
     */
    getBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.rpc.getBlock({ block: String(block) });
        });
    }
    /**
     * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
     * @param block from which we want to retrieve the information
     */
    getLiveBlocks(block) {
        return this.context.rpc.getLiveBlocks({ block: String(block) });
    }
}
exports.RpcReadAdapter = RpcReadAdapter;
//# sourceMappingURL=rpc-read-adapter.js.map