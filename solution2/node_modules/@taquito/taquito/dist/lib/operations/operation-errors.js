"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginationOperationError = exports.flattenErrors = exports.flattenOperationResult = exports.TezosPreapplyFailureError = exports.TezosOperationError = void 0;
const types_1 = require("./types");
const isErrorWithMessage = (error) => {
    return 'with' in error;
};
/**
 *  @category Error
 *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html
 */
class TezosOperationError extends Error {
    constructor(errors, errorDetails) {
        super();
        this.errors = errors;
        this.errorDetails = errorDetails;
        this.name = 'TezosOperationError';
        // Last error is 'often' the one with more detail
        const lastError = errors[errors.length - 1];
        this.id = lastError.id;
        this.kind = lastError.kind;
        this.message = `(${this.kind}) ${this.id}`;
        if (isErrorWithMessage(lastError)) {
            if (lastError.with.string) {
                this.message = lastError.with.string;
            }
            else if (lastError.with.int) {
                this.message = lastError.with.int;
            }
            else {
                this.message = JSON.stringify(lastError.with);
            }
        }
    }
}
exports.TezosOperationError = TezosOperationError;
/**
 *  @category Error
 *  @description Tezos error that will be thrown when a mistake happens during the preapply stage
 */
class TezosPreapplyFailureError extends Error {
    constructor(result) {
        super('Preapply returned an unexpected result');
        this.result = result;
        this.name = 'TezosPreapplyFailureError';
    }
}
exports.TezosPreapplyFailureError = TezosPreapplyFailureError;
// Flatten all operation content results and internal operation results into a single array
// Some cases where we can have multiple operation results or internal operation results are:
// - When an operation includes a reveal operation
// - When an operation is made using the batch API
// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts
const flattenOperationResult = (response) => {
    const results = Array.isArray(response) ? response : [response];
    const returnedResults = [];
    for (let i = 0; i < results.length; i++) {
        for (let j = 0; j < results[i].contents.length; j++) {
            const content = results[i].contents[j];
            if (types_1.hasMetadataWithResult(content)) {
                returnedResults.push(Object.assign({ fee: content.fee }, content.metadata.operation_result));
                if (Array.isArray(content.metadata.internal_operation_results)) {
                    content.metadata.internal_operation_results.forEach((x) => returnedResults.push(x.result));
                }
            }
        }
    }
    return returnedResults;
};
exports.flattenOperationResult = flattenOperationResult;
/***
 * @description Flatten all error from preapply response (including internal error)
 */
const flattenErrors = (response, status = 'failed') => {
    const results = Array.isArray(response) ? response : [response];
    let errors = [];
    // Transaction that do not fail will be backtracked in case one failure occur
    for (let i = 0; i < results.length; i++) {
        for (let j = 0; j < results[i].contents.length; j++) {
            const content = results[i].contents[j];
            if (types_1.hasMetadata(content)) {
                if (types_1.hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {
                    errors = errors.concat(content.metadata.operation_result.errors || []);
                }
                if (types_1.hasMetadataWithInternalOperationResult(content) &&
                    Array.isArray(content.metadata.internal_operation_results)) {
                    for (const internalResult of content.metadata.internal_operation_results) {
                        if ('result' in internalResult && internalResult.result.status === status) {
                            errors = errors.concat(internalResult.result.errors || []);
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.flattenErrors = flattenErrors;
/**
 *  @category Error
 *  @description Error that indicates a general failure happening during an origination operation
 */
class OriginationOperationError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'OriginationOperationError';
    }
}
exports.OriginationOperationError = OriginationOperationError;
//# sourceMappingURL=operation-errors.js.map