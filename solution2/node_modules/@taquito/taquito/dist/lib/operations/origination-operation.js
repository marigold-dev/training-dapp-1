"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginationOperation = void 0;
const operation_errors_1 = require("./operation-errors");
const operations_1 = require("./operations");
const types_1 = require("./types");
/**
 * @description Origination operation provide utility function to fetch newly originated contract
 *
 * @warn Currently support only one origination per operation
 */
class OriginationOperation extends operations_1.Operation {
    constructor(hash, params, raw, results, context, contractProvider) {
        super(hash, raw, results, context);
        this.params = params;
        this.contractProvider = contractProvider;
        const originatedContracts = this.operationResults && this.operationResults.originated_contracts;
        if (Array.isArray(originatedContracts)) {
            this.contractAddress = originatedContracts[0];
        }
    }
    get status() {
        const operationResults = this.operationResults;
        if (operationResults) {
            return operationResults.status;
        }
        else {
            return 'unknown';
        }
    }
    get operationResults() {
        const originationOp = Array.isArray(this.results) &&
            this.results.find((op) => op.kind === 'origination');
        const result = originationOp &&
            types_1.hasMetadataWithResult(originationOp) &&
            originationOp.metadata.operation_result;
        return result ? result : undefined;
    }
    get fee() {
        return this.params.fee;
    }
    get gasLimit() {
        return this.params.gas_limit;
    }
    get storageLimit() {
        return this.params.storage_limit;
    }
    get consumedGas() {
        const consumedGas = this.operationResults && this.operationResults.consumed_gas;
        return consumedGas ? consumedGas : undefined;
    }
    get storageDiff() {
        const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;
        return storageDiff ? storageDiff : undefined;
    }
    get storageSize() {
        const storageSize = this.operationResults && this.operationResults.storage_size;
        return storageSize ? storageSize : undefined;
    }
    get errors() {
        return this.operationResults && this.operationResults.errors;
    }
    /**
     * @description Provide the contract abstract of the newly originated contract
     */
    contract(confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.contractAddress) {
                throw new operation_errors_1.OriginationOperationError('No contract was originated in this operation');
            }
            yield this.confirmation(confirmations, timeout);
            return this.contractProvider.at(this.contractAddress);
        });
    }
}
exports.OriginationOperation = OriginationOperation;
//# sourceMappingURL=origination-operation.js.map