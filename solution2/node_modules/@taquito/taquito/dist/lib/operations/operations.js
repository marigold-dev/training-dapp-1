"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Operation = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const types_1 = require("./types");
const utils_1 = require("@taquito/utils");
const create_observable_from_subscription_1 = require("../subscribe/create-observable-from-subscription");
const error_1 = require("../error");
/**
 * @description Utility class to interact with Tezos operations
 */
class Operation {
    /**
     *
     * @param hash Operation hash
     * @param raw Raw operation that was injected
     * @param context Taquito context allowing access to rpc and signer
     */
    constructor(hash, raw, results, context) {
        this.hash = hash;
        this.raw = raw;
        this.results = results;
        this.context = context;
        this._pollingConfig$ = new rxjs_1.ReplaySubject(1);
        this.currentHead$ = this._pollingConfig$.pipe(operators_1.switchMap((config) => {
            return rxjs_1.defer(() => create_observable_from_subscription_1.createObservableFromSubscription(this.context.stream.subscribeBlock('head'))).pipe(operators_1.timeoutWith(config.timeout * 1000, rxjs_1.throwError(new Error('Confirmation polling timed out'))));
        }), operators_1.shareReplay({ refCount: true }));
        // Observable that emit once operation is seen in a block
        this.confirmed$ = this.currentHead$.pipe(operators_1.map((head) => {
            for (let i = 3; i >= 0; i--) {
                head.operations[i].forEach((op) => {
                    if (op.hash === this.hash) {
                        this._foundAt = head.header.level;
                    }
                });
            }
            if (head.header.level - this._foundAt >= 0) {
                return this._foundAt;
            }
        }), operators_1.filter((x) => x !== undefined), operators_1.first(), operators_1.shareReplay());
        this._foundAt = Number.POSITIVE_INFINITY;
        if (utils_1.validateOperation(this.hash) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidOperationHashError(this.hash);
        }
        this.confirmed$
            .pipe(operators_1.first(), operators_1.catchError(() => {
            return rxjs_1.of(rxjs_1.EMPTY);
        }))
            .subscribe();
    }
    get includedInBlock() {
        return this._foundAt;
    }
    get revealOperation() {
        return (Array.isArray(this.results) &&
            this.results.find((op) => op.kind === 'reveal'));
    }
    get revealStatus() {
        if (this.revealOperation) {
            return this.revealOperation.metadata.operation_result.status;
        }
        else {
            return 'unknown';
        }
    }
    get status() {
        return (this.results.map((result) => {
            if (types_1.hasMetadataWithResult(result)) {
                return result.metadata.operation_result.status;
            }
            else {
                return 'unknown';
            }
        })[0] || 'unknown');
    }
    /**
     *
     * @param confirmations [0] Number of confirmation to wait for
     * @param timeout [180] Timeout
     */
    confirmation(confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof confirmations !== 'undefined' && confirmations < 1) {
                throw new error_1.InvalidConfirmationCountError('Confirmation count must be at least 1');
            }
            const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;
            this._pollingConfig$.next({
                timeout: timeout || confirmationPollingTimeoutSecond,
            });
            const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;
            return new Promise((resolve, reject) => {
                this.confirmed$
                    .pipe(operators_1.switchMap(() => this.currentHead$), operators_1.filter((head) => head.header.level - this._foundAt >= conf - 1), operators_1.first())
                    .subscribe((_) => {
                    resolve(this._foundAt + (conf - 1));
                }, reject);
            });
        });
    }
}
exports.Operation = Operation;
//# sourceMappingURL=operations.js.map