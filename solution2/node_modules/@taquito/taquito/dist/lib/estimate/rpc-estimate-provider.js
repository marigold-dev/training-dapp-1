"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCEstimateProvider = void 0;
const rpc_1 = require("@taquito/rpc");
const bignumber_js_1 = require("bignumber.js");
const constants_1 = require("../constants");
const operation_emitter_1 = require("../operations/operation-emitter");
const operation_errors_1 = require("../operations/operation-errors");
const types_1 = require("../operations/types");
const estimate_1 = require("./estimate");
const prepare_1 = require("../contract/prepare");
const utils_1 = require("@taquito/utils");
const error_1 = require("./error");
const mergeLimits = (userDefinedLimit, defaultLimits) => {
    return {
        fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,
        gasLimit: typeof userDefinedLimit.gasLimit === 'undefined'
            ? defaultLimits.gasLimit
            : userDefinedLimit.gasLimit,
        storageLimit: typeof userDefinedLimit.storageLimit === 'undefined'
            ? defaultLimits.storageLimit
            : userDefinedLimit.storageLimit,
    };
};
// RPC requires a signature but does not verify it
const SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';
class RPCEstimateProvider extends operation_emitter_1.OperationEmitter {
    constructor() {
        super(...arguments);
        this.ALLOCATION_STORAGE = 257;
        this.ORIGINATION_STORAGE = 257;
        this.OP_SIZE_REVEAL = 128;
    }
    getKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const isSignerConfigured = this.context.isAnySignerConfigured();
            return {
                publicKeyHash: isSignerConfigured
                    ? yield this.signer.publicKeyHash()
                    : yield this.context.walletProvider.getPKH(),
                publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined,
            };
        });
    }
    // Maximum values defined by the protocol
    getAccountLimits(pkh, constants, numberOfOps) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.context.readProvider.getBalance(pkh, 'head');
            const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, } = constants;
            return {
                fee: 0,
                gasLimit: numberOfOps
                    ? Math.floor(this.ajustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber())
                    : hard_gas_limit_per_operation.toNumber(),
                storageLimit: Math.floor(bignumber_js_1.default.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()),
            };
        });
    }
    // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.
    // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,
    // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).
    // numberOfOps is incremented by 1 for safety in case a reveal operation is needed
    ajustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {
        return bignumber_js_1.default.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));
    }
    getEstimationPropertiesFromOperationContent(content, size, costPerByte, tx_rollup_origination_size) {
        const operationResults = operation_errors_1.flattenOperationResult({ contents: [content] });
        let totalGas = 0;
        let totalMilligas = 0;
        let totalStorage = 0;
        operationResults.forEach((result) => {
            totalStorage +=
                'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'
                    ? result.originated_contracts.length * this.ORIGINATION_STORAGE
                    : 0;
            totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;
            totalGas += Number(result.consumed_gas) || 0;
            totalMilligas += Number(result.consumed_milligas) || 0;
            totalStorage +=
                'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;
            totalStorage +=
                'storage_size' in result && 'global_address' in result
                    ? Number(result.storage_size) || 0
                    : 0;
            totalStorage += 'originated_rollup' in result ? tx_rollup_origination_size : 0;
        });
        if (totalGas !== 0 && totalMilligas === 0) {
            // This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.
            totalMilligas = totalGas * 1000;
        }
        if (types_1.isOpWithFee(content)) {
            return {
                milligasLimit: totalMilligas || 0,
                storageLimit: Number(totalStorage || 0),
                opSize: size,
                minimalFeePerStorageByteMutez: costPerByte.toNumber(),
            };
        }
        else {
            return {
                milligasLimit: 0,
                storageLimit: 0,
                opSize: size,
                minimalFeePerStorageByteMutez: costPerByte.toNumber(),
                baseFeeMutez: 0,
            };
        }
    }
    prepareEstimate(params, constants, pkh) {
        return __awaiter(this, void 0, void 0, function* () {
            const prepared = yield this.prepareOperation(params, pkh);
            const { opbytes, opOb: { branch, contents }, } = yield this.forge(prepared);
            const operation = {
                operation: { branch, contents, signature: SIGNATURE_STUB },
                chain_id: yield this.context.readProvider.getChainId(),
            };
            const { opResponse } = yield this.simulate(operation);
            const { cost_per_byte, tx_rollup_origination_size } = constants;
            const errors = [...operation_errors_1.flattenErrors(opResponse, 'backtracked'), ...operation_errors_1.flattenErrors(opResponse)];
            // Fail early in case of errors
            if (errors.length) {
                throw new operation_errors_1.TezosOperationError(errors, 'Error occurred during estimation');
            }
            let numberOfOps = 1;
            if (Array.isArray(params.operation) && params.operation.length > 1) {
                numberOfOps =
                    opResponse.contents[0].kind === 'reveal'
                        ? params.operation.length - 1
                        : params.operation.length;
            }
            return opResponse.contents.map((x) => {
                return this.getEstimationPropertiesFromOperationContent(x, 
                // TODO: Calculate a specific opSize for each operation.
                x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte, tx_rollup_origination_size !== null && tx_rollup_origination_size !== void 0 ? tx_rollup_origination_size : 0);
            });
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an origination operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param OriginationOperation Originate operation parameter
     */
    originate(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKeyHash } = yield this.getKeys();
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
            const op = yield prepare_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS))));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], publicKeyHash);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], publicKeyHash) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: publicKeyHash }, protocolConstants, publicKeyHash);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an transfer operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param TransferOperation Originate operation parameter
     */
    transfer(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            if (utils_1.validateAddress(rest.to) !== utils_1.ValidationResult.VALID) {
                throw new utils_1.InvalidAddressError(rest.to);
            }
            if (rest.source && utils_1.validateAddress(rest.source) !== utils_1.ValidationResult.VALID) {
                throw new utils_1.InvalidAddressError(rest.source);
            }
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield prepare_1.createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a delegate operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    setDelegate(_a) {
        var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, ["fee", "gasLimit", "storageLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            if (rest.source && utils_1.validateAddress(rest.source) !== utils_1.ValidationResult.VALID) {
                throw new utils_1.InvalidAddressError(rest.source);
            }
            if (rest.delegate && utils_1.validateAddress(rest.delegate) !== utils_1.ValidationResult.VALID) {
                throw new utils_1.InvalidAddressError(rest.delegate);
            }
            const pkh = (yield this.getKeys()).publicKeyHash;
            const sourceOrDefault = rest.source || pkh;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(sourceOrDefault, protocolConstants);
            const op = yield prepare_1.createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch
     *
     * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.
     */
    batch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKeyHash } = yield this.getKeys();
            let operations = [];
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants, params.length);
            for (const param of params) {
                switch (param.kind) {
                    case rpc_1.OpKind.TRANSACTION:
                        operations.push(yield prepare_1.createTransferOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                        break;
                    case rpc_1.OpKind.ORIGINATION:
                        operations.push(yield prepare_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))));
                        break;
                    case rpc_1.OpKind.DELEGATION:
                        operations.push(yield prepare_1.createSetDelegateOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                        break;
                    case rpc_1.OpKind.ACTIVATION:
                        operations.push(Object.assign(Object.assign({}, param), DEFAULT_PARAMS));
                        break;
                    case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                        operations.push(yield prepare_1.createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                        break;
                    case rpc_1.OpKind.TX_ROLLUP_ORIGINATION:
                        operations.push(yield prepare_1.createTxRollupOriginationOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                        break;
                    case rpc_1.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                        operations.push(yield prepare_1.createTxRollupBatchOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));
                        break;
                    default:
                        throw new utils_1.InvalidOperationKindError(params.kind);
                }
            }
            const isRevealNeeded = yield this.isRevealOpNeeded(operations, publicKeyHash);
            operations = isRevealNeeded ? yield this.addRevealOp(operations, publicKeyHash) : operations;
            const estimateProperties = yield this.prepareEstimate({ operation: operations, source: publicKeyHash }, protocolConstants, publicKeyHash);
            return estimate_1.Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a delegate operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    registerDelegate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield prepare_1.createRegisterDelegateOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), pkh);
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees to reveal the current account
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed
     *
     * @param Estimate
     */
    reveal(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKeyHash, publicKey } = yield this.getKeys();
            if (!publicKey) {
                throw new error_1.RevealEstimateError();
            }
            if (yield this.isAccountRevealRequired(publicKeyHash)) {
                const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
                const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);
                const op = yield prepare_1.createRevealOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), publicKeyHash, publicKey);
                const estimateProperties = yield this.prepareEstimate({ operation: op, source: publicKeyHash }, protocolConstants, publicKeyHash);
                return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
            }
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param params registerGlobalConstant operation parameter
     */
    registerGlobalConstant(_a) {
        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, ["fee", "storageLimit", "gasLimit"]);
        return __awaiter(this, void 0, void 0, function* () {
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield prepare_1.createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a rollup origination operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param TxRollupOriginateParams Originate tx rollup operation parameter
     */
    txRollupOriginate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            params = params ? params : {};
            const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield prepare_1.createTxRollupOriginationOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    /**
     *
     * @description Estimate gasLimit, storageLimit and fees for a tx rollup batch operation
     *
     * @returns An estimation of gasLimit, storageLimit and fees for the operation
     *
     * @param Estimate
     */
    txRollupSubmitBatch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { fee, storageLimit, gasLimit } = params, rest = __rest(params, ["fee", "storageLimit", "gasLimit"]);
            const pkh = (yield this.getKeys()).publicKeyHash;
            const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');
            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);
            const op = yield prepare_1.createTxRollupBatchOperation(Object.assign(Object.assign({}, rest), mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS)));
            const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);
            const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;
            const estimateProperties = yield this.prepareEstimate({ operation: ops, source: pkh }, protocolConstants, pkh);
            if (isRevealNeeded) {
                estimateProperties.shift();
            }
            return estimate_1.Estimate.createEstimateInstanceFromProperties(estimateProperties);
        });
    }
    addRevealOp(op, pkh) {
        return __awaiter(this, void 0, void 0, function* () {
            const { publicKey } = yield this.getKeys();
            if (!publicKey) {
                throw new error_1.RevealEstimateError();
            }
            op.unshift(yield prepare_1.createRevealOperation(Object.assign({
                fee: constants_1.DEFAULT_FEE.REVEAL,
                gasLimit: constants_1.DEFAULT_GAS_LIMIT.REVEAL,
                storageLimit: constants_1.DEFAULT_STORAGE_LIMIT.REVEAL,
            }), pkh, yield this.signer.publicKey()));
            return op;
        });
    }
}
exports.RPCEstimateProvider = RPCEstimateProvider;
//# sourceMappingURL=rpc-estimate-provider.js.map