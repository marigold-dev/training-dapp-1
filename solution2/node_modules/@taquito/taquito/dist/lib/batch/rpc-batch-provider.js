"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCBatchProvider = exports.OperationBatch = exports.BATCH_KINDS = void 0;
const prepare_1 = require("../contract/prepare");
const batch_operation_1 = require("../operations/batch-operation");
const operation_emitter_1 = require("../operations/operation-emitter");
const types_1 = require("../operations/types");
const rpc_1 = require("@taquito/rpc");
const utils_1 = require("@taquito/utils");
exports.BATCH_KINDS = [
    rpc_1.OpKind.ACTIVATION,
    rpc_1.OpKind.ORIGINATION,
    rpc_1.OpKind.TRANSACTION,
    rpc_1.OpKind.DELEGATION,
];
class OperationBatch extends operation_emitter_1.OperationEmitter {
    constructor(context, estimator) {
        super(context);
        this.estimator = estimator;
        this.operations = [];
    }
    /**
     *
     * @description Add a transaction operation to the batch
     *
     * @param params Transfer operation parameter
     */
    withTransfer(params) {
        if (utils_1.validateAddress(params.to) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidAddressError(params.to);
        }
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.TRANSACTION }, params));
        return this;
    }
    /**
     *
     * @description Add a transaction operation to the batch
     *
     * @param params Transfer operation parameter
     */
    withContractCall(params) {
        return this.withTransfer(params.toTransferParams());
    }
    /**
     *
     * @description Add a delegation operation to the batch
     *
     * @param params Delegation operation parameter
     */
    withDelegation(params) {
        if (params.source && utils_1.validateAddress(params.source) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidAddressError(params.source);
        }
        if (params.delegate && utils_1.validateAddress(params.delegate) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidAddressError(params.delegate);
        }
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.DELEGATION }, params));
        return this;
    }
    /**
     *
     * @description Add an activation operation to the batch
     *
     * @param params Activation operation parameter
     */
    withActivation({ pkh, secret }) {
        if (utils_1.validateKeyHash(pkh) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidKeyHashError(pkh);
        }
        this.operations.push({ kind: rpc_1.OpKind.ACTIVATION, pkh, secret });
        return this;
    }
    /**
     *
     * @description Add an origination operation to the batch
     *
     * @param params Origination operation parameter
     */
    withOrigination(params) {
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.ORIGINATION }, params));
        return this;
    }
    /**
     *
     * @description Add an operation to register a global constant to the batch
     *
     * @param params RegisterGlobalConstant operation parameter
     */
    withRegisterGlobalConstant(params) {
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT }, params));
        return this;
    }
    /**
     *
     * @description Add an operation to originate a rollup to the batch
     *
     * @param params Rollup origination operation parameter
     */
    withTxRollupOrigination(params) {
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.TX_ROLLUP_ORIGINATION }, params));
        return this;
    }
    /**
     *
     * @description Add an operation to submit a tx rollup batch to the batch
     *
     * @param params Tx rollup batch operation parameter
     */
    withTxRollupSubmitBatch(params) {
        this.operations.push(Object.assign({ kind: rpc_1.OpKind.TX_ROLLUP_SUBMIT_BATCH }, params));
        return this;
    }
    getRPCOp(param) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (param.kind) {
                case rpc_1.OpKind.TRANSACTION:
                    return prepare_1.createTransferOperation(Object.assign({}, param));
                case rpc_1.OpKind.ORIGINATION:
                    return prepare_1.createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));
                case rpc_1.OpKind.DELEGATION:
                    return prepare_1.createSetDelegateOperation(Object.assign({}, param));
                case rpc_1.OpKind.ACTIVATION:
                    return Object.assign({}, param);
                case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                    return prepare_1.createRegisterGlobalConstantOperation(Object.assign({}, param));
                case rpc_1.OpKind.TX_ROLLUP_ORIGINATION:
                    return prepare_1.createTxRollupOriginationOperation(Object.assign({}, param));
                case rpc_1.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                    return prepare_1.createTxRollupBatchOperation(Object.assign({}, param));
                default:
                    throw new utils_1.InvalidOperationKindError(param.kind);
            }
        });
    }
    /**
     *
     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
     *
     * @param params Operations parameter
     */
    with(params) {
        for (const param of params) {
            switch (param.kind) {
                case rpc_1.OpKind.TRANSACTION:
                    this.withTransfer(param);
                    break;
                case rpc_1.OpKind.ORIGINATION:
                    this.withOrigination(param);
                    break;
                case rpc_1.OpKind.DELEGATION:
                    this.withDelegation(param);
                    break;
                case rpc_1.OpKind.ACTIVATION:
                    this.withActivation(param);
                    break;
                case rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT:
                    this.withRegisterGlobalConstant(param);
                    break;
                case rpc_1.OpKind.TX_ROLLUP_ORIGINATION:
                    this.withTxRollupOrigination(param);
                    break;
                case rpc_1.OpKind.TX_ROLLUP_SUBMIT_BATCH:
                    this.withTxRollupSubmitBatch(param);
                    break;
                default:
                    throw new utils_1.InvalidOperationKindError(param.kind);
            }
        }
        return this;
    }
    /**
     *
     * @description Forge and Inject the operation batch
     *
     * @param params Optionally specify the source of the operation
     */
    send(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKeyHash = yield this.signer.publicKeyHash();
            const publicKey = yield this.signer.publicKey();
            const estimates = yield this.estimator.batch(this.operations);
            const revealNeeded = yield this.isRevealOpNeeded(this.operations, publicKeyHash);
            let i = revealNeeded ? 1 : 0;
            const ops = [];
            for (const op of this.operations) {
                if (types_1.isOpWithFee(op)) {
                    const estimated = yield this.estimate(op, () => __awaiter(this, void 0, void 0, function* () { return estimates[i]; }));
                    ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), estimated)));
                }
                else {
                    ops.push(Object.assign({}, op));
                }
                i++;
            }
            if (revealNeeded) {
                const reveal = { kind: rpc_1.OpKind.REVEAL };
                const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () { return estimates[0]; }));
                ops.unshift(yield prepare_1.createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));
            }
            const source = (params && params.source) || publicKeyHash;
            const prepared = yield this.prepareOperation({
                operation: ops,
                source,
            });
            const opBytes = yield this.forge(prepared);
            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);
            return new batch_operation_1.BatchOperation(hash, ops, source, forgedBytes, opResponse, context);
        });
    }
}
exports.OperationBatch = OperationBatch;
class RPCBatchProvider {
    constructor(context, estimator) {
        this.context = context;
        this.estimator = estimator;
    }
    /***
     *
     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch
     *
     * @param params List of operation to batch together
     */
    batch(params) {
        const batch = new OperationBatch(this.context, this.estimator);
        if (Array.isArray(params)) {
            batch.with(params);
        }
        return batch;
    }
}
exports.RPCBatchProvider = RPCBatchProvider;
//# sourceMappingURL=rpc-batch-provider.js.map