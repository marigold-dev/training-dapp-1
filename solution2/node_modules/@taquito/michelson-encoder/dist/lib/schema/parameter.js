"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterSchema = void 0;
const createToken_1 = require("../tokens/createToken");
const token_1 = require("../tokens/token");
const or_1 = require("../tokens/or");
const option_1 = require("../tokens/option");
const error_1 = require("./error");
/**
 * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.
 */
class ParameterSchema {
    constructor(val) {
        this.root = createToken_1.createToken(val, 0);
    }
    static fromRPCResponse(val) {
        const parameter = val &&
            val.script &&
            Array.isArray(val.script.code) &&
            val.script.code.find((x) => x.prim === 'parameter');
        if (!parameter || !Array.isArray(parameter.args)) {
            throw new error_1.InvalidRpcResponseError(val.script);
        }
        return new ParameterSchema(parameter.args[0]);
    }
    get isMultipleEntryPoint() {
        return (this.root instanceof or_1.OrToken ||
            (this.root instanceof option_1.OptionToken && this.root.subToken() instanceof or_1.OrToken));
    }
    get hasAnnotation() {
        if (this.isMultipleEntryPoint) {
            return Object.keys(this.ExtractSchema())[0] !== '0';
        }
        else {
            return true;
        }
    }
    Execute(val, semantics) {
        return this.root.Execute(val, semantics);
    }
    Encode(...args) {
        try {
            return this.root.Encode(args.reverse());
        }
        catch (ex) {
            if (ex instanceof token_1.TokenValidationError) {
                throw ex;
            }
            throw new error_1.ParameterEncodingError('Unable to encode parameter', args.toString(), ex);
        }
    }
    EncodeObject(value, semantics) {
        try {
            return this.root.EncodeObject(value, semantics);
        }
        catch (ex) {
            if (ex instanceof token_1.TokenValidationError) {
                throw ex;
            }
            throw new error_1.ParameterEncodingError('Unable to encode parameter object', value, ex);
        }
    }
    /**
     * @deprecated ExtractSchema has been deprecated in favor of generateSchema
     *
     */
    ExtractSchema() {
        return this.root.ExtractSchema();
    }
    /**
     * @description Produce a schema grouping together all the entry points of a contract.
     */
    generateSchema() {
        return this.root.generateSchema();
    }
    ExtractSignatures() {
        return this.root.ExtractSignature();
    }
}
exports.ParameterSchema = ParameterSchema;
//# sourceMappingURL=parameter.js.map