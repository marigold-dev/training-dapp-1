"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewSchema = void 0;
const createToken_1 = require("../tokens/createToken");
const error_1 = require("./error");
class ViewSchema {
    constructor(val) {
        if (val.length !== 4 || !('string' in val[0])) {
            throw new error_1.InvalidScriptError(`Invalid on-chain view: ${JSON.stringify(val)}`);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.viewName = val[0]['string'];
        this.viewArgsType = val[1];
        this.viewReturnType = val[2];
        this.instructions = val[3];
        this.rootArgsType = createToken_1.createToken(this.viewArgsType, 0);
        this.rootReturnType = createToken_1.createToken(this.viewReturnType, 0);
    }
    /**
     *
     * @description Create an instance of ViewSchema for each view in a script
     *
     * @param val contract script obtained from the RPC
     * @returns array of ViewSchema or empty array if there is no view in the contract
     */
    static fromRPCResponse(val) {
        const allViewSchema = [];
        const views = val &&
            val.script &&
            Array.isArray(val.script.code) &&
            val.script.code.filter((x) => x.prim === 'view');
        if (views) {
            views.forEach((view) => {
                if (!view.args || view.args.length !== 4) {
                    throw new error_1.InvalidScriptError(`Invalid on-chain view found in the script: ${JSON.stringify(view)}`);
                }
                allViewSchema.push(new ViewSchema(view.args));
            });
        }
        return allViewSchema;
    }
    /**
     *
     * @description Transform the view parameter into Michelson
     *
     * @param args parameter of the view in js format
     * @returns parameter of the view in Michelson
     */
    encodeViewArgs(args) {
        try {
            return this.rootArgsType.EncodeObject(args);
        }
        catch (ex) {
            throw new error_1.ViewEncodingError(this.viewName, ex);
        }
    }
    /**
     *
     * @description Transform the view result from Michelson to readable data
     *
     * @param val result of the view in JSON Michelson
     * @param semantics optional semantics to override the default decoding behavior
     * @returns result of the view in a readable format
     */
    decodeViewResult(val, semantics) {
        return this.rootReturnType.Execute(val, semantics);
    }
    /**
     *
     * @description Return the signature of the view parameter
     */
    extractArgsSchema() {
        return this.rootArgsType.ExtractSchema();
    }
    /**
     *
     * @description Return the format of the view result
     */
    extractResultSchema() {
        return this.rootReturnType.ExtractSchema();
    }
}
exports.ViewSchema = ViewSchema;
//# sourceMappingURL=view-schema.js.map