"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapToken = exports.MapValidationError = void 0;
const michelson_map_1 = require("../michelson-map");
const token_1 = require("./token");
class MapValidationError extends token_1.TokenValidationError {
    constructor(value, token, message) {
        super(value, token, message);
        this.value = value;
        this.token = token;
        this.name = 'MapValidationError';
    }
}
exports.MapValidationError = MapValidationError;
class MapToken extends token_1.Token {
    constructor(val, idx, fac) {
        super(val, idx, fac);
        this.val = val;
        this.idx = idx;
        this.fac = fac;
    }
    get ValueSchema() {
        return this.createToken(this.val.args[1], 0);
    }
    get KeySchema() {
        return this.createToken(this.val.args[0], 0);
    }
    isValid(value) {
        if (michelson_map_1.MichelsonMap.isMichelsonMap(value)) {
            return null;
        }
        return new MapValidationError(value, this, 'Value must be a MichelsonMap');
    }
    Execute(val, semantics) {
        const map = new michelson_map_1.MichelsonMap(this.val);
        val.forEach((current) => {
            map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));
        });
        return map;
    }
    objLitToMichelsonMap(val) {
        if (val instanceof michelson_map_1.MichelsonMap)
            return val;
        if (typeof val === 'object') {
            if (Object.keys(val).length === 0) {
                return new michelson_map_1.MichelsonMap();
            }
            else {
                return michelson_map_1.MichelsonMap.fromLiteral(val);
            }
        }
        return val;
    }
    Encode(args) {
        const val = this.objLitToMichelsonMap(args.pop());
        const err = this.isValid(val);
        if (err) {
            throw err;
        }
        return Array.from(val.keys())
            .sort((a, b) => this.KeySchema.compare(a, b))
            .map((key) => {
            return {
                prim: 'Elt',
                args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
            };
        });
    }
    EncodeObject(args, semantic) {
        const val = this.objLitToMichelsonMap(args);
        const err = this.isValid(val);
        if (err) {
            throw err;
        }
        if (semantic && semantic[MapToken.prim]) {
            return semantic[MapToken.prim](val);
        }
        return Array.from(val.keys())
            .sort((a, b) => this.KeySchema.compare(a, b))
            .map((key) => {
            return {
                prim: 'Elt',
                args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],
            };
        });
    }
    /**
     * @deprecated ExtractSchema has been deprecated in favor of generateSchema
     *
     */
    ExtractSchema() {
        return {
            map: {
                key: this.KeySchema.ExtractSchema(),
                value: this.ValueSchema.ExtractSchema(),
            },
        };
    }
    generateSchema() {
        return {
            __michelsonType: MapToken.prim,
            schema: {
                key: this.KeySchema.generateSchema(),
                value: this.ValueSchema.generateSchema(),
            },
        };
    }
    findAndReturnTokens(tokenToFind, tokens) {
        if (MapToken.prim === tokenToFind) {
            tokens.push(this);
        }
        this.KeySchema.findAndReturnTokens(tokenToFind, tokens);
        this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);
        return tokens;
    }
}
exports.MapToken = MapToken;
MapToken.prim = 'map';
//# sourceMappingURL=map.js.map