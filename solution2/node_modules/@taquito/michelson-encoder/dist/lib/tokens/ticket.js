"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TicketToken = exports.EncodeTicketError = void 0;
const int_1 = require("./comparable/int");
const contract_1 = require("./contract");
const token_1 = require("./token");
/**
 *  @category Error
 *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain
 */
class EncodeTicketError extends Error {
    constructor() {
        super('Tickets cannot be sent to the blockchain; they are created on-chain');
        this.name = 'TicketEncodeError';
    }
}
exports.EncodeTicketError = EncodeTicketError;
const ticketerType = { prim: 'contract' };
const amountType = { prim: 'int' };
class TicketToken extends token_1.Token {
    constructor(val, idx, fac) {
        super(val, idx, fac);
        this.val = val;
        this.idx = idx;
        this.fac = fac;
    }
    get valueToken() {
        return this.createToken(this.val.args[0], this.idx);
    }
    Encode(_args) {
        throw new EncodeTicketError();
    }
    EncodeObject(args, semantic) {
        if (semantic && semantic[TicketToken.prim]) {
            return semantic[TicketToken.prim](args, this.val);
        }
        throw new EncodeTicketError();
    }
    Execute(val, semantics) {
        if (semantics && semantics[TicketToken.prim]) {
            return semantics[TicketToken.prim](val, this.val);
        }
        const ticketer = this.createToken(ticketerType, this.idx);
        const value = this.valueToken;
        const amount = this.createToken(amountType, this.idx);
        if (undefined === val.args[2] && undefined !== val.args[1].args) {
            return {
                ticketer: ticketer.Execute(val.args[0], semantics),
                value: value.Execute(val.args[1].args[0], semantics),
                amount: amount.Execute(val.args[1].args[1], semantics),
            };
        }
        return {
            ticketer: ticketer.Execute(val.args[0], semantics),
            value: value.Execute(val.args[1], semantics),
            amount: amount.Execute(val.args[2], semantics),
        };
    }
    /**
     * @deprecated ExtractSchema has been deprecated in favor of generateSchema
     *
     */
    ExtractSchema() {
        return {
            ticketer: contract_1.ContractToken.prim,
            value: this.valueToken.ExtractSchema(),
            amount: int_1.IntToken.prim,
        };
    }
    generateSchema() {
        return {
            __michelsonType: TicketToken.prim,
            schema: {
                value: this.valueToken.generateSchema(),
                ticketer: {
                    __michelsonType: contract_1.ContractToken.prim,
                    schema: contract_1.ContractToken.prim,
                },
                amount: {
                    __michelsonType: int_1.IntToken.prim,
                    schema: int_1.IntToken.prim,
                },
            },
        };
    }
    findAndReturnTokens(tokenToFind, tokens) {
        if (TicketToken.prim === tokenToFind) {
            tokens.push(this);
        }
        this.valueToken.findAndReturnTokens(tokenToFind, tokens);
        return tokens;
    }
}
exports.TicketToken = TicketToken;
TicketToken.prim = 'ticket';
//# sourceMappingURL=ticket.js.map